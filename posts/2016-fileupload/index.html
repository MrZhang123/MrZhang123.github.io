<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>文件上传（一）---H5 file API，canvas | 博客</title>

<meta name="generator" content="Hugo Eureka 0.8.3-dev" />
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>









<meta name="description"
  content="最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"文件上传（一）---H5 file API，canvas",
      "item":"/posts/2016-fileupload/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/2016-fileupload/"
    },
    "headline": "文件上传（一）---H5 file API，canvas | 博客","datePublished": "2016-03-31T23:35:12+00:00",
    "dateModified": "2016-03-31T23:35:12+00:00",
    "wordCount":  483 ,
    "publisher": {
        "@type": "Person",
        "name": "博客",
        },
    "description": "\u003cp\u003e最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。\u003c\/p\u003e"
}
</script><meta property="og:title" content="文件上传（一）---H5 file API，canvas | 博客" />
<meta property="og:type" content="article" />



<meta property="og:url" content="/posts/2016-fileupload/" />




<meta property="og:description" content="最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="博客" />






<meta property="article:published_time" content="2016-03-31T23:35:12&#43;00:00" />


<meta property="article:modified_time" content="2016-03-31T23:35:12&#43;00:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="H5" />

<meta property="article:tag" content="file" />

<meta property="article:tag" content="canvas" />





<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">博客</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">文件上传（一）---H5 file API，canvas</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2016-03-31</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>3分钟阅读时长</span>
    </div>
    
    
    <div class="mr-6 my-2">
        <i class="fas fa-folder mr-1"></i>
        
        <a href="/categories/javascript/" class="hover:text-eureka">Javascript</a>
        
    </div>
    

    
</div>
        
        
        

        <div class="content">
            <p>最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。</p>
<h2 id="一做好htmlcss样式">一.做好HTML，CSS样式</h2>
<p>这里很简单，就是写一个HTML+CSS的文件，让我们的上传看起来像那么回事儿，这里不细说，代码如下：</p>
<h3 id="html">html</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;fileUploader&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;upbox&quot;&gt;
        &lt;h1&gt;测试&lt;/h1&gt;
        &lt;input id=&quot;uploader&quot; type=&quot;file&quot; multiple=&quot;multiple&quot; name=&quot;file&quot; accept=&quot;image/*&quot;&gt;
    &lt;/div&gt;    
    &lt;a id=&quot;test&quot; href=&quot;&quot;&gt;点击选择上传图片&lt;/a&gt;
    &lt;button type=&quot;button&quot; id=&quot;button&quot;&gt;上传&lt;/button&gt;
    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="indexcss">index.css</h3>
<pre><code class="language-css">.upbox{width: 100%;height: 500px;border: 3px dashed #000;position: relative;}
#uploader{display: block;width: 100%;height: 100%;opacity: 0;position: absolute;left: 0;top: 0;cursor: pointer;}
h1{position: absolute;left: 45%;top: 40%;}
button{width: 100px;height: 50px;float: right;}
.img-content{width: 120px;height: 120px;border: 1px solid #000;margin: 20px;float: left;position: relative; z-index: 5;}
.img-box{width: 100%;height: 100%;}
.img-box img{display: block; width: 100%;height: 100%;}
</code></pre>
<h2 id="二用户多选文件并读取用户选择的文件">二.用户多选文件并读取用户选择的文件</h2>
<h3 id="1让input实现多文件选择">1.让input实现多文件选择</h3>
<p>用户在点击input区域后，可以选择文件，H5支持多文件选择，只需要像下面这样写就可以：</p>
<pre><code class="language-html">&lt;input id=&quot;uploader&quot; type=&quot;file&quot; multiple=&quot;multiple&quot; name=&quot;file&quot; accept=&quot;image/*&quot;&gt;
</code></pre>
<p>在上面代码中，设置multiple可以让input实现文件多选，accept则是允许用户选择什么文件，这里我们要写图片上传，所以接受所有的图片的类型，也为后文的转换上传图片的文件格式奠定基础。</p>
<h3 id="2利用filereader对象读取源文件">2.利用FileReader对象读取源文件</h3>
<p>H5的File接口提供了文件的信息以及文件内容的存取的方法。File对象是用户在input元素上选择文件后返回的FileList对象，所以，通过File对象可以获得用户选择的文件。代码如下：</p>
<pre><code class="language-javascript">var uploader=document.querySelectorAll('#uploader')[0];
uploader.addEventListener('change',function (event) {
    var e=event||window.event;
    var target=e.target;
    var files=target.files;
});
</code></pre>
<p>这里可以获得用户选择的文件，但是因为我们要利用用户选择的源文件生成缩略图，所以需要需要读取的是用户在计算机上存储的源文件，H5提供了FileReader对象，该对象允许web应用程序异步读取存储在用户计算机上的文件（或者元素数据缓冲）内容。</p>
<h4 id="filereader对象提供了readasdataurl方法">FileReader对象提供了readAsDataURL()方法：</h4>
<h4 id="readasdataurl">readAsDataURL()</h4>
<p>开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.参数file为将要读取的Blob对象或者File对象.
所以拿到用户选择的源文件的代码如下：</p>
<pre><code class="language-javascript">var filesLen;
var uploader=document.querySelectorAll('#uploader')[0];
uploader.addEventListener('change',function (event) {
    var e=event||window.event;
    var target=e.target;
    var files=target.files;
    filesLen=files.length;
    for(let i=0;i&lt;filesLen;i++){
        var reader=new FileReader();
        //文件读取结束后要做的事
        reader.onload=function (event) {
            //读取用户选择的文件
            var fileURL=event.target.result;
        }
        reader.readAsDataURL(files[i]);
    }
});

</code></pre>
<p>因为是读取多个文件，所以需要使用for循环去读取每一个文件（这意味着FileReader一次只读取一个文件，异步读取），这样就拿到了用户选择的图片的源文件，该源文件被读取为base64编码，这位下一步，生成缩略图做了基础。</p>
<h2 id="三利用canvas生成缩略图">三.利用canvas生成缩略图</h2>
<p>H5的canvas提供了drawImage和toDataURL两个方法</p>
<h3 id="1drawimage">1.drawImage()</h3>
<p>drawImage()方法在画布上绘制图像，画布或视频，同时也能绘制图像的某个部分或者增加减少图像的尺寸。在javascript中有三种语法，分别如下：</p>
<h4 id="在画布上定位图像">在画布上定位图像</h4>
<pre><code class="language-javascript">context.drawImage(img,x,y);
</code></pre>
<h4 id="在画布上定位图像并规定图像的宽度和高度">在画布上定位图像并规定图像的宽度和高度</h4>
<pre><code class="language-javascript">context.drawImage(img,x,y,width,height);
</code></pre>
<p>正是这一点儿让利用canvas压缩图片成为可能（本身生成缩略图也是在更改图片大小）</p>
<h4 id="剪切图像并在画布上定位被剪切部分">剪切图像并在画布上定位被剪切部分</h4>
<pre><code class="language-javascript">context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
</code></pre>
<p>以上参数值对应如下：
<img src="./canshu.PNG" alt="mahua"></p>
<h3 id="2todataurl">2.toDataURL()</h3>
<p>toDataURL()方法回传含有图像和参数设置特定格式的dataURLs，回传的图像解析度为96dpi。同样通过toDataURL()可以方便的将图片转换为base64编码，但是这里需要注意两点：</p>
<ul>
<li>如果canvas的高度或者宽度为0，则回传的字符串为<code>data:,</code>。</li>
<li>如果要求图像类型并非image/png，但是回传的类型却是data:image/png，表示要求的图像类型并不支持。</li>
</ul>
<p>表达式如下：</p>
<pre><code class="language-javascript">canvas.toDataURL(type,encoderOptions);
</code></pre>
<p>type：图片的格式，预设为image/png
encoderOptions：生成的图片的品质，为0~1之间的数字，如果只不在该范围内，则使用默认值，其他会忽略</p>
<h3 id="生成缩略图代码实现">生成缩略图代码实现</h3>
<p>基于以上两个canvas方法，可以写出生成缩略图的方法，代码如下：</p>
<pre><code class="language-javascript">//创建缩略图样式
function createThumbnailFromUrl(context,fileURL) {
     //创建元素
     var img=document.createElement('img'),
         imgBox=document.createElement('div'),
         imgContent=document.createElement('div');
     //添加Class    
     imgBox.classList.add('img-box');
     imgContent.classList.add('img-content');
     //动态插入创建的元素 
     context.appendChild(imgContent);
     imgContent.appendChild(imgBox);
     imgBox.appendChild(img);
     
     //创建canvas重绘缩略图    
     var canvas=document.createElement('canvas');
     var context=canvas.getContext('2d'); 
     // 创建image图片对象
     var image=new Image();
     image.src=fileURL;
     image.onload=function () {
        canvas.width=120;
        canvas.height=120*(image.height/image.width);
        context.drawImage(image,0,0,canvas.width,canvas.height);
        img.src=canvas.toDataURL('image/png',0.5);  
     }  
}
</code></pre>
<p>这里，为了拿到图片对象，也就是拿到要转换的图片，我们新建一个图片对象，<font color="red">然后将图片对象的src赋值为FileReader拿到的FileURL，这样就拿到了用户选择上传的图片，这就将用户选择的文件与canvas联系起来</font>，接下来就进行处理，等图片读取完成后，进行cnavas操作，最后把生成的base64图片编码直接赋值给动态创建的缩略图img，这样就实现了用户在选择完要上传的图片后生成缩略图。</p>
<h2 id="四将要上传的图片利用canvas进行压缩改变格式---遇到js中的异步执行">四.将要上传的图片利用canvas进行压缩，改变格式&mdash;遇到js中的异步执行</h2>
<p>canvas压缩，更改图片格式的实现就是上面生成缩略图的方法，但是我在写这里的时候遇到了一个问题，就是javascript中异步执行机制。
我在javascript中写了一个函数，代码如下：</p>
<pre><code class="language-javascript">function changeImg(fileURL) {
     //创建canvas重绘缩略图    
     var canvas=document.createElement('canvas');
     var context=canvas.getContext('2d'); 
     // 创建image对象
     var image=new Image();
     //这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高
     image.src=fileURL;
     image.onload=function () {
        canvas.width=image.width;
        canvas.height=image.height;
        context.drawImage(image,0,0,canvas.width,canvas.height);
        newFile=canvas.toDataURL('image/png',0.5);
        //这里的return就是问题的所在
        return newFile
     }
}
</code></pre>
<p>本来我的想法是通过写一个changeImg函数，在文件读取完成后，进行图片压缩，然后再将转换后的图片利用return返回回来，然后继续操作。但是在执行的时候，发现浏览器一直报错，var newFile=changeImg(newFile)返回的是undefined的。经过询问高手，得知这里遇到了js中异步执行索带来的结果。关于js异步执行机制，我会在接下来做细致研究，并记录，现在说一下通过这个问题知道的一些东西。</p>
<h3 id="什么时候就会出现异步执行机制">什么时候就会出现异步执行机制</h3>
<p>当在js中出现回调，ajax，FileReader(暂时知道这三个)的时候，就会出现异步执行机制，简单举例：</p>
<pre><code class="language-javascript">var a;
a=ajax();//这里代表经过ajax执行后返回的值给a
console.log(a);//undefined
</code></pre>
<p>以上代码运行结果并不是ajax返回的值，而是undefined。ajax是 JavaScript和XML，这里我对异步的简单理解就是在代码执行的同时，ajax执行，可以想象，在浏览器中js代码执行的速度与通过ajax返回服务器回传的数据的速度，当ajax返回数据时，浏览器中代码早已执行完成console，所以输入的是undefined，同时这也解释了为什么ajax会存在当ajax调用成功后，再执行一个XXX。
所以在这里不能写return newFile，因为image.onload=function(){}也是异步的，我这里想到的办法就是在文件读取完成后，继续创建canvas，转换压缩图片（我感觉这个方法一点儿不好，暂时这么写）。
所以正确的代码如下：</p>
<pre><code class="language-javascript">//input选框change事件，取得文件，创建缩略图
uploader.addEventListener('change',function (event) {
    var e=event||window.event;
    var target=e.target;
    files=target.files;
    filesLen=files.length;
    for(let i=0;i&lt;filesLen;i++){
        var reader=new FileReader();
        //文件读取结束后要做的事
        reader.onload=function (event) {
            //读取用户选择的文件
            var fileURL=event.target.result;
            //根据读取的文件创建缩略图
            createThumbnailFromUrl(upbox,fileURL); 
            //上传前改变图片的格式
            //创建canvas重绘缩略图    
            var canvas=document.createElement('canvas');
            var context=canvas.getContext('2d'); 
            // 创建image对象
            var image=new Image();
            //这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高
            image.src=fileURL;
            image.onload=function () {
                canvas.width=image.width/2;
                canvas.height=image.width/2*(image.height/image.width);
                context.drawImage(image,0,0,canvas.width,canvas.height);
                newURL=canvas.toDataURL('image/jpeg',0.5);
                var base=newURL.substr(23); 
                newFile=atob(base);
            } 
        }
        reader.readAsDataURL(files[i]);
        filesArray.push(newURL);
    }
},false);
</code></pre>
<p>上面的代码实现了将经过转换的图片的base64编码放入一个数组中，将这些代码传给后台。
这里有一点，本身base64可以利用javascript的window.atob()实现base64的转码，但是简单利用该函数进行转码不能转回图片，还需要blob对象中的一些东西，关于这个对象我并没有深入研究，只是知道，对于该对象的研究我会在接下来继续研究。后台可以解析base64，所以直接把base64传给后台也可以，关于base64转码的实现可以参考稀土掘金中的文章<a href="http://gold.xitu.io/entry/560a726960b2ad8a22a538fc">@用Canvas技术压缩要上传的图片</a>。</p>
<h2 id="五利用xmlhttprequestformdata实现文件上传">五.利用XMLHttpRequest,FormData实现文件上传</h2>
<h3 id="1formdata对象">1.FormData对象</h3>
<p>利用<code>FormData</code>对象可以创建一系列键值对来模拟一个完整的表单，然后再使用XMLHttpRequest发送这个表单，这样就不用像传统的表单那样写form。所以在新建一个FormData对象：</p>
<pre><code class="language-javascript">var data=new FormData();
</code></pre>
<p>然后就可以使用append()方法向该对象里添加字段，形成可以发送给后台的键值对。</p>
<h3 id="2xmlhttprequest对象">2.XMLHttpRequest对象</h3>
<p>通过XMLHttpRequest可以很容易取回URL上的数据资源，可以取回的数据不仅仅是XML，除了支持HTTP还支持file，ftp协议。
通过下列代码可以获得一个XMLHttpRequest()实例。 然后利用open()初始化请求。</p>
<pre><code class="language-javascript">var xhr=new XMLHttpRequest();
xhr.open('post','uploader.php',true);
xhr.send(data);
</code></pre>
<h3 id="3open方法">3.open方法</h3>
<p>open可以写入的参数如下：</p>
<pre><code class="language-javascript">void open(
   DOMString method,
   DOMString url,
   optional boolean async,
   optional DOMString user,
   optional DOMString password
);
</code></pre>
<ul>
<li>method：请求所使用的HTTP方法：例如&rsquo;GET'，&lsquo;POST&rsquo;，&lsquo;PUT&rsquo;，&lsquo;DELETE&rsquo;等，但是如果下个参数是非HTTP(S)的URL，则忽略该参数。</li>
<li>url：该请求所要访问的URL</li>
<li>async：一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。</li>
<li>user：用户名,可选参数,为授权使用;默认参数为空string.</li>
<li>password：密码,可选参数,为授权使用;默认参数为空string.</li>
</ul>
<h3 id="4send方法">4.send()方法</h3>
<p>发送请求. 如果该请求是异步模式(默认),该方法会立刻返回. 相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回.</p>
<h2 id="综合以上简单的一个上传图片代码实现如下">综合以上，简单的一个上传图片代码实现如下：</h2>
<pre><code class="language-javascript">//创建缩略图样式
function createThumbnailFromUrl(context,fileURL) {
     //创建元素
     var img=document.createElement('img'),
         imgBox=document.createElement('div'),
         imgContent=document.createElement('div');
     //添加Class    
     imgBox.classList.add('img-box');
     imgContent.classList.add('img-content');
     //动态插入创建的元素 
     context.appendChild(imgContent);
     imgContent.appendChild(imgBox);
     imgBox.appendChild(img);
     //创建canvas重绘缩略图    
     var canvas=document.createElement('canvas');
     var context=canvas.getContext('2d'); 
     // 创建image对象
     var image=new Image();
     image.src=fileURL;
     image.onload=function () {
        canvas.width=120;
        canvas.height=120*(image.height/image.width);
        context.drawImage(image,0,0,canvas.width,canvas.height);
        img.src=canvas.toDataURL('image/png',0.5);  
     }  
}

window.addEventListener('load',function () {
    var uploader=document.querySelectorAll('#uploader')[0];
    var button=document.querySelectorAll('#button')[0];
    var upbox=document.querySelectorAll('.upbox')[0];
    var files,filesLen,newFileURL,newFile;
    var filesArray=[],newURL;
    var test=document.querySelectorAll('#test')[0];
    //input选框change事件，取得文件，创建缩略图
    uploader.addEventListener('change',function (event) {
        var e=event||window.event;
        var target=e.target;
        files=target.files;
        filesLen=files.length;
        for(let i=0;i&lt;filesLen;i++){
            var reader=new FileReader();
            //文件读取结束后要做的事
            reader.onload=function (event) {
                //读取用户选择的文件
                var fileURL=event.target.result;
                //根据读取的文件创建缩略图
                createThumbnailFromUrl(upbox,fileURL);
                //上传前改变图片的格式
                //创建canvas重绘缩略图    
                var canvas=document.createElement('canvas');
                var context=canvas.getContext('2d'); 
                // 创建image对象
                var image=new Image();//这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高
                image.src=fileURL;
                image.onload=function () {
                    canvas.width=image.width/2;
                    canvas.height=image.width/2*(image.height/image.width);
                    context.drawImage(image,0,0,canvas.width,canvas.height);
                    newURL=canvas.toDataURL('image/jpeg',0.5);
                    var base=newURL.substr(23); 
                    newFile=atob(base);
                } 
            }
            reader.readAsDataURL(files[i]);
            filesArray.push(newURL);
        }
    },false);
    //button按钮点击上传
    button.addEventListener('click',function () {
        if(filesLen.length!=0){
            var data=new FormData();
            var i=0;
            //将所有的经过转码后的base64组成的数组传给后台
            while(i&lt;filesLen){
                data.append('file'+i,filesArray[i]);
                i++;
            }
            var xhr = new XMLHttpRequest();
            xhr.open('post','uploader.php',true);
            xhr.onreadystatechange=function () {
                if(xhr.readyState==4){
                    console.log(xhr.responseText);
                }
            };
            xhr.send(data);
        }
    })
},false);
</code></pre>
        </div>
        
        <div class="my-4">
    
    <a href="/tags/h5/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#H5</a>
    
    <a href="/tags/file/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#file</a>
    
    <a href="/tags/canvas/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#canvas</a>
    
</div>
        
        
        


        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="/posts/2016-es6practice/" class="block">初探ES6——轮播图实践总结</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="/posts/2016-activeelement/" class="block">H5焦点管理---tabindex与document.activeElement</a>
        
    </div>
</div>

        



    </div>
    

    
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://www.wangchucheng.com/">C. Wang</a> and <a href="https://www.ruiqima.com/">R. Ma</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>