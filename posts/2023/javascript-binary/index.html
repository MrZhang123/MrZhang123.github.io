<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>聊一聊 JS 中的二进制 - Raymond</title><meta name="Description" content=""><meta property="og:title" content="聊一聊 JS 中的二进制" />
<meta property="og:description" content="在 JavaScript 中，有很多跟二进制相关的概念，例如 Buffer，TypedArray，ArrayBuffer，Blob，Stream 等等。那么这些概念彼" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mrzhang123.github.io/posts/2023/javascript-binary/" /><meta property="og:image" content="https://mrzhang123.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-18T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://mrzhang123.github.io/logo.png"/>

<meta name="twitter:title" content="聊一聊 JS 中的二进制"/>
<meta name="twitter:description" content="在 JavaScript 中，有很多跟二进制相关的概念，例如 Buffer，TypedArray，ArrayBuffer，Blob，Stream 等等。那么这些概念彼"/>
<meta name="application-name" content="Raymond">
<meta name="apple-mobile-web-app-title" content="Raymond">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="https://mrzhang123.github.io/posts/2023/javascript-binary/" /><link rel="prev" href="https://mrzhang123.github.io/posts/2023/know-your-target/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "聊一聊 JS 中的二进制",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/mrzhang123.github.io\/posts\/2023\/javascript-binary\/"
        },"genre": "posts","keywords": "Node.js, 二进制","wordcount":  3512 ,
        "url": "https:\/\/mrzhang123.github.io\/posts\/2023\/javascript-binary\/","datePublished": "2023-02-18T00:00:00+00:00","dateModified": "2023-02-18T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": "Raymond"},"author": {
                "@type": "Person",
                "name": "Raymond"
            },"description": ""
    }
    </script><script src="//instant.page/5.1.1" defer type="module" integrity="sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq"></script>
</head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark');}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('auto' === 'light' || 'auto' === 'dark' || 'auto' === 'black') setTheme('auto'), saveTheme('auto'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Raymond"><span id="desktop-header-typeit" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="请输入关键词进行搜索" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" class="menu-item theme-select" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                    <select class="color-theme-select" id="theme-select-desktop" title="切换主题">
                        <option value="light">浅色</option>
                        <option value="dark">深色</option>
                        <option value="black">黑色</option>
                        <option value="auto">跟随系统</option>
                    </select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Raymond"><span id="mobile-header-typeit" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="请输入关键词进行搜索" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="#" class="menu-item theme-select" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
                <select class="color-theme-select" id="theme-select-mobile" title="切换主题">
                    <option value="light">浅色</option>
                    <option value="dark">深色</option>
                    <option value="black">黑色</option>
                    <option value="auto">跟随系统</option>
                </select>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content always-active" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#定型数组typedarray">定型数组（TypedArray）</a>
      <ul>
        <li><a href="#定型数组的历史">定型数组的历史</a></li>
        <li><a href="#数组缓冲区arraybuffer">数组缓冲区（ArrayBuffer）</a></li>
        <li><a href="#dataview">DataView</a></li>
        <li><a href="#定型数组">定型数组</a></li>
        <li><a href="#字节序">字节序</a></li>
      </ul>
    </li>
    <li><a href="#stream">Stream</a></li>
    <li><a href="#blob">Blob</a></li>
    <li><a href="#buffer">Buffer</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">聊一聊 JS 中的二进制</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">Raymond</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/node.js/"><i class="far fa-folder fa-fw"></i>Node.js</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2023-02-18">2023-02-18</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2023-02-18">2023-02-18</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3512 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 8 分钟&nbsp;</div>
        </div><div class="featured-image"><img
        
        loading="eager"
        src="../../../image/logo/nodejs.png"
        srcset="../../../image/logo/nodejs.png, ../../../image/logo/nodejs.png 1.5x, ../../../image/logo/nodejs.png 2x"
        sizes="auto"
        alt="../../../image/logo/nodejs.png"
        title="../../../image/logo/nodejs.png" height="auto" width="auto"></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#定型数组typedarray">定型数组（TypedArray）</a>
      <ul>
        <li><a href="#定型数组的历史">定型数组的历史</a></li>
        <li><a href="#数组缓冲区arraybuffer">数组缓冲区（ArrayBuffer）</a></li>
        <li><a href="#dataview">DataView</a></li>
        <li><a href="#定型数组">定型数组</a></li>
        <li><a href="#字节序">字节序</a></li>
      </ul>
    </li>
    <li><a href="#stream">Stream</a></li>
    <li><a href="#blob">Blob</a></li>
    <li><a href="#buffer">Buffer</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>在 JavaScript 中，有很多跟二进制相关的概念，例如 <code>Buffer</code>，<code>TypedArray</code>，<code>ArrayBuffer</code>，<code>Blob</code>，<code>Stream</code> 等等。那么这些概念彼此之间的关系是什么？各自的使用场景是什么？这将是本文内容的重点。</p>
<h2 id="定型数组typedarray" class="headerLink">
    <a href="#%e5%ae%9a%e5%9e%8b%e6%95%b0%e7%bb%84typedarray" class="header-mark"></a>定型数组（TypedArray）</h2><p>首先介绍下定型数组。定型数组是一种用于处理 <strong>数值</strong> 类型（注意不是所有类型）数据的 <strong>专用数组</strong>，<code>ArrayBuffer</code>（数组缓冲区） 只是其中的一个概念。</p>
<h3 id="定型数组的历史" class="headerLink">
    <a href="#%e5%ae%9a%e5%9e%8b%e6%95%b0%e7%bb%84%e7%9a%84%e5%8e%86%e5%8f%b2" class="header-mark"></a>定型数组的历史</h3><p>定型数组最早是在 <a href="https://zh.wikipedia.org/wiki/WebGL" target="_blank" rel="noopener noreferrer">WebGL</a>  中使用的，WebGL 是 OpenGL ES 2.0 的移植版，在 WebGL 早期的版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。</p>
<p>JavaScript 数组在内存中的格式是双精度浮点格式（IEEE 754 64位），但图形驱动程序 API 通常不需要以 JavaScript 默认的双精度浮点格式传递给它们的数值。所以每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 都需要在目标环境重新分配数组，以其当前格式迭代数组，然后将数值转换成新数组中的适当格式，这需要花费很多时间。</p>
<p>为了解决上面的问题，Mozilla 实现了 <code>CanvasFloatArray</code>。它提供了 JavaScript 接口的、C语言风格的浮点值数组。最终该类型成为了 <code>Float32Array</code>，即定型数组的其中一个类型。</p>
<h3 id="数组缓冲区arraybuffer" class="headerLink">
    <a href="#%e6%95%b0%e7%bb%84%e7%bc%93%e5%86%b2%e5%8c%baarraybuffer" class="header-mark"></a>数组缓冲区（ArrayBuffer）</h3><p><code>ArrayBuffer</code> 是所有定型数组的基础，它是一段 <strong>可以包含特定数量字节的内存地址</strong>，这在其他语言中被称为“Byte Array”。创建 <code>ArrayBuffer</code> 的过程类似于在 C 中调用 <code>malloc()</code> 来分配内存，只不过不需要指明内存块所包含的数据类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 在内存中分配 10 字节
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>需要注意一点：ArrayBuffer 一旦创建就不能改变大小。</p>
</blockquote>
<p>当然，仅创建存储单元没什么用，我们需要将数据写入到存储单元中，所以还需要创建一个视图来实现写入功能。</p>
<p>数组缓冲区是内存中的一段地址，视图是用来操作内存中的接口。视图可以操作数组缓冲区或缓冲区的子集，并按照其中一种数值型数据类型来读取和写入数据。</p>
<h3 id="dataview" class="headerLink">
    <a href="#dataview" class="header-mark"></a>DataView</h3><p>第一种允许读写 <code>ArrayBuffer</code> 的视图是 <code>DataView</code>，它是一种 <strong>通用的</strong> 数组缓冲区视图 。该视图专为文件 I/O 和网络 I/O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能要差一些。</p>
<p>使用示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>DataView 有以下几个属性：</p>
<ul>
<li>buffer：视图绑定的数组缓冲区；</li>
<li>byteOffset：DataView 构造函数的第二个参数，默认是 0，只有传入参数时才有值；</li>
<li>byteLength：DataView 构造函数的第三个参数，默认是缓冲区的长度的 bytelength。</li>
</ul>
<p>DataView 对存储在缓冲内的数据类型没有预设值，它的 API 强制开发者在读、写时指定一个 ElementType，然后 DataView 就会按照指定的类型做相应转换。DataView 支持的 ElementType 有如下 8 种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8</td>
<td>1</td>
<td>8 位有符号整数</td>
</tr>
<tr>
<td>Uint8</td>
<td>1</td>
<td>8 位无符号整数</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
<td>16 位有符号整数</td>
</tr>
<tr>
<td>Uint16</td>
<td>2</td>
<td>16 位无符号整数</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
<td>32 位有符号整数</td>
</tr>
<tr>
<td>Uint32</td>
<td>4</td>
<td>32 位无符号整数</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
<td>32 位 IEEE-754 浮点数</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64 位 IEEE-754 浮点数</td>
</tr>
</tbody>
</table>
<p>以上每种类型都暴露了 <code>get</code> 和 <code>set</code> 方法，例如 <code>getInt8(byteOffset, littleEndian)</code>，<code>setFloat32(byteOffset, value ,littleEndian)</code> 。更详细的介绍查看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener noreferrer">DataView</a> 。</p>
<h3 id="定型数组" class="headerLink">
    <a href="#%e5%ae%9a%e5%9e%8b%e6%95%b0%e7%bb%84" class="header-mark"></a>定型数组</h3><p>定型数组是另一种形式的 <code>ArrayBuffer</code> 视图，它是用于数组缓冲区的 <strong>特定类型</strong> 的视图，可以直接强制使用特定的数据类型而不是通用的 <code>DataView</code> 对象来操作数组的缓冲区，定型数组遵循原生的字节序。</p>
<p>定型数组的类型有如下几种：</p>
<table>
<thead>
<tr>
<th>构造函数名</th>
<th>字节</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8Array</td>
<td>1</td>
<td>8 位有符号整数</td>
</tr>
<tr>
<td>Uint8Array</td>
<td>1</td>
<td>8 位无符号整数</td>
</tr>
<tr>
<td>Uint8ClampedArray</td>
<td>1</td>
<td>8 位无符号整数（强制转换）</td>
</tr>
<tr>
<td>Int16Array</td>
<td>2</td>
<td>16 位有符号整数</td>
</tr>
<tr>
<td>Uint16Array</td>
<td>2</td>
<td>16 位无符号整数</td>
</tr>
<tr>
<td>Int32Array</td>
<td>4</td>
<td>32 位有符号整数</td>
</tr>
<tr>
<td>Uint32Array</td>
<td>4</td>
<td>32 位无符号整数</td>
</tr>
<tr>
<td>Float32Array</td>
<td>4</td>
<td>32 位 IEEE 浮点数</td>
</tr>
<tr>
<td>Float64Array</td>
<td>8</td>
<td>64 位 IEEE 浮点数</td>
</tr>
</tbody>
</table>
<p>上面的 <code>Uint8ClampedArray</code> 和 <code>Uint8Array</code> 大致相同，唯一的区别在于数组缓冲区中的值如果小于 0 或大于 255，<code>Uint8ClampedArray</code> 会将其分别转换成 0 或者 255。例如，-1 会变成0，300 会变成 255。</p>
<p>按照 JavaScript 之父 Brendan Eich 的说法：” <code>Uint8ClampedArray</code> 完全是 HTML5 <code>canvas</code> 元素的历史遗留。除非真的做跟 <code>canvas</code> 相关的开发，否则不要使用它。“</p>
<p>关于定型数组更详细的用法查看文档：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noopener noreferrer">TypedArray</a></p>
<h3 id="字节序" class="headerLink">
    <a href="#%e5%ad%97%e8%8a%82%e5%ba%8f" class="header-mark"></a>字节序</h3><p>使用定型数组可以查看相同字节序列的8、16、32或64位视图。这里就涉及到“字节序”的问题。所谓“字节序”指的是计算机系统维护的一种字节顺序的约定。它分为两种：大端字节序（big endian）和小端字节序（little endian）：</p>
<ul>
<li><strong>大端字节序</strong>：高位字节在前，低位字节在后，这是人类读写数值的方法。</li>
<li><strong>小端字节序</strong>：低位字节在前，高位字节在后。
例如数值 <code>0x2211</code> 使用两个字节储存：高位字节是<code>0x22</code>，低位字节是<code>0x11</code>，所以对应的小端字节序为<code>0x1122</code>。</li>
</ul>
<p>可以使用以下代码确定底层平台的字节序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 如果整数 0x00000001 在内存中的排列为 01 00 00 00
</span></span></span><span class="line"><span class="cl"><span class="c1">// 则底层使用小端字节序。在大端字节序平台中应该是 00 00 00 01
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">littleEndian</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Int8Array</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">]).</span><span class="nx">buffer</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前市面上常见的 CPU 都是小端字节序。而很多网络协议及某些二进制文件格式则要求使用大端字节序。</p>
<p>为了考虑效率，定型数组使用底层硬件的原生字节序。上面提到的 <code>DataView</code> 并不遵守这个约定。对一段内存而言，<code>DataView</code> 是一个中立接口，它会遵循你指定的字节序。<code>DataView</code> 所有 API 方法都以大端字节序为默认值，但可以通过接收一个 <code>true</code> 开启小端字节序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 按小端字节序读取 Uint16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">view</span><span class="p">.</span><span class="nx">getUint16</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="stream" class="headerLink">
    <a href="#stream" class="header-mark"></a>Stream</h2><p>Steam API 是为了解决 Web 应用有序消费小信息块而不是大信息块的问题的。这种能力的应用场景如下：</p>
<ul>
<li>大信息块可能不会一次性都可用：网路请求的响应就是一个典型的例子。网路负载以连续信息包的形式交付，而流式处理可以让应用在数据一到达就能使用，而不必等到所有数据都加载完毕。</li>
<li>大数据块可能需要分小部分处理。例如视频处理、数据压缩等。</li>
</ul>
<p>Stream API 直接解决的问题是处理 <strong>网络请求</strong> 和 <strong>读写磁盘</strong>，它定义了三种流：</p>
<ul>
<li><strong>可读流</strong>：通过某个公共接口读取数据块的流。数据在内部从底层源进入流，然后由消费者（consumer）进行处理；</li>
<li><strong>可写流</strong>：通过某个公共接口写入数据块的流。生产者（producer）将数据写入流，数据在内部传入底层数据槽（sink）；</li>
<li><strong>转换流</strong>：由两种流组成，可写流用于接收数据（可写端），可读流用于输出数据（可读端）。这两个流之间是转换程序（transformer），可以根据需要检查和修改流内容。</li>
</ul>
<p>流的基本单位是块（chunk）。<strong>块可以是任意数据类型，但通常是定型数组</strong>。每个块都是离散的流片段，可以作为一个整体来处理。块的大小不固定，也不一定按固定时间间隔到达。</p>
<h2 id="blob" class="headerLink">
    <a href="#blob" class="header-mark"></a>Blob</h2><p><strong>Blob 和文件读取有关</strong>。某些情况下，我们需要读取部分文件而不是整个文件。为此，File 对象提供了名为 <code>slice()</code> 的方法。<code>slice()</code> 方法返回一个 Blob 实例。File 接口基于 Blob，继承了 blob 的功能并将其扩展以支持用户系统上的文件。</p>
<p>blob 表示二进制大对象（binary larget object），是 JavaScript 对不可修改二进制数据的封装类型。包含字符串的数组、<code>ArrayBuffer</code>、<code>ArrayBufferView</code>，甚至其他 Blob 都可以用来创建 blob。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener noreferrer">ReadableStream</a> 来用于数据操作。</p>
<p>Blob 有两个属性：</p>
<ul>
<li><code>Blob.prototype.size</code>：表示 Blob 对象所包含的<strong>数据的大小（字节）</strong>；</li>
<li><code>Blob.prototype.type</code>：一个字符串，表明该 Blob 对象所包含的 MIME 类型。如果类型未知，则该值为空。</li>
</ul>
<p>Blob 的实例方法如下：</p>
<ul>
<li><code>Blob.prototype.arrayBuffer()</code>：返回一个 promise，resolve 后结果包含 Blob 所有内容的二进制格式的 <code>ArrayBuffer</code>；</li>
<li><code>Blob.prototype.slice()</code>：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据；</li>
<li><code>Blob.prototype.stream()</code>：返回一个能读取 Blob 内容的 ReadableStream；</li>
<li><code>Blob.prototype.text()</code>：返回一个 promise，resolve 后结果包含 Blob 所有内容的 UTF-8 格式的字符串。</li>
</ul>
<h2 id="buffer" class="headerLink">
    <a href="#buffer" class="header-mark"></a>Buffer</h2><p>最后我们再来聊一下 Buffer，和上面的几个不同的是，Buffer 是 Node.js 中特有的，但是实际上 <code>Buffer</code> 类是 JavaScript 中 <code>Uint8Array</code> 的子类，并且对其进行了扩展。</p>
<p>Buffer 的实例也就是 JavaScript Uint8Array 和 TypedArray 的实例，所有 TypedArray 的方法在 Buffer 中都支持。然而 Buffer API 和 TypedArray API 有些许的不同：</p>
<ul>
<li><code>TypedArray.prototype.slice()</code>  复制调用数组的一部分并返回一个新数组，而 <code>Buffer.prototype.slice()</code> 在不复制的情况下在现有缓冲区创建视图。<code>TypedArray.prototype.subarray()</code> 可以实现和 <code>Buffer.prototype.slice()</code> 相同的行为，它在 Buffer 和 TypedArray 中没有区别；</li>
<li><code>buf.toString()</code> 与 <code>TypedArray.prototype.toString()</code> 不兼容；</li>
<li>Buffer 中的很多方法例如 <code>buf.indexOf()</code> 支持附加参数。</li>
</ul>
<p>所以我们可以认为 Buffer 和 TypedArray 是为了处理一类问题而存在的，但是在实际使用过程中还是要注意兼容性问题。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>以上就是 JS 中和二进制相关的一些概念。最后，用一张图总结一下上面提到的这些概念的关系：</p>
<figure><img src="img/JS%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%a6%82%e5%bf%b5%e7%9a%84%e5%85%b3%e7%b3%bb.png"/>
</figure>

<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener noreferrer">Blob - Web APIs | MDN (mozilla.org)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener noreferrer">ArrayBuffer - JavaScript | MDN (mozilla.org)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" target="_blank" rel="noopener noreferrer">Streams API - Web APIs | MDN (mozilla.org)</a></li>
<li><a href="https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html" target="_blank" rel="noopener noreferrer">Buffer | Node.js v18.14.0 Documentation (nodejs.org)</a></li>
<li><a href="https://nodejs.org/dist/latest-v18.x/docs/api/stream.html" target="_blank" rel="noopener noreferrer">Stream | Node.js v18.14.1 Documentation (nodejs.org)</a></li>
<li><a href="https://nodejs.org/dist/latest-v18.x/docs/api/webstreams.html" target="_blank" rel="noopener noreferrer">Web Streams API | Node.js v18.14.1 Documentation (nodejs.org)</a></li>
<li><a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener noreferrer">Previous Releases | Node.js (nodejs.org)</a></li>
</ul>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-02-18</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/node.js/">Node.js</a>,&nbsp;<a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/2023/know-your-target/" class="prev" rel="prev" title="明确目标才能持续专注于最重要的事"><i class="fas fa-angle-left fa-fw"></i>明确目标才能持续专注于最重要的事</a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer">Raymond</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":1000},"comment":{},"data":{"desktop-header-typeit":"Raymond's Blog","mobile-header-typeit":"Raymond's Blog"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":50,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},"duration":null,"speed":null}};</script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>
</body>

</html>