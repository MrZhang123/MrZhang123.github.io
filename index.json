[{"categories":["算法"],"content":"选择排序 首先找到数组中最小的那个元素，其次将它和数组第一个元素交换位置（如果第一个元素就是最小元素，那么它就和自己交换）。再次，在剩下的元素中找到最小元素，将它和数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序。 命题A：对于长度为N的数组，选择排序需要大约$N^2 / 2$次比较和N次交换 ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:1:0","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"特性 运行时间和输入无关 数据移动是最少的 ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:1:1","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"代码实现 无论原数组排序是如何的，该排序方式总是需要平方时间 func SelectSort(arr []int) []int{ arrLength := len(arr) for i := 0; i \u003c arrLength; i++ { min := i for j := i+1; j \u003c arrLength; j++ { if arr[j] \u003c arr[min] { min = j } } // exchange arr[min], arr[i] = arr[i], arr[min] } return arr } function exchange(arr, a, b) { let temp = arr[a] arr[a] = arr[b] arr[b] = temp } function selectSort(arr) { const arrLength = arr.length for (let i = 0; i \u003c arrLength; i++) { let min = i for (let j = i + 1; j \u003c arrLength; j++) { if(arr[j] \u003c arr[min]) { min = j } } exchange(arr, i, min) } return arr; } ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:1:2","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"插入排序 指针 i 用于遍历整个数组，指针 j 用于将右边部分数组依此跟前一个元素进行比较，如果比前一个元素小，就将元素与前一个元素交换，直到遍历完成整个数组。 与选择排序一样，当前索引左边的所有元素都是有序的，但是它的最终位置还不确定。和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。 命题B：对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要 ～$N^2 / 4$ 次比较及 ~ $N^2 / 4$ 次交换，最坏情况下插入排序需要 ～$N^2 / 2$ 次比较及 ~ $N^2 / 2$ 次交换，最好情况下需要 N-1 次比较和 0 次交换。 ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:2:0","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"代码实现 func InsertSort(arr []int) []int { arrLength := len(arr) for i := 1; i \u003c arrLength; i++ { for j:=i; j \u003e 0 \u0026\u0026 arr[j] \u003c arr[j - 1]; j-- { arr[j], arr[j - 1] = arr[j - 1], arr[j] } } return arr } ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:2:1","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"部分有序 如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。以下是几种经典的部分有序数组： 数组中每个元素距离它的最终位置都不远 一个有序的大数组接一个小数组 数组中只有几个元素位置不正确 对于部分有序的数组，插入排序执行是线性的 逆序对：逆序对是数组中乱序的关键对，例如下面的数组 [4,5,1,3,0] // 逆序对 5-1, 5-3, 5-0, 3-0 四个逆序对 事实上，当倒置数量很少时，插入排序可能比我们所知道任何基础排序算法都要快。 命题C：插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 如果逆序对是线性的（部分有序数组），插入排序对这样的数组排序的时间是线性的。总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组。 ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:2:2","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"希尔排序（Shell sort） 前面的排序每次都移动一个位置，导致效率要低一些，所以希尔排序将数组每次移动若干位置，这种操作叫做对数组进行h-排序。希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被成为“h有序数组”。 h-排序包含h个不同的交叉的“有序子列”，通过递减h值的h-排序实现一种排序方法，对h-排序使用“插入排序”，之前每次获取新的项往回走一个，现在往回走h个。 这里选择插入排序而不是选择排序的原因是插入排序对部分有序数组的排序是线性的，而选择排序无论是什么顺序，时间都是平方级别的 希尔排序中，增量的取值 2n-1：1，3，5，7… 3n+1：1，4，13，40… ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:3:0","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["算法"],"content":"代码实现 实现方式，增量取3n+1 func ShellSort(arr []int) []int { N := len(arr) h := 1 for h \u003c N/3 { h = 3*h + 1 } for h \u003e= 1 { for i := h; i \u003c N; i++ { for j := i; j \u003e= h \u0026\u0026 arr[j] \u003c arr[j-h]; j -= h { arr[j], arr[j-h] = arr[j-h], arr[j] } } h = h / 3 } return arr } function exchange(arr, a, b) { let temp = arr[a] arr[a] = arr[b] arr[b] = temp } function shellSort(arr) { const N = arr.length let h = 1 while (h \u003c N / 3) { h = 3*h + 1 } while (h \u003e= 1) { for (let i = h; i \u003c N; i++) { for (let j = i; j \u003e= h \u0026\u0026 arr[j] \u003c arr[j - h]; j -= h) { exchange(arr, j, j - h) } } h = parseInt(h / 3, 10) } return arr } 已知在最坏情况下该算法的比较次数和N^(3/2)成正比 性质E：使用递增序列1，4，13，40，121，364…（即$3*h+1$）的希尔排序所需的比较次数不会超过N的若干倍乘以递增序列的长度。 洗牌算法（Shuffling） 要点：指针 i 遍历整个数组，将数组分为左右两个部分，从右边已经乱序的数组中随机找到元素 a[r] ，将 a[i] 与 a[r] 交换，i++ ","date":"2020-07-14","objectID":"/posts/2020-basicsort/:3:1","series":null,"tags":["算法"],"title":"基础排序","uri":"/posts/2020-basicsort/"},{"categories":["Javascript"],"content":"原文链接：https://v8.dev/blog/pointer-compression 内存和性能之间的斗争始终存在。作为用户，我们希望速度又快占用内存又少。然而通常情况下，提高性能需要消耗更多的内存（反之亦然）。 时间回到2014年，那时Chrome从32位切换到64位。这个变化带给了Chrome更好的安全性、稳定性和性能，但同时也带来了更多内存的消耗，因为之前每个指针占用4个字节而现在占用是8个字节。我们面临在V8中尽可能减少这种多出来4个字节开销的挑战。 在实施改进之前，我们需要知道我们目前的状况，从而正确的评估如何改进。为了测量当前的内存和性能，我们使用一组可以代表目前流行站点的页面。数据显示在桌面端Chrome渲染进程内存占用中V8占用了60%，平均为40%。 指针压缩是改进V8内存占用的多项工作之一。想法很简单：我们可以存储一些“基”地址的32位偏移量而不是存储64位指针。这样一个简单的想法，我们可以从V8中的这种压缩获得多少收益？ V8的堆区包含大量的项目（items），例如浮点值（floating point values），字符串字符（string characters），解析器字节码（interpreter bytecode）和标记值（tagged values）。在检查堆区时，我们发现在现实使用的网站中，这些标记值占了V8堆区的70%！ 下面我们具体看看这些标记值是什么。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:0:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"V8中的标记值 在V8中JavaScript的对象，数组，数字或者字符串都用对象表示，分配在V8堆区。这使得我们可以用一个指向对象的指针表示任何值。 许多JavaScript程序都会对整数进行计算，例如在循环中增加索引。为了避免每次整数递增时重新分配一个新的number对象，V8使用著名的指针标记技术(pointer tagging)在V8的堆指针中存储其他或替代数据。 标记位（tag bits）有双重作用：用于指示位于V8堆中对象的强/弱指针或一个小整数的信号。因此，整数能够直接存储在标记值中，而不必为其分配额外的存储空间。 V8在堆中按字对齐的地址分配对象，这使得它可以使用2（或3，取决于机器字大小）最低有效位进行标记。在32位架构中，V8使用最低有效位去区分Smis和堆对象指针。对于堆指针，它使用第二个最低有效位去区分强引用和弱引用： |----- 32 bits -----| Pointer: |_____address_____w1| Smi: |___int31_value____0| 这里的 w 用来区分强指针和弱指针。 *注意：*一个Smi值只能携带一个31bit有效载荷（payload），包括符号位。对于指针，我们有30bit用来作为堆对象地址有效载荷（payload）。由于字对齐，分配粒度为4个字节，这给了我们4GB的寻址空间。 在64位架构中，V8的值看起来像这样： |----- 32 bits -----|----- 32 bits -----| Pointer: |________________address______________w1| Smi: |____int32_value____|0000000000000000000| 不同于32位架构，在64位架构中V8可以将32位用于Smi值有效载荷（payload）。以下各节将讨论32位Smis对指针压缩的影响。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:1:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"压缩标记值（tagged values）和新的堆布局 使用指针压缩，我们的目标是以某种方式在64位架构中将两种标记值转换为32位。我们通过以下方式将指针调整为32位： 确保所有V8对象分配在4GB范围内 将指针表示为这个范围内的偏移量 这样严格的限制是非常不幸的，但是Chrome中的V8已经将堆限制到2GB或4GB大小（具体限制到多少取决于设备），即使在64位架构上也是如此。其他V8嵌入程序，例如Node.js可能需要更大的堆。如果我们添加最大4GB的限制，就会让这些嵌入V8的程序无法使用指针压缩。 现在的问题是如何更新堆布局才能让32位指针唯一标识V8对象。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:2:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"简单的堆内存布局（Trivial heap layout） 简单的压缩方案是在前4GB的地址空间分配对象。 但是很可惜V8不能这样做，因为Chrome的渲染进程可能需要在同一渲染器进程中创建多个V8的实例，例如对于Web/Service Workers。除此之外，用这个方案会导致所有的V8实例竞争相同的4GB地址空间从而导致所有的V8实例都受到4GB内存的限制。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:2:1","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"堆内存布局，v1 如果我们将V8堆（heap）放在其他地方的连续4GB地址空间，那么一个从base开始的无符号32位偏移量将唯一标识一个指针。 如果我们确保base是4GB对齐（4-GB-aligned），则所有指针的高位32位都相同。 |----- 32 bits -----|----- 32 bits -----| Pointer: |________base_______|______offset_____w1| 通过将Smi的有效载荷（payload）限制为31位并将其放在低32位，我们还可以压缩Smis。基本上，使它和在32位架构中类似。 |----- 32 bits -----|----- 32 bits -----| Smi: |sssssssssssssssssss|____int31_value___0| 这里 s 是Smi有效载荷的符号值。如果再有使用符号扩展表示，我们就可以仅用64位字的一位算数移位来压缩和解压Smis。 现在，我们可以看到指针和Smis的上半字（upper half-word）完全由下半字定义。这样，我们就可以只将后者存储在内存中，从而将存储标记值所需的内存减少一半。 |----- 32 bits -----|----- 32 bits -----| Compressed pointer: |______offset_____w1| Compressed Smi: |____int31_value___0| 假设base是4GB对齐的，则压缩就是截断： uint64_t uncompressed_tagged; uint32_t compressed_tagged = uint32_t(uncompressed_tagged); 但是解压代码要复杂一些。我们需要区分符号扩展（sign-extending）Smi和零扩展（zero-extending）指针，以及是否要添加base。 uint32_t compressed_tagged; uint64_t uncompressed_tagged; if (compressed_tagged \u0026 1) { // pointer case uncompressed_tagged = base + uint64_t(compressed_tagged); } else { // Smi case uncompressed_tagged = int64_t(compressed_tagged); } 尝试改变压缩方案来简化解压代码。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:2:2","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"堆内存布局，v2 如果将base不是放在4GB的开头，而是中间，就可以将压缩值视为从base开始的一个有符号32位偏移量。注意，整个保留不再是4GB对齐（4-GB-aligned），但是base依然是对齐的。 在这个新的布局中，压缩代码和上面堆内存布局v1中的相同。 然而解压代码变得更好了。现在对Smi和指针来说，符号扩展是相同的，唯一的分支在于如果是指针，需要添加base。 int32_t compressed_tagged; // Common code for both pointer and Smi cases int64_t uncompressed_tagged = int64_t(compressed_tagged); if (uncompressed_tagged \u0026 1) { // pointer case uncompressed_tagged += base; } 代码中分支的性能取决于CPU中的分支预测单元。如果我们以无分支的方式执行解压，我们可以得到更好的性能。通过少量魔术，我们可以写出一个无分支版本的代码： int32_t compressed_tagged; // Same code for both pointer and Smi cases int64_t sign_extended_tagged = int64_t(compressed_tagged); int64_t selector_mask = -(sign_extended_tagged \u0026 1); // Mask is 0 in case of Smi or all 1s in case of pointer int64_t uncompressed_tagged = sign_extended_tagged + (base \u0026 selector_mask); 然后，我们决定从无分支实现开始。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:2:3","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"性能演化 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"初始性能 我们使用Octane测试性能，Octane是我们过去使用的性能基准测试。尽管我们在日常工作中不再专注于提高性能峰值（improving peak performance），但我们也不希望降低它，特别是一些像指针这样对性能敏感的东西。Octane依然是完成这个任务的好的基准测试。 图形显示了在使用指针压缩时Octane在x64架构上的得分。在图中，线越高越好。红色的线是未压缩指针的x64构建，绿色的线是指针压缩的版本。 在第一个方案中，我们的回归差约为35%。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:1","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Bump(1), +7% 首先我们通过比较无分支解压和有分支解压，验证了“无分支会更快”的假设。事实证明，我们的假设是错误的，在x64上，有分支版本的速度提高了7%。这是非常大的不同！ 下面看一下x64汇编 r13是base值的专用寄存器。注意，无分支代码在这里代码量更多且需要的寄存器也更多。 在Arm64，我们观察到相同的现象——在强大的CPU上，有分支版本明显更快（尽管这两种情况的代码大小是一样的）。 在低端Arm64设备上我们发现在任一方向上几乎没什么性能差异。 我们的收获是：在现代CPU中分支预测器非常的好，代码的大小（code size）（尤其是执行路径的长度）对性能影响更大。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:2","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Bump(2), +2% TurboFan是V8的优化编译器，围绕“Sea of Nodes”概念构建。简单来说就是每一个操作在graph中用一个Node表示（更详细的解释可以查看这篇博客。这些节点有各种依赖，包括数据流和控制流。 有两个对指针压缩至关重要的操作：加载和存储，因为它们将V8堆内存和管道（pipeline）的其余部分连起来。如果我们每次从堆内存加载压缩值的时候都解压，并且在存储之前对其压缩，那么管道（pipeline）就可以像在全指针模式（full-pointer mode）下工作了。因此我们在节点图中添加了新的显式操作——压缩和解压。 在某些情况下解压是不需要的，例如，如果一个压缩值仅仅是从某个位置被加载然后存储到新的位置。 为了优化不必要的操作，我们在TurboFan中实施了一个新的“消除解压”阶段。它的工作就是消除直接压缩后的解压。由于这些节点可能不会直接相连，因此它会尝试通过graph传播解压，以期遇到压缩问题并消除。这使我们的Octane的值提高了2%。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:3","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Bump(3), +2% 在查看生成代码时，我们注意到解压一个刚刚被加载的值会导致代码的冗长： movl rax, \u003cmem\u003e // load movlsxlq rax, rax // sign extend 一旦我们修复了标志扩展的问题，value就可以直接从内存中加载。 movlsxlq rax, \u003cmem\u003e 我们得到了另外2%的改善。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:4","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Bump(4), +11% TurboFan优化阶段通过在graph上使用模式匹配工作：一旦一个sub-garph与一个特定模式匹配，就会被替换为语义上等效（但是更好）的sub-graph或指令（instruction）。 尝试匹配不成功并不会有明确的失败提示。在graph中显式的压缩/解压操作导致之前成功的模式匹配尝试失败，从而导致优化失败且没有提示。 “中断”优化的其中一个例子是分配预配置（allocation preternuring）。一旦我们更新匹配模式（pattern matching）使其能够匹配到新的压缩 / 解压 node，我们就可以得到另外11%的改进。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:5","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Bump(5), +0.5% 在TurboFan中使用解压去除（Decompression Elimination）我们学到了很多。显式的解压 / 压缩node方法具有以下特性： 优点： 很明显我们通过对sub-graphs的规范模式匹配可以优化不必要的解压。 但是，随着我们进一步的实施，我们发现缺点： 新的内部值的表示可能会导致转换操作变的难以管理。除了现有的表示集（tagged Smi, tagged pointer, tagged any, word8, word16, word32, float32, float64, simd128），我们还有压缩指针，压缩Smi，压缩任何值（压缩值可以是指针或Smi）。 现有的基于graph的模式匹配（pattern-matching）的优化并没有生效，这导致了一些地方的回退（regressions）。尽管我们找到并修复其中的问题，但TurboFan的复杂性仍在不断增加。 寄存器分配器（register allocator）对graph中的node数量越来越不满意，并且经常生成错误的代码。 较大的node graph会减缓TurboFan优化阶段，并增加编译期间的内存消耗。 我们决定回退一步，考虑在TurboFan中实现一种更简单的指针压缩方式。新的方法是删除压缩指针/Smi/任何表示，然后让所有显式的压缩/解压 node 隐藏在存储和加载中，并假设我们始终在加载之前压缩，在存储之前解压。 我们还在TurboFan中添加新的阶段，该阶段将替代“解压消除（Decompression Elimination”。这个新的阶段能够识别我们什么时候不需要压缩或解压并相应地更新“加载和存储”。这种方法显著降低了TurboFan中指针压缩的复杂性，提高了生成代码的质量。 新的操作和初始时候一样有效，并且又提高了0.5%的性能。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:6","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Bump(6), +2.5% 我们已经接近平均性能，但是依然有差距。我们必须有更好的想法。其中一个想法是：如果我们确保任何处理Smi值的代码都不处理高32位，结果会怎么样？ 之前的解压实现： // Old decompression implementation int64_t uncompressed_tagged = int64_t(compressed_tagged); if (uncompressed_tagged \u0026 1) { // pointer case uncompressed_tagged += base; } 如果我们忽略一个Smi的高32位就可以假定它是undefined。这样，我们就可以避免指针和Smi之间的特殊case，并且可以在解压的时候无条件的添加base，即使是对Smis也可以！我们称这个方法为“Smi-corrupting”。 // New decompression implementation int64_t uncompressed_tagged = base + int64_t(compressed_tagged); 由于我们不关注Smi的符号扩展（sign extending），因此这个改变允许我们回到堆内存布局v1。这是一个base指向4GB预留空间的开始位置。 就解压代码而言，这个改变将符号扩展（sign-extension）变为零扩展（zero-extension），这也同样简单。但是这简化了运行时（C++）端的工作。例如，例如地址空间区域保留代码（查看一些细节实现部分）。 这是用于比较的汇编： 因此我们更将8中所有的使用Smi的代码块调整为新的压缩方案，这给我们另外2.5%的性能提升。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:7","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"剩余差距（Remaining gap） 剩余的性能差距可以用对64位构建的两个优化来解释，这些优化由于与指针压缩不兼容而禁用。 32-bit Smi优化(7), -1% 我们回顾一下，Smis在64位架构全指针模式中看起来是这样： |----- 32 bits -----|----- 32 bits -----| Smi: |____int32_value____|0000000000000000000| 32-bit Smi有如下好处： 它可以有更大的整数范围且不需要封装成整数对象 这样的形式可以在读/写时直接访问32位值 由于使用指针压缩后会具有区分指针和Smis的bit，导致在32-bit压缩指针中没有空间，所以导致该优化无法使用。如果我们在64-bit版本中禁用32-bit smis，将会看到Octane值下降1%。 双精度字段拆箱（双精度 field unboxing） (8), -3% 译者注：装箱（boxing）是指编译器自动将基本数据类型值转换成对应的包装类的对象，拆箱（unboxing）则是反过来。 在某些假设下，这种优化尝试直接将浮点值存储在对象的字段中。这样做的目的是减少数字对象分配的数量，这比单独用Smis减少的更多。 想象一下下面这段代码： function Point(x, y) { this.x = x; this.y = y; } const p = new Point(3.1, 5.3); 一般来说，对象p在内存中的样子如下： 关于更多存储中的隐藏类，属性和元素可以阅读此文 在64位架构中，双精度值和指针的大小相同。所以如果我们假设Point字段总是包含number值，则可以将它们直接存储在对象中。 如果某个字段导致假设不成立，例如执行下面这段代码： const q = new Point(2, 'ab'); y属性的number值必须装箱存储（store boxed instead）。另外，如果某处的优化的代码依赖此假设，则该优化必须舍弃。进行这些“字段类型”泛化的原因是为了尽量减少通过同一构造函数创建的对象的Shapes（译者注：在 JavaScript 程序中，多个对象具有相同的key，JS引擎会将这些key单独存储在一个地方，从而优化存储，具体可以查看[译] JavaScript 引擎基础：Shapes 和 Inline Caches）数量，反过来这对于具有稳定的性能是很必要的。 如果应用该优化，双精度字段拆箱给我们如下好处： 通过对象指针提供对浮点数据的直接访问，避免通过number对象进行额外的取消引用操作。 允许我们对紧凑循环（tight loops）生成更小更快的优化代码从而可以做大量的双精度字段访问。（例如在数字运算应用程序中） 启用指针压缩后，双精度值不再适合压缩字段。然而，在未来我们可能为指针压缩适配该优化。 注意，即使没有双精度字段拆箱优化（以与指针压缩兼容的方式），也可以通过将数据存储在Float64 TypedArrays，甚至是使用Wasm重写要求高吞吐量的数字运算代码。 更多的优化（9），1% 最后，对TurboFan中的解压消除优化进行微调又得到另外1%的性能提升。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:3:8","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"一些优化细节 为了简化将指针压缩整合到现有代码中，我们决定在每次加载values的时候解压并且在每次存储的时压缩它们。因此只是改变标志值的存储格式，而执行格式保持不变。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:4:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"Native代码端 为了在解压的时候生成有效的代码，必须保证始终提供base值。幸运的是V8已经有一个专用的寄存器指向一个“根表（roots table）”，该表包含JavaScript和V8内部对象的引用，这些对象必须始终可用（例如：undefined，null，true，false等）。该寄存器被称为“根寄存器”，它用来生成较小的，可以共享的内部代码。 所以，我们将根表放在V8堆保留区，根寄存器可以同时有两种用途： 作为根指针 作为解压的base值 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:4:1","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"C++ 端 V8运行时通过C++类访问在V8堆区的对象，从而提供对堆中存储的数据的便捷访问。请注意，V8对象比C++对象更类似于POD的结构。助手（helper）“view”类仅仅包含一个带有相应标记值的uintptr_t字段。由于view类是字大小的（word-size），因此我们可以将它按值传递，开销为零（这样感谢现代C++编译器）。 这里是一个helper类的伪代码： // Hidden class class Map { ... inline DescriptorArray instance_descriptors() const; ... // The actual tagged pointer value stored in the Map view object. cosnt uintptr_t ptr_; } DescriptorArray Map::instance_descriptors() const { uintptr_t field_address = FieldAddress(ptr_, kInstanceDescriptorsOffset); uintptr_t da = *reinterpret_cast\u003cuintptr_t*\u003e(field_address); return DescriptorArray(da); } 为了尽量减少首次运行指针压缩版本的所需的更改次数，我们将解压必须的base值的计算集成到getter中。 inline uintptr_t GetBaseForPointerCompression(uintptr_t address) { // Round address down to 4 GB const uintptr_t kBaseAlignment = 1 \u003c\u003c 32; return address \u0026 -kBaseAlignment; } DescriptorArray Map::instance_descriptors() const { uintptr_t field_address = FieldAddress(ptr_, kInstanceDescriptorsOffset); uint32_t compressed_da = *reinterpret_cast\u003cuint32_t*\u003e(field_address); uintptr_t base = GetBaseForPointerCompression(ptr_); uintptr_t da = base + compressed_da; return DescriptorArray(da); } 性能测量结果证实，在每次加载的时候计算base值会影响性能。原因在于C++编译器不知道，对于V8堆区的任何地址调用GetBaseForPointerCompression()的结果是相同的，因此编译器无法合并base值的计算。鉴于代码包含多个指令和一个64位常量，这将导致代码显著膨胀。 为了处理这个问题，我们重用V8实例指针作为解压时用的base（记住，V8实例数据在堆区布局中）。该指针通常在运行时函数中可用，所以我们通过要求使用V8实例指针简化getters代码，并恢复来了性能： DescriptorArray Map::instance_descriptors(const Isolate* isolate) const { uintptr_t field_address = FieldAddress(ptr_, kInstanceDescriptorsOffset); uint32_t compressed_da = *reinterpret_cast\u003cuint32_t*\u003e(field_address); // No rounding is needed since the Isolate pointer is already the base. uintptr_t base = reinterpret_cast\u003cuintptr_t\u003e(isolate); uintptr_t da = DecompressTagged(base, compressed_value); return DescriptorArray(da); } ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:4:2","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"结果 让我们来看看指针压缩的最后结果！对于这些结果，我们使用与本文开头介绍的相同的网站测试。提醒一下，他们代表用户在真实世界网站使用情况。 我们发现指针压缩将V8堆区大小减少43%！反过来，它减少桌面端Chrome渲染进程20%的内存占用。 另一个重要的事情是，不是每一个网站都有相同的改进。例如，在没有使用指针压缩的时候Facebook使用V8堆区内存比纽约时报要多，但是使用该优化后，使用堆内存情况变得相反。这个不同可以通过以下事实解释：某些网站具有比其他网站更多的标记值（Tagged values）。 除了这些内存改进，我们还看到了实际性能的改进。在真实网站上，我们使用更少的CPU和垃圾回收时间！ ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:5:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["Javascript"],"content":"结论 这一路上尽管没有鸟语花香，但是值得度过。300+的提交后，指针压缩让V8拥有64位应用的性能，同时拥有32位的内存占用。 我们一直期待着性能的改进，并在流程中完成以下相关任务： 改进生成汇编代码的质量。我们知道在某些情况下我们能够生成更少的代码来提高性能。 解决相关的性能下降，包括一个机制，该机制以指针压缩友好的方式再次对doble字段拆箱。 探索支持8～16G范围内更大堆的想法。 ","date":"2020-04-23","objectID":"/posts/2020_pointer_compression_in_v8/:6:0","series":null,"tags":["Javascript"],"title":"「译」V8中的指针压缩","uri":"/posts/2020_pointer_compression_in_v8/"},{"categories":["金融","财报"],"content":" 分析上市公司，首先第一步就是阅读公司的财务报表，本系列文章旨在总结之前阅读的《一本书读懂财务报表》，加深对书中概念的理解。 从会计的角度看企业一直都在做的只有三件事：经营、投资和融资。要想创办一个企业首先需要我们手里有钱，然后用手里的钱去买设备，租办公地，招人，开始生产，销售等等，而在现代社会，卖掉商品并不意味着能马上拿到钱，很多时候只是拿到一个收款权利。那么如何确定我们当初的投资是赚钱了还是赔钱呢？这时候就需要一个统计，看我们当初投资的钱变成了什么，它们现在价值如何，是保持原有的价值还是贬值了呢？这个统计，就是资产负债表。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:0:0","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"资产负债表的构成 一张完整的资产负债表如下： 备注：具体的资产负债表可能会包含更多的项目 可以看到资产负债表主要分左右两部分，即左边的资产和右边的负债、所有者（股东）权益。 **注：**不同的上市地方（例如在港交所和纳斯达克）所披露的财报中的名词可能不同，但是含义相同，具体在实际中对应即可。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:1:0","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"资产 资产按流动性分为 流动资产（Current Assets）：指企业可以在一年或者超过一年的一个营业周期内变现或运用的资产。 非流动资产（Non-current Assets）：流动资产以外的资产。 它们的差异点在于能否在一个循环之内将自己变为现金。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:2:0","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"流动资产 资产负债表中的项目按照它们各自转换成现金的速度（流动性），从上到下依次是： 货币资金（Cash）：包括库存现金、银行存款和其他货币资金三种。 应收账款（Accounts Receivable）：核算企业因销售商品、提供劳务等经营活动应收取的款项。 其他应收账款（Other Receivables）：企业除存出保证金（如租房时交付的未来将退回的保证金、押金等）、买入反售金融资产、应收票据、应收账款、预付账款、应收利息、应收代位追偿款、应收分保账款、应收分保合同准备金、长期应收款等以外的其他各种应收及暂收款项。 预付账款（Prepaid Accounts）：企业按照合同规定预付的款项。 存货（Inventory）：企业在日常生活中持有以备出收的产成品或商品、处在生产过程中的在产品、在生产过程或提供劳务过程中耗用的材料和物料等。 待摊费用（Prepaid expenses）：已支出但应有本期和以后各期分别负担的各项费用。 其他流动资产：除以上流动资产外的其他流动资产。 资产和费用之间有一个很大的共同之处就是都得花钱。但是区别在于： 资产可以换来一个对将来有用的东西。 费用的钱，花完就完了。 这里重点说一下待摊费用。待摊费用的定义是：已支出但应有本期和以后各期分别负担的各项费用，该费用包括低值易耗品摊销、一次支出数额较大的财产保险费、排污费、技术转让费、广告费、固定资产经常修理费、预付租入固定资产的租金等。 从定义可以看出，该费用的本质其实就是提前交钱（变成资产），然后在后期享受服务（变为费用）。例如公司花6万买入一批可以使用6个月的办公用品。初始买入后，是公司的一笔资产，随着时间的流逝，办公用品被使用，变成一笔费用，这就是待摊费用。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:2:1","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"非流动资产 非流动资产包含以下几个项目： 长期投资（long-term Investments）：指不满足短期投资条件的投资。即在一年或长于一年的经营周期内不准备转换为现金的投资。长期投资按性质分为股票、债券和其他长期投资。 固定资产（Fixed Assets）是指同时具有以下特征的有形资产： 为生产商品、提供劳务出租或经营管理而持有的； 使用寿命超过一个会计年度。 无形资产（Intangible Assets and Other Assets）：指企业拥有或控制的没有实物形态的可辨认非货币性资产。包括专利权、非专利技术、商标权、土地使用权（中国特有）等。 关于非流动资产需要注意几点： 在使用过程中，固定资产会逐渐损耗，它的价值也会随着损耗逐渐降低。描述固定资产的损耗的量就是折旧。**固定资产的折旧（Depreciation）**是指在一定时期内为弥补固定资产损耗按照规定的固定资产折旧率提取的固定资产折旧，或按国民经济核算统一规定的折旧率虚拟计算的固定资产折旧。 在无形资产中，有一项中国特有的，即土地使用权。因为在中国企业或个人没有土地所有权，只有土地使用权，所以该项是无形资产。而在其他国家，企业和个人有土地所有权，这时土地就成为了固定资产。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:2:2","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"资产计价 当我们确认一个资产的价值时，默认会想到使用当前该资产的现有价格作为它的价值，但是这样会有一个问题，如何找到当前资产现在的价格？因为很可能你持有的这个资产现在已经不再在市场上售卖，即使在市场上有售卖，价格也可能不客观（大家的报价无法达成一致），所以无法确定其准确的价值。为了准确描述资产的价值，我们用当时购买该资产的价格作为该资产的价值。这就是历史成本。 历史成本/原始成本/实际成本（Historical Cost）：资产在其取得时为它所支付的现金或现金等价物的金额。负债在正常经营活动中为交换而收到的或为偿付将要支付的现金或现金等价物的金额。 按照以上定义，历史成本包含两层含义： 只有花了的钱采能记在账上。 在历史成本计价体系下，增加资产价值的唯一途径是发生一个新的交易。 那有没有这样一种资产，虽然已经买了很久，但是只要当前提出报价大家都一致认同的资产呢？答案是有的，例如股票这样的金融资产，房地产，因为金融市场非常活跃，所以它的资产价格很容易达到共识。 与历史成本相对的，用当前市场价格来计价的，被称为公允价值。 公允价值/公允市价/公允价格（Fair Value）：熟悉市场情况的买卖双方在公平交易的条件下和自愿的情况下所确定的价格，或无关联的双方在公平交易的条件下一项资产可以被买卖或者一项负债可以被清偿的成交价格。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:2:3","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"负债 负债（Liability）：由于过去的交易或事项所引起的公司、企业的现有债务，这种债务需要企业在将来以转移资产或提供劳务加以清偿，从而引起未来经济利益的流出。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:3:0","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"流动负债 一年内或者超过一年的一个经营周期内需要偿还的债务合计，包含以下内容： 短期借款（Short-term Borrowing）：企业用来维持正常的生产经营所需的资金或为抵偿某项债务而向银行或其他金融机构等外单位借入的，还款期限在一年以下或者一年的一个经营周期内的各种借款。 应付账款（Accounts Payable）：企业因购买材料、物资和接受劳务供应等而应该付给供货单位的账款。 其他应付账款（Other Payables）：企业除应付票据、应付账款、应付工资、应付利润以外的应付、暂收其他单位或个人的款项。 预收账款（Deposit Received）：买卖双方协议商定，由购货方预先支付一部分货款给供应方而发生的一种负债。 其他流动负债：为了简化资产负债表，将一些项目合并在一起，统称为“其他”。包括应付工资，应交税金等。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:3:1","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"非流动负债 偿还期在一年或超过一年的一个营业周期以上的债务，包含以下内容： 长期借款（Long-term Loans Payable）：：企业从银行或其他金融机构借入的期限在一年以上（不含一年）的借款。 应付债券（Bond Payable）：企业为筹集资金而对外发行的期限在一年以上的长期借款性质的书面证明，约定在一定期限内还本付息的一种书面承诺。 长期应付款（Long-term Payable）：企业除了长期借款和应付债券以外的长期负债。包括应付引进设备款、应付融资租入固定资产的租赁费等。 其他非流动负债：除长期借款、应付债券等项目以外的其他非流动负债。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:3:2","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"股东权益 股东权益（Shareholder‘s Equity）：公司总资产中扣除债务所余下的那部分，也称净资产。股东权益反应了公司的自有资本。 股东权益包含以下几个部分： 股本（Capital Stock）：股东在公司中所占的权益，多用于指股票。 资本公积（Addition Paid-in Capital）：企业收到的投资者的超出其在企业注册资本所占份额，以及直接记入所有者权益的利得和损失等。资本公积包括资本溢价（股本溢价）和直接记入所有者权益的利得和损失等。 盈余公积（Surplus Zeserve）：企业按照规定从净利润中提取的各种积累资金。中国的公司法规定，一个公司有了盈利之后，必须留存至少**10%**作为盈余公积。该项目为中国特有，其他国家没有这个规定。 未分配利润（Retained Earnings）：企业未作分配的利润。它在以后年度可继续进行分配，在未进行分配之前，属于所有者权益的组成部分。 在资产负债表中实收资本/股本。区别在于实收资本对应有限责任公司而股本对应股份有限公司。 盈余公积是法律不允许分配的利润，而分配利润是企业不想分配的利润。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:4:0","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["金融","财报"],"content":"总结 总的来说，资产负债表左边是说钱被用来做什么了，右边是说企业的钱是从哪儿来的。很显然进来的钱和用掉的钱在金额上必须相等，这就意味着资产负债表的左边的资产与右边的负债和股东权益之和相等。即资产 = 负债 + 股东权益，这就是所谓的“会计恒等式”。也就是说股东权益 = 资产 - 负债。 资产负债表是一个时间点的概念，它提供了截止日期那天，公司的财务状况。 ","date":"2020-04-12","objectID":"/posts/2020-blance-sheet/:5:0","series":null,"tags":["金融","财报"],"title":"学习读财报之资产负债表","uri":"/posts/2020-blance-sheet/"},{"categories":["Vim"],"content":"在使用编辑器的过程中，我们会经常使用到搜索 / 替换，大部分编辑器可以通过快捷键呼出搜索框来搜索 / 替换，通过选择不同的选项可以做到匹配大小写，精准匹配，模糊匹配等等。那么在vim中，这些操作该如何实现？本文将介绍在vim中常用的搜索文本，替换文本操作以及如何结合插件实现更强大的搜索。 利用vim自带搜索 对于搜索当前打开文件，vim自带搜索功能足以应对，在Normal modal下键入/，即可进入搜索模式，此时输入想要搜索的单词然后回车，即可完成搜索，光标会跳到当前搜索到的第一个匹配的单词。按下n，光标跳到下一个匹配的单词，按下N（shift+n）光标会跳到上一个匹配的单词。 除了在Normal modal下可以键入/开始搜索外，还可以键入以下符号开始搜索： ?：与/相反，键入该符号后反向向上搜索 *：搜索当前光标所在单词，例如：如果当前光标所在单词是set，则相当于键入/\\\u003cset\\\u003e #：搜索当前光标所在单词，相当于键入?\\\u003cset\\\u003e 其中\\\u003c是单词界定符，表示只匹配单词的开头，/\u003e表示只匹配单词的末尾 此外vim搜索还支持正则，例如输入/se$表示搜索以se结尾的单词，输入/^se表示搜索以se开头的单词 ","date":"2020-03-15","objectID":"/posts/2020-vimsearch/:0:0","series":null,"tags":["Vim"],"title":"vim的搜索与替换","uri":"/posts/2020-vimsearch/"},{"categories":["Vim"],"content":"高亮搜索结果 默认情况下，搜索的结果不会高亮，只是光标会跳到搜索到的单词，如果想要高亮搜索结果，可以在Normal modal下输入:set hlsearch，或者在.vimrc文件中设置： \" search result heighligh, when enter `:noh` in command line , clean heightlight set hlsearch 这样设置后，在搜索完成后，所有的匹配文本都会高亮，想要取消搜索结果的高亮可以在Normal modal下输入:nohlsearch或其简写:noh ","date":"2020-03-15","objectID":"/posts/2020-vimsearch/:1:0","series":null,"tags":["Vim"],"title":"vim的搜索与替换","uri":"/posts/2020-vimsearch/"},{"categories":["Vim"],"content":"搜索大小写敏感 在使用vim的搜索默认是大小写不敏感的，如果想要让vim搜索做到大小写敏感，可以在输入想要搜索的单词后面添加\\C，对应的如果使用\\c，则表示搜索大小写不敏感。 或者直接在.vimrc中添加设置： \" 开启大小写不敏感（默认值） set ignorecase \" 开启智能推测 set smartcase 开启智能推测后，如果输入的文本带有大写字母，vim会认为你当前搜索是区分大小写的，否则不区分大小写。即开启后，如果输入:Set，则只能搜索到Set，但是如果输入:set，则可以搜索到set和Set。 vim中的替换 对于替换当前打开文件中的文本，vim提供如下语法： :{作用范围}s/{目标字符}/{替换的字符}/{替换标志} 作用范围：用于指定替换的范围，1,3表示替换第一行至第三行，1,$表示替换第一行到最后一行，也可以直接用%表示。 替换标志（可以组合使用）： c: confirm，每次替换前都会询问 e：不显示error g: globe，不询问，整个替换 i: ignore，即不区分大小写 具体的用法可以查看下图（摘自Reddit）： :%s/remember/me/n命令不会替换任何东西。 只是告诉我们如果我们运行命令，受影响的行数。实际操作过程中，在vim中运行该命令，显示89 matches on 89 lines :%s/remember/me/\u0026命令没看明白做什么用 利用插件在vim中搜索 有时候需要在整个项目中搜索文件或者文本，这类操作借助插件更方便一些。 说起vim中搜索文件，就一定会想到大名鼎鼎的ctrlp.vim，但该插件早已不再维护（最近一次提交是在2015年11月30日），那是否还有其他替代插件呢？答案是有的，可以使用fzf.vim。fzf.vim支持文件搜索，全局文本搜索，buffer搜索，git log搜索等，这里只介绍最常用的全局文本搜索和文件搜索。 首先使用vim-plug安装插件： Plug 'junegunn/fzf', { 'do': { -\u003e fzf#install() } } Plug 'junegunn/fzf.vim' 从以上安装可以看到要想使用fzf.vim，需要首先安装fzf。 fzf是一款golang编写的命令行模糊查找器，支持文件，命令等的模糊搜索。强烈建议使用，对于经常使用终端的同学来说太方便了。 备注： 如果要安装fzf，在macOS直接：brew install fzf即可。如果通过brew安装过fzf，则vim-plug的配置如下： Plug '/usr/local/opt/fzf' Plug 'junegunn/fzf.vim' 安装完成后在.vimrc中添加如下配置： \" fzf \" fzf use rg search config let g:fzf_layout = { 'down': '~70%' } command! -bang -nargs=* Rg \\ call fzf#vim#grep( \\ \"rg --column --line-number --no-heading --color=always --smart-case \" \\ .(len(\u003cq-args\u003e) \u003e 0 ? \u003cq-args\u003e: '\"\"'), \\ 1, \\ \u003cbang\u003e0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%') \\ : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:50%:hidden', '?'), \\ \u003cbang\u003e0) command! -bang -nargs=? -complete=dir Files \\ call fzf#vim#files(\u003cq-args\u003e, fzf#vim#with_preview(), \u003cbang\u003e0) \" fzf vim nnoremap \u003csilent\u003e \u003cLeader\u003erg :Rg\u003cCR\u003e nnoremap \u003cleader\u003eb :Buffers\u003cCR\u003e nnoremap \u003cC-p\u003e :Files\u003cCR\u003e 关于fzf.vim的配置有几点说明： fzf_layout用于设置调用fzf搜索的窗口位置以及大小，可以设置left、right、down、up。 fzf.vim内置fzf#vim#grep函数，支持调用第三方搜索，接收参数：fzf#vim#grep(command, [has_column bool], [spec dict], [fullscreen bool]) command：要运行的命令； has_column：是否打印列号； spec：展示预览窗口； fullscreen：是否全屏，\u003cbang\u003e0是vim script，在vim命令中如果输入!则\u003cbang\u003e0转换成1，否则为0； 这里使用了ripgrep（因为据说vscode内的搜索就是基于这个做的，所以选择这个）作为fzf中默认的搜索。fzf#vim#with_preview用于配置展示预览窗口。配置好后在vim中输入:Rg就可以启动在整个项目搜索文本，:Files在整个项目中搜索文件。 在使用fzf.vim搜索文本和文件的过程中需要注意一点，搜索是基于你当前打开文件所在的文件夹去搜索。所以如果要在整个项目中搜索，就需要在项目根目录下打开一个文件进行搜索。这也类似于在vscode中，如果想搜索项目中特定文件夹中的文本，需要选择当前想要选择的文件夹。 以上配置就可以满足我们日常开发中的搜索/替换文本，搜索文件等常用功能了。 ","date":"2020-03-15","objectID":"/posts/2020-vimsearch/:2:0","series":null,"tags":["Vim"],"title":"vim的搜索与替换","uri":"/posts/2020-vimsearch/"},{"categories":["职场"],"content":" 尽管很多人都很努力地工作，但是他们却没能取得什么成就感。 ----安迪·格鲁夫 第一次听说OKR是一年前刚来新公司要定制试用期目标，那时候也没有太在意OKR是什么，只是觉得就是绩效，跟KPI一样。直到后来转正，每隔一段时间都要定制自己的OKR，同时在吴军老师的书《见识》中也提到关于OKR的使用，如何用OKR管理自己的时间等等。这时候开始觉得有必要了解一下OKR到底是什么，该如何写，如何用OKR帮助自己管理工作 / 生活中的时间。本文是在阅读了《这就是OKR》之后的一些总结以及自己对OKR的理解。 OKR全称Objectives and Key Results即目标与关键成果法，是一套定义和追踪目标及其结果的框架，由英特尔公司的前CEO安迪·格鲁夫发明，旨在明确公司和团队最重要的“目标”（Objectives）以及达成每个目标的可衡量的“关键结果”（Key Results）。OKR可以在整个组织中共享，这样各个团队可以明确自身的目标，集中精力完成。 OKR的四大利器 优先事项的聚焦和承诺 团队工作的协同和联系 持续追踪，改进 充分延展进而挑战不可能 ","date":"2020-02-27","objectID":"/posts/2020_okr/:0:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"优先事项的聚焦和承诺 大部分成功人士超越常人的地方不在于智力，而在于时间管理。**查理·芒格说：这辈子我遇见的所有成功人士，没有一个是不读书的，没有，一个都没有！**沃伦·巴菲特也将自己大量的时间花费在读书上面。提起读书，很多人都会说自己很忙，没时间。但是谁又能比巴菲特需要做的事情多呢？为什么巴菲特有那么多时间去阅读？这就要提到巴菲特对事情优先级冷酷的排序。 按照优先级列出你想做的那些事情，然后取前20%，然后集中精力去完成。为什么是20%呢？这里要提到一个基本事实： 20%的优先级任务会占据我们结果的80%，即二八法则 集中精力，聚焦优先事项，少即是多，这是OKR的核心要点之一。短时间内做太多的事情注定会以痛苦收尾。 衡量一件事情的重要性时，应该先考虑这样的问题：**在接下来的周期里（一般是3个月或6个月或12个月），什么事情最重要？**将重要的事情列到清单，这就是我们的Objectives（目标）。每个周期最多定制3到5个目标，就能帮助公司、团队和个人明确什么是最重要的。 关键性结果是实现目标过程的一个个节点。如果目标设定较为科学的话，通常3到5个关键结果足以确保目标的达成。太多的目标会淡化焦点，对于预期的进展形成阻碍。关键结果应该是明确的、具体的、可衡量的，完成了所有关键结果的也就实现了目标，如果完成了所有关键结果而没实现目标，那就不是OKR了。 双线并行是目标设定的最佳方式，既有短期的OKR来支持年度OKR的实现，也有长期的战略规划。尽管推动实际工作的是短期目标，但是年度计划需要依据实际情况指定，并确保这一计划可以实施。 ","date":"2020-02-27","objectID":"/posts/2020_okr/:1:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"团队工作的协同和联系 OKR充分发挥员工的主动性，鼓励目标自下而上的涌现，同时为了适应企业和员工双方需求的波动，领导者对自上而下和自下而上这两种目标设定的选择往往各占一半。这使得全公司整体目标更加一致，除此之外还有更深层的含义，即始终保持员工的目标与公司的核心价值一致。也就是说，员工目标必须对公司的核心价值作出实质性的贡献。 ","date":"2020-02-27","objectID":"/posts/2020_okr/:2:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"持续追踪，改进 在定制OKR的过程中，为了促进沟通，管理者可以向员工提出以下问题： 你打算把精力集中在哪些OKR上，以便为你的角色、团队或公司发挥最大的价值？ 这些OKR中，哪些指标与组织中的关键计划保持一致？ 你的OKR进展如何？ 你需要什么样的关键能力来获得成功？ 是不是有一些因素阻碍你实现目标？ 考虑到优先级的变化，需要调整、增加或删除哪些OKR？ OKR在定制之后并不是一成不变的，要定期检查（一般是每周检查一次），不断调整，为了达到最好的效果，员工和管理者每个周期都要对OKR进行几次详细的检查，包括报告进展情况、识别障碍、改进关键结果等。当一个关键结果或者目标变得过时或不切实际时，应该从OKR列表中删除它，然后继续前进。记住：目标是为目的服务的，而不是为其他事项服务的。 每个周期结束之后，要对OKR进行评分，评分计量标准如下： 0.7 ～ 1.0分 = 绿色（目标完成） 0.4 ～ 0.6分 = 黄色（目标取得了进展，但是没有完成） 0 ～ 0.3分 = 红色（目标失败） 评分之后要对OKR进行反思。OKR是以行动为导向的，但是如果只是一直努力完成而没有停下来反思，这就跟在“仓鼠轮”中的仓鼠一样。要想用OKR达到满意的效果，关键在于定制出目标，努力实现大部分，在适当的时候停下来对取得结果进行反思，并不断改进，一直重复这个过程。 当一个OKR结束之后，我们应该反思： 我是否完成了所有目标？ 如果是，是什么促使我成功？ 如果没有，我遇到了什么阻碍？ 如果我要重新写一个完整的目标，我要作出什么改变？ 我学到了哪些经验，可以帮助我更有效的定制下一个周期的OKR？ ","date":"2020-02-27","objectID":"/posts/2020_okr/:3:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"充分延展进而挑战不可能 目标设定越具有挑战性，所产生的结果越好。虽然高难度的目标预期产出与结果之间的差距会大于低难度目标与其产出结果之间的差距，但是前者达到的最终结果往往要比后者好。就像拉里佩奇说的：“当你设定的是一个疯狂而富有挑战性的目标时，即使没有实现它，你也会取得一些不小的成就。假如你的目标是去一颗恒星，也许你永远无法达到，但是在这个过程中，你可能已经飞到了月球。” 我们可以在设定OKR时，可以设定两类： 承诺型OKR 愿景型OKR 承诺型OKR也就是一定可以完成的目标，是能够通过调整工作时间和资源配置确保其得以实现的目标，这类OKR得分应该是1.0。如果小于1.0，就需要想想为什么没有完成，因为这表明团队在定制计划或执行的过程中存在某种失误。 愿景型OKR表达我们对变化的预期，我们可能并不清楚如何实现以及实现这一OKR所必须的资源，愿景型OKR的平均得分是0.7分。 ","date":"2020-02-27","objectID":"/posts/2020_okr/:4:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"设计有效OKR的基本准则 在OKR的定制过程中应该注意以下几个基本准则： 首先目标是“什么” 明确目标和意图。 有进取心但要认清现实。 目标必须是有形的、客观的、明确的。 目标的成功实现，必须为公司带来明确的价值。 其次，关键的结果意味着“怎么做” 设置可衡量的里程碑事件，如果得以实现，将以一种高效的方式推进目标。 一定要描述结果，而不是行为（活动）。如果OKR中包含有诸如“咨询”、“帮助”、“分析”或“参与”等词汇，这类描述是指行为（活动）。 必须包含完整的证据。这些证据必须是可用的、可信的和易观察的。例如，证据应当包括：变更列表、文档链接、注释和发布的测试报告等。 ","date":"2020-02-27","objectID":"/posts/2020_okr/:5:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"OKR（目标管理方法）与KPI（关键绩效指标）的区别 OKR是目标管理方法，而不仅仅是绩效管理方法。和OKR相比，KPI更注重绩效结果考核，更关心绩效与考核的结果与薪酬的结合。而OKR有很大的不同，OKR有助于确保公司上下一齐聚焦解决重要的难题。 ","date":"2020-02-27","objectID":"/posts/2020_okr/:6:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"我的OKR表格 ","date":"2020-02-27","objectID":"/posts/2020_okr/:7:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"OKR制定流程例子 ","date":"2020-02-27","objectID":"/posts/2020_okr/:8:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["职场"],"content":"OKR例子 ","date":"2020-02-27","objectID":"/posts/2020_okr/:9:0","series":null,"tags":["职场"],"title":"解析OKR","uri":"/posts/2020_okr/"},{"categories":["读书笔记"],"content":" 尽管很多人都很努力地工作，但是他们却没能取得什么成就感。 ----安迪 格鲁夫 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:0","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第一部分 有效的关键结果应该是具体的，有时限的且具有挑战性的，但又必须是能够实现的。最重要的是，它们必须是可衡量、可验证的。 OKR体现的是公司最主要的目标，能引导员工共同努力和协作，将不同的业务联系在一起，为整个组织提供明确的目标和凝聚力 目标就像是“一种需要谨慎使用和严密监管的处方药。”作者甚至还提出这样的警告：“由于聚焦过度，出现不道德行为、冒险行为增多，以及合作意愿和工作积极性下降等原因，目标会在组织内引发系统性问题”。 埃德温 洛克指出：首先，“困难目标”往往比简单目标更能有效提升绩效；其次，具体的、困难的目标往往比含糊其次的目标“带来更高的产出”。 实验证明，明确的、具有挑战性的目标确实能够提升生产效率。 管理和领导力咨询公司德勤的一项调查结果显示：“留住员工和提升员工敬业度是公司领导者第二关心的问题，其重要性仅次于如何迎接构建全球领导力的挑战” 如果目标的优先级有冲突、不明确、毫无意义或被随意改变，那么员工就会变得沮丧、愤世嫉俗，并失去动力 在过去连续75个季度中，谷歌公司都是这么做的。11月和12月，各个团队和产品部门都会分别制定未来一年的计划，并将其凝练为OKR。次年1月，正如首席执行官桑达尔 皮查伊 告诉我的那样：“我们将回过头来反思，并在公司层面明确这就是我们的最高战略，下面则是我们为今年制定的OKR。”按照公司传统，高管团队还会对公司OKR进行评分，进而明确找到那些没有达标的地方 OKR的几大利器： 对优先事项的聚焦和承诺 团队工作的协同和联系 责任追踪 充分延展进而挑战不可能 持续改进 文化的重要性 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:1","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第二部分 当这些企业把注意力集中到少数几件优先事项上时，取得的结果也相当令人震撼 OKR总在提醒团队需要做些什么，明白无误地告诉我们做到了什么，没做什么 格鲁夫明确地知道自己想要什么，以及如何实现。从这个意义上说，他有点儿像行走的OKR 解决管理问题的最好方法就是“以创造性思维去面对问题”——坦诚、直接、不带歉意地面对他人 健康的OKR文化的本质是绝对诚实、摒弃个人利益和忠于团队，健康的OKR包括以下几点（OKR的几个标准） **少即是多。每个周期最多只需制定3到5个OKR，就能够帮助公司、团队和个人明确什么是最重要的。一般而言，每个目标都应该与5个或更少的关键结果对应 **自下而上设定目标。**为了促进员工参与，应该鼓励团队和个人与管理人员进行协商。通过这种方式制定的OKR，应该占到各自OKR的一半左右。如果所有目标都是自上而下制定的，那么员工的工作动机就会受挫 **共同参与。**OKR旨在通过协作确定优先事项，并规定如何衡量进展情况。即使在公司目标已经确定的情况下，关键结果仍然是可以商讨和调整的。集体达成一致，对最大限度实现目标来讲至关重要 **保持灵活性。**如果大环境发生了变化，既定目标看起来不切实际或难以实现，则可以在执行期间修改甚至放弃某些关键性结果 **敢于失败。**格鲁夫写到：“如果每个人都把目标定得比自己轻而易举就能完成的目标高一些，那么结果往往会更好。如果你想要自己和下属都有最佳表现，那么这样的目标制定方式是非常重要的。”某些操作性目标必须要全部实现，但激励性OKR会让人倍感压力，甚至让人觉得可能无法实现。格鲁夫将这种目标称为：“挑战性目标”，它能将组织推向新的高度 **OKR是工具，而非武器。**OKR系统“就好比给你一块秒表，让你随时诊断自己的表现。它不是一份基于绩效评估的法律文本”。为了鼓励员工承担风险，防止消极参与，最好将OKR和奖金分离开来 **耐心、坚定。**每个过程都需要反复试验。格鲁夫告诉iOPDE的学员，英特尔公司在采用OKR之后“翻了很多错误”：“我们并没有完全理解OKR的主要目的，但是随着时间的推移，我们将它运用的越来越好。” ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:2","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第三部分 对于低层级员工来说，他们的OKR就是他们的全部工作产出，但经理们会有额外的日常管理责任 英特尔公司删除制定战略，并将其转化为可实现、可写作的项目 能够激励员工，并让他们充满热情，但他们却不知道该怎么做，这是很糟糕的 员工可以表达自己的观点而不担心会遭受惩罚，这种想法和文化至关重要 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:3","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第四部分 衡量一件事情的重要性时，应该先考虑这样的问题：在接下来的3个月（6个月或12个月）里，什么事最重要的事？成功的组织聚焦于少数能产生实质性差异的举措，并推迟那些不怎么紧迫的事项 虽然消减目标清单总是富有挑战性，但却是值得的。正如经验丰富的领导者会告诉你：没有一个人或公司可以“做所有的事情” 领导者必须说清楚为什么做某件事，以及怎样做。员工不仅仅需要通过里程碑式的成功来获取动力，他们还渴望理解辛勤工作的意义，同时了解自己的目标与公司使命之间的关联。这一过程不能只是在全体员工季度会议上宣布OKR之后就结束。正如领英公司首席执行官杰夫 韦纳喜欢说饿的：“当你不厌其烦地多次强调的时候，团队成员可能菜真正开始听你话” 关键性结果是拉动目标实现的杠杆和实现目标过程的一个个节点。如果目标设定较为科学的话，通常有3到5个关键结果足以确保目标的达成。如果目标太多，常常会淡化焦点，对于预期的进展形成阻碍。此外，每个关键结果对于个人来说应该是一项挑战。如果你有足够的信心做好这件事，那么你所设立的目标就不够宏大 双线并行可能是目标设定的最佳方式，既有短期的OKR来支持年度OKR的实现，也有长期的战略规划。请牢记，尽管能够推动实际工作的是短期目标，但是年度计划需要依据实际情况来制定，并确保这一计划是可以实施的 请记住，在OKR周期的任何时间点，都可以修改甚至完全抛弃之前的设定 目标设定也有一些基本规则：关键结果应该是明确的、具体的、可衡量的，产出和投入的组合（匹配）对其有所帮助。最后，完成所有关键结果的关键和前提是实现目标。如果目标没有实现，那就不是OKR了 大多数情况下，季度OKR的理想数往往介于3到5个之间。太多的目标可能会模糊我们对重要事物的关注，或者使我们分心去追逐下一个更为闪亮的东西 OKR系统应该为企业提供最卓越的东西，即“聚焦”。只有当我们将目标的数量保持在很小时，才会真正聚焦于此。每次作出承诺时，都会丧失投身其他事项的机会。当然，这是任何有限资源分配中都不可避免的结果。因此，做计划的人必须要有勇气、诚实且遵守纪律。只有这样，才能放弃某个项目的同时启动新的项目。摇头说“不”和微笑着说“行”一样重要。我们必须意识到关注所有事项和意见都不关注的结果是一样的，并且能够践行这个原则 OKR既不是一个什么都要完成的愿望清单，也不是团队日常任务的总和。它们是一系列精心策划的目标，值得特别关注，并将推动人们在此时此地努力前行。同时，它与我们期望实现的更大目标相关联 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:4","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第五部分 对于选择正确的目标来说，聚焦是至关重要的，这对区分OKR的优劣也是至关重要的 在我看来，你一次只能做好一件大事，所以你最好知道那件大事到底是什么 总体来说，OKR还是很简单的，但是人们一般不会立刻就掌握这种方法。早些时候，我们公司的目标总是无法完成，原因就在于目标定的太过宏大。以我们的能力最多只能达成两个目标，可我们设定了七八个 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:5","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第六部分 除了聚焦之外，承诺也是OKR第一利器中的核心元素。在实施OKR时，管理者必须公开对其目标作出的承诺，并一以贯之。 我从为跑马拉松而设定的OKR中认识到，短时间内做太多的事情，注定会以痛苦收尾 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:6","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第七部分 研究表明，与保持隐秘相比，组织中公开的目标往往更容易实现，而只需简单的按下“开放”按钮，就可以全面提升目标达成的可能性 在现实中，过度的目标协同也可能会在组织中产生强迫性，进而给组织成员带来精神上的伤害，为了避免这种现象的出现，健康的组织往往会鼓励某些目标自下而上的涌现 理想的OKR系统往往允许员工自主设置部分目标及大部分或者全部的关键结果。OKR能引导组织成员向更高、更远的范围拓展，设定更宏伟的目标并为之付出，以遍实现更多：“目标越高，绩效越高”。知道要去哪里的人，往往会更加清晰如何到达目的地 为了适应企业和员工双方的需求波动，领导者对自上而下和自下而上这两种目标设定的选择往往各占一半。在我看来，这是正确的选择 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:7","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第八部分 除了使公司内部目标更加一致之外，协同还包含着更深层的含义，那就是始终保持你的目标相对于“北极星”（公司最重要的核心价值）的真实性和正确性。也就是说，你的目标必须对公司的核心价值作出实质性的贡献 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:8","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第九部分 领导者不能只关注团队成员的日常工作，更应该把精力集中在更有价值、更长远的计划上 在我所在的部门，每一个员工每季度都有3到5个团队层面的业务目标，同时还有一两个个人业务目标 当对一个新项目进行讨论时，他们会相互询问该如何使用OKR模版来评价这个项目，如果项目没有得到积极的评价，他们马上会对这个项目亮起“红旗”，并会问一个问题：“我们为什么要做这个项目？” 研究表明，当一线员工能看到他们的工作如何和公司的目标保持一致时，他们就能发挥能动性 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:9","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十部分 OKR系统有一个优点常常被低估，这就是它的可追踪性，这一特性使得我们可以根据实际情况对OKR系统不断进行修改 研究表明，取得可量化的进步相比公众的认可、金钱刺激或实现目标本身，对人更有驱动力 OKR系统不需要进行每日跟踪，但是需要定期检查——最好是每周一次，这是防止绩效下滑的必要措施 当你跟踪你的OKR以获得持续的反馈时，你在目标管理方面就不会出现时好时坏的结果，也不回经常出现一些令人惊奇的事 当一个关键结果或目标变得过时或不切实际时，就要当机立断地结束它。没必要顽固的坚持一个过时的预测——从你的列表中删除它，然后继续前进。目标是为目的服务的，而不是为其他事项服务的 为了达到最好的效果，下属和管理者每个季度都要对OKR进行几次详细的检查，包括报告进展情况、识别障碍、改进关键结果等 OKR不会因工作完成而过期。在任何数据驱动的系统中，事后的评估和分析都可以挖掘出巨大的价值。不管是一对一的沟通还是团队会议，这些总结都包括三个部分：客观评估，主观自我评估和反思 OKR评分计量标准： 0.7~1.0分 = 绿色（目标完成） 0.4～0.6分 = 黄色（目标取得了进展，但是没有完成） 0～0.3分 = 红色（目标失败） OKR之反思 OKR是以行动为导向的，但是，如果只是不懈努力而没有停下来反思，这跟永远不停止的“仓鼠轮”没什么区别。在我看来，若想达到令人满意的结果，关键是制定出野心勃勃的目标，并努力实现大部分目标，在适当的时候要停下来对取得的成就进行反思，并不断地重复这个过程 要有意识的去总结、提炼、和阐明关键的经验教训 以下是OKR结束时的反思： 我是否完成了所有的目标？如果是，是什么促使我成功？ 如果没有，我遇到了什么障碍？ 如果我要重新写一个完整的目标，我需要作出什么改变？ 我学到了哪些经验，可以帮助我更有效制定下一个周期的OKR？ ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:10","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十一部分 人们将目标与使命相混淆。使命是具有方向性的，而目标则包含一系列具体步骤，需要个体真正的参与其中并为之不懈奋斗。有一个宏伟目标是必要的，但你必须要知道如何控制它们的规模，以及如何对它们进行衡量 设定宏大的目标相对容易，但是达到目标却不容易。我们需要时时刻刻追问：需要克服哪些困难才能实现目标？ ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:11","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十二部分 目标设定越具有挑战性，所产生的结果越佳。虽然高难度的目标预期产出结果之间的差距，通常会大雨低难度目标与其产出结果之间的差距，但是前者达到的最终结果仍比后者要好 我对创业者的定义是，哪些不仅仅思考各种可能性，而且将各种可能性付诸实践的人 谷歌将OKR分为两类，一类称为承诺型目标，另一类称为愿景型（或挑战性）目标，二者有着本质的区别 领导必须要思考：未来一年我们要成为什么类型的公司？是迅速而果断地开拓一个新的市场，还是采取保守稳健的战略去巩固我们现有的市场地位？我们是采取生存第一的保守投资模式，还是进行风险投资以获得高额回报？我们当前业务到底需要什么？ 拉里佩奇指出：“大多数人倾向于认为某件事是不可能的，而不是回归现实世界的本源去寻找可能实现它们的机会”。 正如佩奇所说，10%的改进意味着你和其他人一样，你们在做着同样的事情。你可能不会失败，但是你也绝不会太成功 领导者必须给员工传达两件事：结果的重要性和结果能够被实现的坚定信念 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:12","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十三部分 就像拉里佩奇说的：“当你设定的是一个疯狂而富有挑战性的目标时，即使没有实现它，你也仍然会取得一些不小的成就。”假如你的目标是去一颗恒星，也许你永远无法到达，但是在这个过程中，你却可能飞到了月球 作为团队的领导者，你的作用之一就是激励团队让他们觉得目标可以实现 但我同样认为，尽可能把我们的能力推向极限甚至超越极限是非常重要的 我尝试着用深入且系统性的思考方式，来取代情绪化的思考方式，我认为前者更有助于问题的解决 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:13","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十四部分 有两个原因影响了工程师们设定目标的准确性，一方面他们讨厌放弃自己认为好的想法，另一方面他们习惯性地低估了完成任务所需要花费的时间 我们需要依靠明确的规则迫使人们将其团队的目标清单缩减到3至4个 巨石理论： 假设你有几块石头，一对鹅卵石和一些沙子，你的任务是尽可能地把所有东西都装进一个一加仑的广口瓶中。如果你先放沙子，再放入鹅卵石，那么在最后放石头的时候你会发现瓶子已经没有空间留给他们了。然而当你先放石头，再放鹅卵石，最后放沙子，你会发现一切如你所愿——沙子将石头之间的缝隙填满了。这就是我们要善于抓住主要矛盾，重要的事情先做，否则可能永远都没机会去做了 如果人们不相信挑战性目标是可以实现的，那么它真的无法实现，这就是设定目标的艺术所在 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:14","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十五部分 在德鲁克看来，管理者的“首要角色”是“自己本身”，管理者需要和他人建立有效的人际关系，激发共同的信心，构建命运共同体 年度绩效管理是回顾性的评估，通常在年底举行。而持续性绩效管理是领导同员工之间持续跟进的前瞻性对话，通常以五个问题为中心： 你正在做什么？ 你做的怎么样？你的OKR进展如何？ 你的工作有什么阻碍吗？ 你需要我提供什么来帮助你实现目标？ 你需要什么帮助来实现你的职业目标？ 根据安迪格鲁夫的测算，管理者与下属的谈话“将提升下属的工作质量，90分钟的谈话可以影响下属两周的工作效率” 管理者与员工之间的对话通常出现在五个关键领域： 目标设定与反思：员工的OKR计划是为即将到来的周期设定的，讨论的重点应当是如何将个人目标和关键结果与组织的当务之急进行最有效的结合 持续进度更新：依托数据对员工工作的实时进度进行快捷监督，并随时待命准备解决问题 双向辅导：帮助员工发挥他们的潜能，并帮助管理者更上一层楼 职业发展：帮助员工提升技能，发现成长的机会，并让其看到未来在公司的升职空间 轻量级的绩效评估：这是一种以组织需求为基准，将上次会议以来的组织投入与员工产出进行总结比较的反馈 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:15","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十六部分 绩效管理不是进行事后管理，而是参与整个过程并进行实时把控 想要云作好一个持续性绩效管理系统，需要做到如下三点： 管理层支持 明确公司的目标，以及它们如何与个人目标匹配——正如我们在“目标与期望”中所说的那样，其实就相当于OKR 正对高层管理者和领导者的效率进行适当培训和投资 成功并不是通过表格、排名和评级来体现的，也不是由那些使人们陷入困境或阻碍他们前行的政策和程序驱动的。真正的成功机制是构筑能力，并激发员工真心为公司服务的东西 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:16","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十七部分 OKR管理方法最巧妙的一点就是它能“反思”程序化。每个季度，至少保证有一次为员工提供一个安静的地方，让他们思考该如何决策才能与公司的利益保持一致，于是员工学会了站在宏观的角度思考问题，学会如何更加直接而具体地执行目标 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:17","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十八部分 团队的绩效表现与以下五个问题息息相关： 结构和清晰度：我们团队的目标、角色和执行计划是清晰而明确的吗？ 心理安全：我们能够感到安全而且从容地在这个团队中承担风险吗？ 工作的意义：我们是否在做一些对我们每个人都很重要的事情？ 可靠性：我们能彼此信赖并按时完成高质量的工作吗？ 工作的影响：我们是否发自内心的认为我们做的工作是真正有意义的？ 最佳绩效往往是团队高度合作和对产品高度负责的结果 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:18","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第十九部分 人们关注你做了什么，而不是你说了什么 讨论如何让这些目标回到正轨上来。在跨部门协作精神的鼓舞下，每个高级主管都需要主动帮助同事完成目标。正如阿特所说：“我们在一起时为了相互帮助，我们应当同心协力。”据我所知，“推销”未完成的目标时OKR的运用中独一无二的环节，并且非常值得推广 OKR能让你从整体业务的角度来关注自己的工作，而不是仅仅将眼光放在自己的工作上 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:19","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第二十部分 在用OKR的这几年里，我也经常说：“这就像是攀登珠穆朗玛峰，我们先想象一下登顶后的成就感，然后再想象一下登顶后的成就感，然后再想象一下攀登的难度，最后再思考我们该如何到达峰顶” OKR让我们保持让我们保持了激情，但又给了我们一个思考和执行的框架，这个框架时非常必要的，没有它，思考就过于抽象 OKR让每一个人思考：你对什么充满激情？这些激情江湖让你做些什么？ 如果所有目标都是绿色的，那么你们就失败了。这对很多人来说是违反直觉的，因为，“绿色”表明我们完成了所有的目标。但约翰坚持认为：“你们需要更深的红色” ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:20","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"第二十一部分 有想法很容易，但关键是执行，没有执行，一切都是空中楼阁 你永远不会发现“教练”（比尔 坎贝尔）会分心查看他的手机。他特别投入，在那个环境中总能“闪闪发光” 我们可以使用OKR让人们专注于最重要的目标，避免其被紧急的次要目标分心，OKR很宏大，它不是渐进式的——我们并不是非要全部实现不可。（这样的话，我们就没有表现出足够的进取性。）我们利用猜测进度来衡量我们的业绩： 0～0.3分是红色 0.4～0.6分是黄色 0.7～1.0分是绿色 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:21","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"设计有效OKR 设计OKR过程中应该注意以下几个基本规则： 首先目标是“什么” 明确目标和意图 有进取心，但要认清现实 目标必须是有形的、客观的、明确的。对一位理性观察者而言，目标是否已实现应当是显而易见的 目标的成功实现，必须为公司带来明确的价值 其次，关键的结果意味着“怎么做” 设置可衡量的里程碑事件，如果得以实现，将以一种高效的方式推进目标 一定要描述结果，而不是行为（活动）。如果OKR中包含有诸如“咨询”、“帮助”、“分析”或“参与”等词汇，这类描述是指行为（活动）。 必须包含完整的证据。这些证据必须是可用的、可信的和易观察的。例如，证据应当包括：变更列表、文档链接、注释和发布的测量报告等 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:22","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"OKR分类 OKR主要分承诺型OKR和愿景型OKR 承诺型OKR是指我们一定会实现的OKR，是我们甘愿通过调整工作时间和资源配置以确保其得以实现的目标，承诺型OKR的得分应该是1.0分。若得分小于1.0分，则需要解释未完成部分的原因，因为它表明团队在制定计划或执行计划时存在着某种失误 愿景型OKR表达了我们对世界变化的预期。不过，我们可能并不清楚如何到达那里，以及实现这一OKR所必须的资源，愿景型OKR指标的平均分是0.7分，且方差较大 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:23","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"OKR流程 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:24","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"OKR沟通反馈 持续改进的绩效管理是互相交织的两个过程：第一过程是设定OKR，第二过程是定期和持续沟通，并根据需求不断进行调整 为了促进沟通，管理者可能会向相关员工提出以下问题： 你打算把精力集中在哪些OKR上，以便为你的角色、团队或公司发挥最大的价值？ 这些OKR中，哪些指标与组织中的关键计划保持一致？ 你的OKR进展如何？ 你需要什么样的关键能力来获得成功？ 是不是有一些因素阻碍你实现目标？ 考虑到优先级的变化，需要调整、增加或删除哪些OKR？ 员工也可以自己提问自己： 我的目标实现了吗？ 我是否发现了机会所在？ 我是否理解自己的工作与重大里程碑之间的联系？ 我能给我的管理者反馈什么？ ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:25","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"总结 为自己的OKR循环设定合适的节奏。我推荐双重追踪，即季度OKR（用于短期目标）和年度OKR（用于长期策略）并进行部署 在每个循环周期，需要承诺3～5个最高目标，太多的目标会分散注意力 每个目标的关键结果都不要超过5个，而且这些关键结果是可以衡量的、明确的以及有时间限制的。关键结果也即目标如何实现？根据定义，完成了所有关键结果等于实现了目标 要想在生产力或创新上取得飞跃，请遵循谷歌公司的“10倍”原则，并且用指数级来替换增量式的OKR。这就是企业被颠覆、品类被推新的原因 在管理者和员工之间的绩效沟通中，允许员工设置工作计划，而管理者的角色则是学习和指导 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:26","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"后记 **OKR（目标管理方法）与KPI（关键绩效指标）**OKR是目标管理方法，而不仅仅是绩效管理方法。和目标管理方法相比，KPI更注重绩效结果考核，更关心绩效考核的结果与薪酬的结合。而OKR则有很大的不同，OKR有助于确保公司上下一起聚焦解决重要的难题 我们通常以为人区别于其他物种的首要特征是智商，但真正的首要特征是社会智商。人类之所以能够取得伟大的成就，理解和合作能力是首要因素 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:27","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["读书笔记"],"content":"附OKR例子 ","date":"2020-02-23","objectID":"/posts/2020_this_is_okr/:0:28","series":null,"tags":["读书笔记"],"title":"《这就是OKR》读书笔记","uri":"/posts/2020_this_is_okr/"},{"categories":["年终总结"],"content":" 不知不觉又到年底了，临近年底大家都忙着总结2019年发生的大事儿，比如前端2019年发生了哪些大事儿，投资界2019年发生了哪些事情让大家惊讶，DJ们也忙着制作并推出 Year Mix 2019。我从2016年开始，在每年的年底都会写一篇年底总结文章，回头看看这一年对我来说重要的事情，这一年我又学到了哪些，有哪些成长，今年也不例外… 2019年总的来说，相对于提升前端技术，更多的是在其他技能以及思想意识方面的提升。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:0:0","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"工作 这一年，在工作方面的最重要事情就是 顺利转正，并且越来越适应新的环境，新的方式。🎉🎉🎉 2018年底的时候来到现在的公司，经过半年的试用期，终于在今年上半年转正了，转正过程也是一波三折，中间也经历了不太好的过程，但是好在最终的结果还是好的，最终还是转正了。虽然自己在来现在这家公司的时候就已经工作三年了，但是换了一个新的环境后，还是感觉不太适应，所以在刚来的时候表现的不是特别好，这也导致了后面转正的一些问题。 记得去年年底刚来的时候，真的是让我惊呆了，上午还在参加入职培训，下午就拉着我去参加需求会，于是我一脸懵逼的去听需求会，然后就自己熟悉项目。期间也参加过一些小的需求，但是也许是因为还在适应，所以导致了一些问题，也是比较尴尬。还有件比较尴尬的事情是自己虽然新入职，但是似乎并没有人去指导，带着熟悉一些规则，流程，或许是因为我工作三年了，觉得没必要吧，不知道了😂。之后还发生过一些不开心的事情，导致那段时间我非常紧张，总担心自己做不好，好在这一切都过去了，最终还是顺利通过，开心😁。 在这一年的工作中，相比于从工作中学到的技术，更多的是学到的团队配合；如何跟别人配合，如何跟进项目，如何保证一个项目的顺利进行等等。记得当初我刚工作的时候，关注的只有技术，我拿到需求后，关注的只有该怎么实现，能不能从中学到什么东西，能不能用新的技术实现它，其他的合作，进度什么的不会去想，在工作的这几年，渐渐的明白大家如何合作比单单是自己去想该怎么做要重要的多，相比于忙于自己事情，多抬头看看别人在做什么看看整个大局更重要，也许这就是成长吧。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:1:0","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"技术 关于技术方面的学习，今年似乎在前端方面学习的不太多，或者说在前端方面还是那些学习，比如React，Javascript等等，但是2019年跟往年不同的主要是开始注意到，要想称为一名合格的工程师，就不能只懂前端，而对后端一无所知，所以今年主要就是开始学习后端方面的知识。说到这里突然想起了Armin Van Burren（我最喜欢的DJ，Trance之神😁）今年下半年给自己后面的的主题——Balance，也许对我来说也需要Balance，所以在今年开始有意识学习其他技术。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:2:0","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"熟练使用vim和tmux 关于技术方面的提升，第一个就是熟练使用vim和tmux（当然只是使用，更深入的还有待学习）。 从今年开始，我开始全面使用vim+tmux提升效率，终于理解了为什么把vim称为“编辑器之神”，vim结合tmux在终端的使用，简直就是完美，效率真的是太高了，完全脱离鼠标的点击，在开发过程中再也不用点来点去了。虽然从The state of Javascript 2019的调查结果看，在前端 / Javascript界 VS Code 是当之无愧的宇宙第一编辑器（第二是webstrom，第三是vim），但是在我的工作过程中，vim已经超越了VS Code，成为我的主力编辑器。关于vim的使用，后续我会专门写一篇文章介绍，关于tmux的使用可以查看文章：终端复用神器Tmux。 至于为什么放着好好的VS Code不用，要去用vim，我觉得是因为在现在的公司给配置的是笔记本+扩展屏，然后如果想用鼠标的话，就要用笔记本上的触摸板，很不方便，所以我就开始使用vim，让自己在开发过程中，可以减少鼠标的点击，当然这并不是我第一次开始使用vim，在此之前已经尝试过好几次使用vim，但是都因为实在是太难用了，完全是在降低开发效率而告终，这一次终于坚持下来并且成功了。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:2:1","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"学习服务端的知识 从今年下半年开始，自己开始利用工作之余的时间学习一些服务端的知识，选择的语言是go语言，至于为什么想学习服务端，为什么选择go语言，有几个原因： 作为工程师，如果只懂前端不懂服务端，就好像造房子只有榫结构的材料，没有卯结构的材料，无法作出一个完整的成品，所以需要学习服务端，完善自己的技能体系，这样才能真正的做到不设边界，解决问题 个人觉得，想要理解计算机科学，就要去深入学习服务端的东西，不只是只知道前端 自己对go语言有莫名的好奇感而且go语言是一门相对来说比较年轻的语言 在公司中，服务端主要用go做开发，如果学会了，可以看看服务端的东西 在零零散散的看了一些网上的课程和开源的go语言教程后，开始尝试着看go的项目，目前仍然在学习中。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:2:2","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"几点遗憾 今年看了不少书，渐渐的也明白一个道理并试着开始实践，给自己的计划做减法。人的精力是有限的，所以不要给自己规划太多事情，所以今年也舍弃了一些计划，不过这些计划在2020年会重新回到日程： ⚛️React源码学习 其实一直都想研究一下React源码的，React作为我工作中用的最多的前端框架，总觉得天天用而不理解原理实在是不合适，况且如果深入理解源码，对于遇到的一些问题也可以快速找到原因并拿出解决方案同时也可以避免一些坑，所以今年上半年有看过一些React源码，但是因为React源码真的是太复杂了，所以看了一部分之后就没有再研究，这一点比较遗憾。 算法的学习 今年下半年的时候，开始有意识的学习算法，在每天中午休息时间，看《算法》这本书，同时周末的时候自己会总结一下，但是呢，看算法真的是太太太太太慢了，几天只看了那么几页，还不一定全都学会😭，所以后面实在看不下去了，就改看其他书了。也许算法也就像我当年使用vim，放弃了无数次，但是又一次又一次捡起来，最终称为我的利器。关于算法，在2020年依然会学习，但是我觉得我需要好好规划一下如何学习算法。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:2:3","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"金融、投资 2019年在学习金融、投资方面还是下了一些功夫的，主要有以下几点： ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:3:0","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"阅读了很多金融投资方面的书 从2018年开始阅读到2019年，自己的阅读量比以前有了明显的提升，因为自己喜欢研究投资、金融，所以2019年读了很多（相比于读的其他类型的书而言）关于金融、投资的书，大概有下面这些： 《一本书读懂财报》 《第一本经济学》 《债务危机》 《周期 《投资最重要的事》 《聪明的投资者》 《在股市大崩溃前抛出的人》 《富爸爸，穷爸爸》 《股票大作手回忆录》 《金融学》 因为平时工作需要上班，所以一般读书的时间是中午的一个小时休息时间，有时候实在瞌睡的不行就来罐咖啡，就这样利用中午的时间读完了这些书，现在回想起来也是感觉很欣慰。 在这一年中，股市经历了大涨也经历了大跌，所以有人开玩笑说买A股就像坐过山车🎢，看着自己的资产下跌的时候，要说不慌那是假的，为了让自己的内心不因为上涨而洋洋自得，不因为下跌而过度悲伤，所以选择读一些大佬的书，像《富爸爸，穷爸爸》、《聪明的投资者》、《投资最重要的事》、《在股市大崩溃前抛出的人》，这些书让我的内心更加强大，不再害怕下跌。 在2019年中我个人觉得最好的书还是 瑞达里奥的《债务危机》，相比于他2018年的书《原则》，2019年出的《债务危机》是一本纯金融学读物，想读懂这本书，需要有一定的经济、金融学基础，幸亏我在读这本书之前在中国大学MOOC上学习了《金融学》的基础知识，不然真的看不懂（其实就算是学习了这个课程，我在看的过程中也是很难懂，第一部分看了三遍才有感觉😅，之后总结了一篇文章：不可不知的债务危机。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:3:1","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"学习经济、金融学基础 因为自己本身不是金融专业出身，对很多金融、经济学概念都不太熟悉，所以在工作之于自己抽时间在中国大学MOOC上面学习金融学，而且还买了相应的教材，本来想完整学习的，但是说实话，大学教材真的大学是教材，有些地方真的是为了考试而写的，像什么出现历史、意义这些对我来说确实用处不大，所以最后并没有全部学，挑了其中毕竟重要的部分学习了一下。与此同时也阅读了比较基础通俗的经济学读物《第一本经济学》，学完之后感觉还是挺有用的，至少一些基本的\u0008概念能懂了。但是后续要想深入理解，还是要多学习。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:3:2","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"学习阅读财报 买股票本质上是买公司，所以阅读公司财报可以说是做投资的基础技能之一，之前一直都有想法学习阅读财报，但是因为还有其他事情要做所以一直没排上，直到今年11月份才把学习阅读财报列到计划中，本来是想看肖星老师的《财务分析》学习，但是10个小时的视频确实有点儿慢，所以买了配套的教材——《一本书读懂财报》。 说实话《一本书读懂财报》这本书是真心不错，里面关于财务三大报表的概念、含义以及财务分析方法有很详细的讲解，所以这本书可以说是我把它当教材上学时候的课本来读，认认真真的在笔记本上做了笔记，目前这本书快看完了，后续会总结一下发出来。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:3:3","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"关于投资的总结 2018年末，我买入人生中第一支股票，到现在投资整整满一年。 A股方面，因为在2018年年底A股大跌的时候，买入龙头消费和银行，所以这一年在A股的投资收益率还是可以的，比较后悔的一件事儿是当时贵州茅台(SH:600519)才500多一股，但是因为自己没那么多钱而且害怕再次跌所以没有买入，如今一年过去了，贵州茅台涨到了¥1185.80，实在是可惜，不过自己一直持有中证白酒(SZ:399997)的基金，所以也算是分了杯羹吧。😁 港美股方面，今年上半年买入的美股苹果(NASDAQ:AAPL)也给我带来了不错的收益，但是在港股上市的老东家小米集团-W(HK:01810)虽然年底的时候从8块一路上升到10块，但是依然让我亏损惨重，计划2020年再买入一波，期待2020年可以继续上涨。 总体来说2019年投资收益我个人还是比较满意的，期待在2020年自己可以学会财报分析，分析跟多行业，买入更多便宜的股票。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:3:4","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"生活 2019年在生活方面比较开心的有这么几点吧： ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:4:0","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"带着女朋友去了一次EDC 今年最开心的一件事情就是带着女朋友参加了11月23，11月24日在珠海长隆举办的EDC电音节。记得上次去还是2017年，自己一个人从北京跑到上海参加在中国举办的第一届Ultra China，那时候就想将来我一定要带着女朋友来一起参加，如今两年过去了，我的梦想着终于实现了，这一次我不再是一个人😭❤️ ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:4:1","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"阅读了更多的书籍 2019年相比于2018年读了更多的书，除了上面提到过的金融、投资类书籍，还有其他方面的： 《这就是OKR》 《乌合之众》 《见识》 《情商》 《稀缺》 果然还是金融投资类的书籍多😂。 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:4:2","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"在生活中尝试使用OKR，给自己的计划做减法 今年下半年，因为阅读了吴军老师的《见识》，在书中他提到关于他使用OKR管理自己的规划，同时也因为在平时工作中每个双周都要求填写自己的OKR，所以在阅读完《见识》之后又进一步阅读了《这就是OKR》去深入了解OKR是什么，如何使用。 从今年的9月份开始也按照公司的那种模式给自己设置了双月OKR，但是两个双月下来发现实行的不太好，很多都没有完成，我觉得没有完成的主要原因有以下两点： 目标还是太多了，需要再减少一些，毕竟人的精力是有限的，要专注于那些对自己来说最重要的事情（注：这一点在吴军老师的《见识》中有提到，同时巴菲特也在自己的时间管理哲学中提到过（参考文章：巴菲特超越大部分人的地方，在于时间管理） 对于我来说毕竟还是以上班为主，工作占据了我主要的时间，主要精力，而我的目标又不是那么容易完成，所以应该调整OKR的周期，计划从双月改为季度，这样在定了目标之后或许更容易实现 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:4:3","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"遗憾的一点 今年最最最遗憾的就是体重没有减下去，在双月OKR中，都定了要减肥，但是始终没有实现😔，眼看着马上就快过年了，必须在年前减肥，不然的话过完年回来，更是胖的不能看了，之前减肥成功就是晚上不吃饭加锻炼，现在已经再次开启这个模式，期望在过年之前体重可以下来😭 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:4:4","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"展望2020 2019年马上就要过去了，回望2019年，就我个人来说，还是有成长的，又是学习新技术，又是学习投资而且开始使用更加科学的方式规划自己的计划，为什么自己要折腾这些，我想总的来说就是想了解这个世界，不希望平平凡凡的过一生吧。 2020年马上就要到了，新的一年里我会继续2019年没有完成的计划 学习golang，然后可以在项目中实践 学习React源码 学习算法 学习阅读财报，把《一本书读懂财报》读完并总结，然后开始尝试着分析财报 减肥，减肥，减肥！！！ 同时在新的一年里，也有新的期望，期望在2020年可以学习一些新的技术 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:5:0","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"技术 希望（或者说必须）在2020年学习并熟练使用Typescript：如今有一半以上的项目都是使用Typescript写的，可以说Typescript已经变成了必备技能，但是这个技能我还没学会，所以在2020年要加油把ts学会 学会使用GraphQL：从2019年JavaScript调查报告看，GraphQL已经成为开发者们最期望学习的技术，与此同时在2019年越来越多的项目落地了GraphQL，想必将来应用会越来越多，所以学习这个也是必须的 学习SQL：之前在工作中不需要接触SQL，所以会不会无所谓，但是现在在公司开始接触数据库，所以如果自己会写SQL，查数据日志的时候还是很方便的，期望在2020年可以学会SQL的使用 学习Linux：虽然是前端，但是每天都在接触命令行，同时自己用vim+tmux写代码也驱使了对linux系统的好奇，2020年可以学习一波 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:5:1","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["年终总结"],"content":"生活 阅读更多的书：2020年，期望可以阅读更多类型的书籍，比如哲学，历史等等 带着女朋友去ISY跨年：2019年参加了DEC，期望在2020年，可以带着女朋友去ISY跨年到2021😄 最后，贴一个Armin的A State of Trance Year Mix 2019作为结束，祝大家新年快乐。 2019年12月31日凌晨 ","date":"2019-12-31","objectID":"/posts/2019-2020newyear/:5:2","series":null,"tags":["年终总结"],"title":"再见2019，你好2020","uri":"/posts/2019-2020newyear/"},{"categories":["JavaScript"],"content":"在JavaScript中长的链式调用可能容易出错，因为任何一步都可能出现null或undefined（也被称为“无效”值）。检查每个步骤的属性是否存在很容易变成深层次嵌套的if声明或者复制属性访问链的长的if条件： // 容易出错的版本，可能抛出错误 const nameLength = db.user.name.length; // 不容易出错，但是难以阅读 let nameLength; if (db \u0026\u0026 db.user \u0026\u0026 db.user.name) nameLength = db.user.name.length; 以上还可以使用三元表达式，但是同样难以阅读： const nameLength = (db ? (db.user ? (db.user.name ? db.user.name.length : undefined) : undefined) : undefined); ","date":"2019-09-03","objectID":"/posts/2019-optional-chaining/:0:0","series":null,"tags":["JavaScript"],"title":"「译」JS新特性“可选链式调用”","uri":"/posts/2019-optional-chaining/"},{"categories":["JavaScript"],"content":"介绍可选调用链 我们并不想写出这样的代码，所以有一些代替方案是可取的。一些语言（例如swift，具体查看https://www.jianshu.com/p/5599b422afb0）针对这个问题提供了优雅的解决方案——可选调用链。 根据最近的规范，“可选调用链是一个或多个属性访问和函数调用的链，以?.开头”。 使用新的可选调用链，我们可以重写上面的demo： // 依然检查错误，但是可读性更高 const nameLength = db?.user?.name?.length; 使用可选调用链，当db，user，或name是undefined或者null的时候，nameLength被初始化为undefined，而不是像之前那样抛出错误。 **Note：**可选调用链比我们自己用if(db \u0026\u0026 db.user \u0026\u0026 db.user.name)检查更加健壮，例如，如果name是一个空字符串，可选字符串会将name?.length改为name.length然后得到正确的长度0，但是如果像我们之前那样做判断，不会得到正确的值，因为在if语句中空字符和false的行为相同。可选调用链修复了这个常见的bug。 ","date":"2019-09-03","objectID":"/posts/2019-optional-chaining/:1:0","series":null,"tags":["JavaScript"],"title":"「译」JS新特性“可选链式调用”","uri":"/posts/2019-optional-chaining/"},{"categories":["JavaScript"],"content":"其他的语法形式：调用和动态属性 还有一个用于调用可选方法的运算符： // 使用可选方法扩展接口，仅适用于管理员用户 const adminOption = db?.user?.validateAdminAndGetPrefs?.().option; 这个语法可能有点儿出乎意料，因为这里的运算符是?.()，该运算符适用于之前的表达式。 可选调用链还有第三种用法，即可选动态属性访问?.[]。如果对象中有该key对应的value，则返回value，否则返回undefined。demo如下： // 使用动态属性名访问属性对应的值 const optionName = 'optional setting'; const optionLength = db?.user?.preferences?.[optionName].length; 该用法同样适用于可选索引数组，例如： // 如果`userArray`是`null`或`undefined`，则`userName`被优雅的赋值为`undefined` const userIndex = 42; const userName = usersArray?.[userIndex].name; 可选调用链可以和nullish coalescing ?? 操作符结合使用，返回一个非undefined的默认值。这样可以使用指定的默认值安全的进行深层属性访问，解决了之前用户需要JavaScript库才能解决的问题，例如lodash的_.get： const object = { id: 123, names: { first: 'Alice', last: 'Smith' }}; { // With lodash: const firstName = _.get(object, 'names.first'); // → 'Alice' const middleName = _.get(object, 'names.middle', '(no middle name)'); // → '(no middle name)' } { // With optional chaining and nullish coalescing: const firstName = object?.names?.first ?? '(no first name)'; // → 'Alice' const middleName = object?.names?.middle ?? '(no middle name)'; // → '(no middle name)' } ","date":"2019-09-03","objectID":"/posts/2019-optional-chaining/:2:0","series":null,"tags":["JavaScript"],"title":"「译」JS新特性“可选链式调用”","uri":"/posts/2019-optional-chaining/"},{"categories":["JavaScript"],"content":"可选调用链的属性 可选调用链有一些有趣的属性：短路（short-circuiting），堆叠（stacking）和可选删除（optonal deletion）。下面通过例子来了解这些属性。 *短路（short-circuiting）*即如果可选调用链提前返回则不计算表达式的其余部分： // 只有在`db`和`user`不是`undefined`的情况下`age`才会+1 db?.user?.grow(++age); *堆叠（stacking）*意味着可以在一系列属性访问中应用多个可选调用运算符： // 一个可选链可以跟随另一个可选链 const firstNameLength = db.users?.[42]?.names.first.length; 但是，考虑在一个链中使用多个可选调用运算符。如果一个value保证是有效的，那么不鼓励使用?.去访问属性。像在之前的例子中，db必然是定义的，但是db.users和db.users[42]可能是未定义的。如果数据库中有这样的用户，那么name.first.length也是始终被定义的。 *可选删除（optonal deletion）*就是delete操作符可以和可选链一起使用： // 当且仅当`db`是定义过的时候删除`db.user` delete db?.user; 更多细节可以访问该提案的语义部分。 原文链接：https://v8.dev/features/optional-chaining ","date":"2019-09-03","objectID":"/posts/2019-optional-chaining/:3:0","series":null,"tags":["JavaScript"],"title":"「译」JS新特性“可选链式调用”","uri":"/posts/2019-optional-chaining/"},{"categories":["Vim"],"content":"关键点 vim -u NONE -N可以不加载vim配置和插件打开vim vim --startuptime vim.log可以生成vim启动的log 使用vim-plug插件管理工具，给插件配置for or on可以实现插件懒加载 设置foldmethod=syntax会导致vim插入模式下卡顿 用vim已经一年了，之前虽然知道vim会有性能问题，但是之前从来没遇到过，也许也遇到过？貌似把问题推给电脑了，因为印象中，电脑用一天，内存占用会达到80%以上，那时候，vim也会卡，所以一直是想办法把内存降下来。直到最近… 最近用vim打开一个2000多行代码的js文件，发现打开文件时候有一些卡顿，在输入的时候发现，卡到爆炸💥，无法正常输入，但是如果不加载.vimrc和插件，即用vim -u NONE -N打开，完全不会卡，至此确定我遇到了vim性能问题，需要优化我的vim配置。 一般情况下，vim的性能问题都是由于我们装插件太多导致的，本质上是因为vim不支持异步，但是现在（vim8+）支持异步了，所以很多插件都开始转向使用异步API实现自己的功能，比如大名鼎鼎的YouCompleteMe，不过也不是所有的插件都会做支持，毕竟vim好多年了，也许我们用的一些插件都停更好久了。 ","date":"2019-09-01","objectID":"/posts/2019-vimperformance/:0:1","series":null,"tags":["Vim"],"title":"记一次vim性能优化","uri":"/posts/2019-vimperformance/"},{"categories":["Vim"],"content":"vim启动优化 为了优化vim启动，首先可以做的一点是将插件懒加载，即用到哪个插件再加载哪个插件，通过vim-plug插件管理工具可以非常方便的做到，配置方式如下： Plug 'mattn/emmet-vim', { 'for': ['html', 'javascript.jsx'] } Plug 'mxw/vim-jsx', { 'for': 'javascript.jsx' } Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } on表示在某个条件下加载，例如上面的配置表示在输入命令NERDTreeToggle的时候加载nerdtree插件，for表示该插件针对某一类文件加载，例如vim-jsx插件只有在文件类型为javascript.jsx的时候加载。 这样就可以让vim在启动的时候，不加载不必要的插件。 ","date":"2019-09-01","objectID":"/posts/2019-vimperformance/:0:2","series":null,"tags":["Vim"],"title":"记一次vim性能优化","uri":"/posts/2019-vimperformance/"},{"categories":["Vim"],"content":"vim输入性能优化 启动快了，但是输入还是很卡，所以开始寻找是哪个插件的问题。 为了找到具体是哪个插件导致的卡顿，首先可以通过生成的vim.log文件查看vim启动以及使用的时候每一步的时间，具体启动方式如下： # 启动vim并生成vim启动时候的日志 $ vim --startuptime vim.log 这样就可以拿到具体vim启动时候的各个步骤的启动时间，但是查看了日志并没看看出明显的问题🤔，所以开始尝试第二种方法，逐个注销vim的插件，看哪个插件注销后，卡顿会消失。 发现注释掉vim-javascript后，输入变得流畅，所以可以确定是这个插件导致的问题，但是这个插件是用来支持js语法的，不应该出现这么严重的性能问题啊，去GitHub vim-javascript 的 issues中搜索关于performance的帖子，最终找到一篇关于打开大的js文件严重卡顿的原因：Very slow performance in large Js files，在帖子中插件的作者回复到，出现卡顿的原因是设置了foldmethod=syntax（该设置项本来是让vim基于语法进行折叠），作者强调给vim设置该选项本身就会导致插入时候速度变慢，具体原因以及解决方法（文中的解决方案尝试了，但是没有效果😅）可以查看：Keep folds closed while inserting text。 解决方案： 可以给foldmethod设置其他选项（manual，indent，marker） 直接使用vim的一个插件——FastFold实现代码折叠 去掉代码折叠设置 总的来说就是不要在插入模式下使用foldmethod=syntax。 基于以上优化，再打开大型文件，vim不再卡顿，又可以流畅的使用vim编写代码了😁。 ","date":"2019-09-01","objectID":"/posts/2019-vimperformance/:0:3","series":null,"tags":["Vim"],"title":"记一次vim性能优化","uri":"/posts/2019-vimperformance/"},{"categories":["金融"],"content":" 在17年年底，因为数字货币的一轮暴涨，开始关注金融，开始关注股票，基金，学习一些跟金融知识，本文是我自写文章以来第一篇关于金融的文章，是我在阅读瑞达里欧《债务危机》的一些摘要和理解。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:0:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"信贷和债务 要了解债务危机，首先要明确两个概念：信贷和债务。 信贷和债务这两个概念在我们日常生活中经常见到，信贷就是给予他人购买力，例如我们使用支付宝的花呗，银行信用卡，而这些用了之后，我们会在下一个月还花呗和信用卡，这就是偿还债务。对我们个人来说是这样，对国家，企业的发展也是相同的，企业开始的时候，可能因为没钱，无法进行商业活动，所以可能会向银行贷款（信贷），开始自己的商业活动，等将来赚钱了，再还给银行（偿还债务）。这样一个过程中，企业得到发展，银行因为之前放贷然后到期收回，所以也赚到钱，从而促进了整个社会的发展。这是一个理想的过程。 但是这里有一个问题，如果说企业贷款很容易，那就意味着银行贷出去的钱有可能就收不回来了，毕竟将来企业到底发展成什么样，谁都无法保证。但是如果说整个社会信贷严格，那就意味着，很多企业会错失发展机会，从而导致社会发展缓慢。那我们能否找到一个刚好的信贷标准，即能保证社会发展，又能保证银行不会出现大量坏账呢？我理解应该是不能的，因为随着社会的发展，企业的发展机会也在发生变化，社会中的信贷和债务也在发生变化，所以央行要适时调整信贷标准，从而保证经济稳步发展。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:1:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"债务危机的周期性 试想我们使用的信用卡或者花呗，我们在第一个月消费，第二个月因为要还第一个月欠的钱，所以在第二个月紧缩开支，等到发工资后还信用卡，继续这个循环，后面发生的事情，我们可以想到，跟之前一样。对于个人如此，对国家经济也是如此，一旦借款，就启动的了一系列可预测的事情。 我们知道，银行可以接受存款，又可以提供贷款。所以假设企业向银行贷款用作投资，将赚取的利润存入银行以备不时之需，同时可以赚取利息，银行因为有企业的存款，所以可以放出更多的贷款给其他企业，贷款企业都承诺将来还本付息。这其实就是现实生活中的经济运行模式。在将来，企业因为投资失败或者利润减少等原因而面临资金短缺，但是债务依旧不变，所以企业会通过一些手段（例如裁员等）减少支出。银行也将陷入困境，因为存款人对现金的需求不断增加，要从银行取出现金用于企业正常运作，偿还债务，越来越多的债务人难以按时还款。最终导致银行和债务人都破产，经济出现萎缩。 从贷款开始，会出现如下大致过程 自我强化——上升阶段 到达顶峰后转头向下 债务和收入比率达到极限 资金和信贷增长被遏制，或信贷标准提高，那么信贷增速会放缓，偿债问题加速涌现 央行意识到信贷增长过快，已经到了危险的地步，开始收紧货币政策，遏制信贷增长，债务周期加速下滑 自我强化——下降 触底——逆转而上 贷款支撑支出和投资，进而推动收入增加，资产价格上涨。收入和资产价格上涨会导致进一步增加借贷，扩大在商品和金融资产上的支出。在这样一个一个的循环中，支出和收入会提升至超出经济生产力稳步增长所对应的水平。接近债务周期的顶峰时，人们预计以贷款维持的经济会继续以超越趋势水平的速度发展下去（这是不可能的）最终收入低于偿债成本。 泡沫形成的原因是人们不计后果的贷款和不切实际的预期带来大量无法偿还的债务，在这个阶段的典型特征是，越来越的借款被用于还债，但是泡沫不会一直持续下去，某个时间点商业银行和央行察觉出现了大量无法偿还的债务，就会进行调控，此时，泡沫开始收缩。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:2:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"债务危机的形成与调控 一个国家之所以会爆发债务危机，是因为债务和偿债成本的增速高于偿债所需的收入增速。当决策者发现这个情况后，会迅速进行调控，这里理论上有两种调控方式： 降低债务和偿债成本的增速 提高收入增速 在典型的债务危机中，央行可以通过降低实际利率和名义利率（即降息）缓解危机（给市场增加流动性，提高收入降低债务和偿债成本），但是在危机缓解后，人们并不会记得之前危机时候的情况（资不抵债），相反，人们只会记得当初贷款后可以支出更多，购买更多资产，所以接着借贷（人性，人们总是愿意花钱而不愿意还钱），进而再次出现资不抵债的情况，央行继续降息，但是利率总有降到0的时候，当央行无法再继续降息的时候，就会出现严重的债务危机（萧条）。 可以看出其实严重的债务危机（萧条）是由一个一个短期债务危机引起的，在典型情况下，每个短期债务周期（即经济周期)的顶部和底部的债务与收入比率都会高于此前一个短期债务周期，多个短期债务周期的叠加，形成长期债务周期，直到推动债务扩张的降息无法继续，就像下图这样： **tips：**其实这个图是霍华德马克斯《周期》中讲述经济周期的图，但是我理解多个短期债务危机叠加形成长期债务危机也是这个过程，所以在这里借用。 所以从某个角度讲，央行降息推动了债务扩张。 上面我们讲到，贷款支撑的支出和投资最终会导致收入低于偿债成本，导致债务人资不抵债，从而导致债务人债权人双双破产，后果非常严重。所以在出现债务危机后，决策者会进行调控，降低债务与收入之间的比率和偿债总额与用于偿债的现金流之间的比率，从而避免出现这样严重的情况。决策者主要的调控手段： 财政紧缩（即减少支出） 债务违约/重组 央行印钞，购买资产（或提供担保） 将资金和信贷从充足的领域专向不充足的领域 其中央行印钞具有通胀性，会刺激经济增长，而财政紧缩，债务违约具有通缩性，有利于减轻债务负担。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:3:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"债务危机的分类 债务危机主要有通缩性危机和通胀性危机。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:4:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"通缩性危机 在通缩性危机中，决策者通常会通过降息应对最初的经济萎缩，但是当利率降低到接近0%的时候，就需要使用其他经济刺激手段，此时**债务重组和财政紧缩政策占主导地位。**在这个阶段，收入下降速度快于债务重组速度，偿债会减少债务存量，但是为了支付更高的利息成本，许多借款人不得不承担更多债务，因此债务负担（债务和偿债总额占收入的比例）上升。通缩性危机往往出现在大多数债务是国内融资的，以本币计价的国家，因此最终的债务危机会带来抛售和违约，但是不会造成汇率和国际收支问题。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:4:1","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"通胀性危机 通胀性危机经常出现在依赖外资流动的国家。当这些国家已经积累了大量以外币计价的债务，无法对债务进行货币化（即央行印钞购债）。当外资流动放缓，信用创造就会变成信贷紧缩。在通胀性去杠杆化进程中，资本外流导致贷款水平和流动性急剧下降，同时汇率下跌拉高通胀率。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:4:2","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"结语 后扯点儿读《债务危机》和《周期》的感受，在阅读过程中，越来越觉得（其实书中也是这么说的），（金融）历史总是重复的发生着，虽然并不会完全相同的发生，但是有着固定的模式，而我们要做的，是读懂这个时代，明白我们所处在周期的哪个位置，顺应这个潮流，这样才会走向成功。 本文主要讲述债务危机的大概过程，主要是《债务危机》第一节内容的总结以及自己的一些理解，作为非专业人士可能文中有些观点不太正确，如果文中有哪些观点有问题，欢迎指正。 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:5:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["金融"],"content":"附 ","date":"2019-08-07","objectID":"/posts/2019-debtcrisisoverview/:6:0","series":null,"tags":["金融"],"title":"不可不知的债务危机","uri":"/posts/2019-debtcrisisoverview/"},{"categories":["JavaScript"],"content":" 原文链接：https://2ality.com/2019/07/private-class-fields.html class属性是关于直接在类体内创建属性和类似构造，这篇播客文章是关于它们的系列文章的一部分： 公有class属性 私有class属性 在这篇文章中，我们看看私有属性，在类和实例中的一种新的私有插槽。这个功能是ES草案“JavaScript类属性声明”的一部分。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:0:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"1.概览 Private fields是一种与属性不同的新的数据插槽。它们只能在它们声明的class body内直接访问。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:1:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"1.1 静态私有属性 class MyClass { // 声明并初始化静态私有属性 static #privateStaticField = 1; static getPrivateStaticField() { return MyClass.#privateStaticField; // (A) } } assert.throws( () =\u003e eval('MyClass.#privateStaticField'), { name: 'SyntaxError', message: 'Undefined private field undefined:' + ' must be declared in an enclosing class', } ); assert.equal(MyClass.getPrivateStaticField(), 1); 小窍门：永远不要用this来访问一个静态私有属性，直接使用类名访问即可（就像A行那样）。为什么会在本文后面解释。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:1:1","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"1.2 实例私有属性 使用带有初始值的私有属性（等号后面跟值）。 class MyClass { // 声明并初始化 #privateInstanceField = 2; getPrivateInstanceField() { return this.#privateInstanceField; } } assert.throws( () =\u003e eval('new MyClass().#privateInstanceField'), { name: 'SyntaxError', message: 'Undefined private field undefined:' + ' must be declared in an enclosing class', } ); assert.equal(new MyClass().getPrivateInstanceField(), 2); 使用未初始化的实例私有属性： class DataStore { #data; // 必须声明 constructor(data) { this.#data = data; } getData() { return this.#data; } } assert.deepEqual( Reflect.ownKeys(new DataStore()), []); ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:1:2","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"2. 从下划线到实例私有属性 在JavaScript中保持数据私有的公共约定是使用带有下划线的属性名。在这个部分，我们从使用这个约定的代码开始，然后更改它，到使用实例私有属性。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:2:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"2.1 从下划线开始 class Countdown { constructor(counter, action) { this._counter = counter; // private this._action = action; // private } dec() { if (this._counter \u003c 1) return; this._counter--; if (this._counter === 0) { this._action(); } } } // 变量并非真正的私有 assert.deepEqual( Reflect.ownKeys(new Countdown(5, () =\u003e {})), ['_counter', '_action']); 这个约定并没有给我们任何保护；它仅仅建议使用这个类的用户：不要使用这些属性，它们是私有的。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:2:1","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"2.2 切换到实例私有属性 我们可以用实例私有属性代替下划线： 我们用哈希符#替换每一个下划线_。 我们在类的顶部声明所有的私有属性。 class Countdown { #counter; #action; constructor(counter, action) { this.#counter = counter; this.#action = action; } dec() { if (this.#counter \u003c 1) return; this.#counter--; if (this.#counter === 0) { this.#action(); } } } // The data is now private: assert.deepEqual( Reflect.ownKeys(new Countdown(5, () =\u003e {})), []); ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:2:2","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"3. 类主体内的所有代码都可以访问私有属性 例如，实例方法可以访问静态私有属性： class MyClass { static #privateStaticField = 1; getPrivateFieldOfClass(theClass) { return theClass.#privateStaticField; } } assert.equal( new MyClass().getPrivateFieldOfClass(MyClass), 1); 一个静态方法可以访问实例私有属性： class MyClass { #privateInstanceField = 2; static getPrivateFieldOfInstance(theInstance) { return theInstance.#privateInstanceField; } } assert.equal( MyClass.getPrivateFieldOfInstance(new MyClass()), 2); ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:3:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"4.（高级） 剩余部分是关于类的私有属性的高级用法 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:4:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"5. 深入理解私有属性 在规范中，私有属性通过附加到对象上的数据结构进行管理。私有属性的大致处理过程如下： { // Private names const _counter = { __Description__: 'counter', __Kind__: 'field', }; const _action = { __Description__: 'action', __Kind__: 'field', }; class Object { // Maps private names to values __PrivateFieldValues__ = new Map(); } class Countdown { constructor(counter, action) { this.__PrivateFieldValues__.set(_counter, counter); this.__PrivateFieldValues__.set(_action, action); } dec() { if (this.__PrivateFieldValues__.get(_counter) \u003c 1) return; this.__PrivateFieldValues__.set( _counter, this.__PrivateFieldValues__.get(_counter) - 1); if (this.__PrivateFieldValues__.get(_counter) === 0) { this.__PrivateFieldValues__.get(_action)(); } } } } 这里有两点很重要： 私有名称是唯一的key。它们只能在class内访问。 私有属性的值是一个私有名称(key)=\u003e值(value)的字典。每个拥有私有属性的实例都有这样一个字典。只能通过私有变量的key访问其value。 意义： 在类Countdown中，只能访问存储在.#counter 和 #action 的私有数据——因为在这个类中你只有这两个私有变量。 私有属性不能被子类访问。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:5:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"6. 陷阱：使用this访问私有静态属性 你可以使用this访问公有静态属性，但是你不应该使用它访问私有静态属性。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:6:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"6.1 this和静态公有变量 class SuperClass { static publicData = 1; static getPublicViaThis() { return this.publicData; } } class SubClass extends SuperClass { } 公有静态属性（Public static fields）是属性。如果我们用一个方法调用： assert.equal(SuperClass.getPublicViaThis(), 1); this指向SuperClass，一切都按照我们预想的那样工作。我们也可以通过子类调用.getPublicViaThis()。 assert.equal(SubClass.getPublicViaThis(), 1); SubClass继承了.getPublicViaThis()方法，this指向SubClass，代码依旧可以运用，因为SubClass也继承了.publicData。 （注：在这种情况下设置.publicData会在SubClass上创建新的属性，这个属性不会覆盖在SuperClass上定义的属性） ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:6:1","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"6.2 this和私有静态属性 考虑这段代码： class SuperClass { static #privateData = 2; static getPrivateViaThis() { return this.#privateData; } static getPrivateViaClassName() { return SuperClass.#privateData; } } class SubClass extends SuperClass { } 通过SuperClass可以调用.getPrivateViaThis()，因为this指向SuperClass： assert.equal(SuperClass.getPrivateViaThis(), 2); 然而，通过SubClass无法调用.getPrivateViaThis()，因为此时this指向SubClass，而SubClass没有私有静态变量.#privateData： assert.throws( () =\u003e SubClass.getPrivateViaThis(), { name: 'TypeError', message: 'Read of private field #privateData from' + ' an object which did not contain the field', } ); 解决办法是直接通过SuperClass访问.#privateData，就像SuperClass中的getPrivateViaClassName方法。 assert.equal(SubClass.getPrivateViaClassName(), 2); ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:6:2","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"7. “友好”和“被保护的”隐私 有时候我们想要某些实体成为某一类的“朋友”。这个朋友应该可以访问calss的私有数据（译者注：这里其实就是想控制哪些可以访问私有属性，哪些不可以）。在以下代码中，函数getCounter()是类Countdown的朋友。我们通过使用WeakMaps生成私有数据，这样Countdown就允许朋友们访问该数据。 const _counter = new WeakMap(); const _action = new WeakMap(); class Countdown { constructor(counter, action) { _counter.set(this, counter); _action.set(this, action); } dec() { let counter = _counter.get(this); if (counter \u003c 1) return; counter--; _counter.set(this, counter); if (counter === 0) { _action.get(this)(); } } } function getCounter(countdown) { return counter.get(countdown); } 这样就很容易控制哪些可以访问私有数据：如果它们可以使用_counter和_action，它们就可以访问私有数据。如果我们将前面的代码片段放到一个模块中，那么数据在整个模块中是私有的。 有关此技术的更多信息，可以查看Sect的“使用WeakMaps保持私有数据”。这同样适用于在superclass和subclass之间共享私有数据（“被保护”的可见度）。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:7:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"8. FAQ ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:8:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"8.1 为什么是#？为什么不通过private属性声明私有属性？ 原则上，私有属性应该用如下方式声明： class MyClass { private value; compare(other) { return this.value === other.value; } } 但是我们不能在整个class内的任何地方使用属性名值——它们总是被解释为私有变量。 静态类型语言，例如TypeScript在这方面具有更多的灵活性：它们在编译的时候就知道是否是MyClass的一个实例并且可以是否将.value作为一个私有变量对待。 ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:8:1","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["JavaScript"],"content":"key word class私有属性（private class fields） 静态私有属性（private static fields） 实例私有属性（private instance fields） ","date":"2019-07-21","objectID":"/posts/2019-privatefields/:9:0","series":null,"tags":["JavaScript"],"title":"「译」ES 草案：class私有属性","uri":"/posts/2019-privatefields/"},{"categories":["leetCode"],"content":"题目 罗马数字使用七个不同的符号表示：I，V，X，L，C，D和M。 Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如，罗马数字II表示2，就是将两个1加在一起。12被写作XII。27被写作XXVII，就是XX+V+II。 罗马数字通常从左到右，从最大到最小。然而，数字4不是IIII。而是IV。因为1写到5前面得到4，相同的原理，9被表示成IX。这里有6个使用剑法的例子🌰： I放在V(5)和X(10)前面表示4和9 X放在L(50)和C(100)前面表示40和90 I放在V(500)和X(1000)前面表示400和900 给定一个罗马数字，转换成整数。输入保证在1到3999。 Example1 Input: \"III\" Output: 3 Input: \"IV\" Output: 4 Input: \"IX\" Output: 9 Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 难度：Easy ","date":"2019-07-16","objectID":"/posts/2019-leetcode-romantoint/:0:1","series":null,"tags":["leetCode"],"title":"Roman To Int","uri":"/posts/2019-leetcode-romantoint/"},{"categories":["leetCode"],"content":"思路 使用了JS的Map，生成有序的罗马数字和整数的对应关系 将输入的字符串使用String.prototype.split()将每个字母转换成数组的元素。 遍历数组，从Map中拿对应关系，这里使用两个相邻元素A,B对应的数字NA和NB比较，如果NA\u003cNB小，result - NA，否则result + NB。 ","date":"2019-07-16","objectID":"/posts/2019-leetcode-romantoint/:0:2","series":null,"tags":["leetCode"],"title":"Roman To Int","uri":"/posts/2019-leetcode-romantoint/"},{"categories":["leetCode"],"content":"代码实现 /** * @param {string} s * @return {number} */ /* { 'I' =\u003e 1, 'V' =\u003e 5, 'X' =\u003e 10, 'L' =\u003e 50, 'C' =\u003e 100, 'D' =\u003e 500, 'M' =\u003e 1000 } */ var romanList = [ {name: 'M', value: 1000}, {name: 'D', value: 500}, {name: 'C', value: 100}, {name: 'L', value: 50}, {name: 'X', value: 10}, {name: 'V', value: 5}, {name: 'I', value: 1} ] var getRomanMap = (s) =\u003e { const mapData = new Map(); romanList.forEach(v =\u003e { mapData.set(v.name, v.value); }); console.log(mapData); return mapData; } var romanToInt = function(s) { const romanMap = getRomanMap(s); const strArr = s.split(''); let result = 0; let nowData = 0; let next = 0; for(let i = 0; i \u003c strArr.length; i++) { nowData = romanMap.get(strArr[i]); next = romanMap.get(strArr[i + 1]); if (nowData \u003c next) { result -= nowData; } else { result += nowData; } } console.log(result); return result; }; ","date":"2019-07-16","objectID":"/posts/2019-leetcode-romantoint/:0:3","series":null,"tags":["leetCode"],"title":"Roman To Int","uri":"/posts/2019-leetcode-romantoint/"},{"categories":["leetCode"],"content":"题目 给定一个整数数组，返回两个数的索引，这两个数相加等于特定的目标。 你可以假定每次输入只有一个解决方案，并且你不会使用相同的元素两次。 Example： Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 难度：Easy ","date":"2019-07-16","objectID":"/posts/2019-leetcode-twosum/:0:1","series":null,"tags":["leetCode"],"title":"Two Sum","uri":"/posts/2019-leetcode-twosum/"},{"categories":["leetCode"],"content":"思路 题目要求在数组中寻找两个数A和B，相加等于一个特定的数traget，返回A和B的索引，我们可以用给定的数traget减去A，看B是否存在于数组中即可。 ","date":"2019-07-16","objectID":"/posts/2019-leetcode-twosum/:0:2","series":null,"tags":["leetCode"],"title":"Two Sum","uri":"/posts/2019-leetcode-twosum/"},{"categories":["leetCode"],"content":"代码实现 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { for(let i = 0; i \u003c nums.length; i++) { let result = target - nums[i]; let key = nums.indexOf(result); if (key !== -1 \u0026\u0026 i !== key) { return [i, key]; } } }; ","date":"2019-07-16","objectID":"/posts/2019-leetcode-twosum/:0:3","series":null,"tags":["leetCode"],"title":"Two Sum","uri":"/posts/2019-leetcode-twosum/"},{"categories":["JavaScript"],"content":"原文链接：https://v8.dev/features/stable-sort#support 假设你有一系列的狗狗，每个狗狗有名字和评分。（如果这个例子看起来很奇怪，你应该知道有一个专门针对这个的Twitter账户…别问为什么！） // Note:按字母顺序进行预排序 const doggos = [ { name: 'Abby', rating: 12 }, { name: 'Bandit', rating: 13 }, { name: 'Choco', rating: 14 }, { name: 'Daisy', rating: 12 }, { name: 'Elmo', rating: 12 }, { name: 'Falco', rating: 13 }, { name: 'Ghost', rating: 14 }, ]; // 按照`rating`把狗狗进行降序排序 // （这会更新doggos） doggos.sort((a, b) =\u003e b.rating - a.rating); 数据按照字母顺序与排序。为了按照评分排序（所以我们首先得到评分最高的狗狗），我们使用Array#sort，传递一个比较评分的自定义回调。排序后的结果如下： [ { name: 'Choco', rating: 14 }, { name: 'Ghost', rating: 14 }, { name: 'Bandit', rating: 13 }, { name: 'Falco', rating: 13 }, { name: 'Abby', rating: 12 }, { name: 'Daisy', rating: 12 }, { name: 'Elmo', rating: 12 }, ] 狗狗按照评分排序，但是在每个评分内，它们依然按照名字的字母的顺序排序。例如，Choco和Ghost的评分都是14，但是在排序结果中Choco在Ghost的前面，因为这也是它们在原始数据中的顺序。 但是要得到这个结果，JavaScript引擎不能只使用任何排序算法——排序算法必须是“稳定的排序”。很长时间里，JavaScript规范并不要求Array#sort进行排序的稳定性，而是将其留给实现过程。因为这种行为没有具体说明，所以你可能得到的Ghost排在Choco前面的排序结果。 [ { name: 'Ghost', rating: 14 }, // 😢 { name: 'Choco', rating: 14 }, // 😢 { name: 'Bandit', rating: 13 }, { name: 'Falco', rating: 13 }, { name: 'Abby', rating: 12 }, { name: 'Daisy', rating: 12 }, { name: 'Elmo', rating: 12 }, ] 换句话说，JavaScript开发者不能依赖排序的稳定性。在实践中，情况可能更令人愤怒，因为有些JavaScript引擎对短数组进行稳定排序而对长数组进行不稳定排序。这让人非常困惑，开发者在测试他们的代码时候，看到的是稳定的排序，但是当数组略大的时候，突然在生产环境中获得不稳定排序的结果。 但是有一些好消息。我们提出规范变更，让Array#sort变得稳定，并且被接受。现在，所有的JavaScript主流引擎都实现了稳定的Array#sort。作为开发人员，只需要担心一件事情，太好了！ （我们做了同样的事情为TypedArrays：它的sort现在也稳定了） 尽管现在每个规范都要求稳定，JavaScript引擎依然可以自由的实现它们想要的排序算法。例如V8使用的Timsort。该规范并不要求任何特定的排序算法。 译者注： Timsort算法是非常有名的一个算法，在保证高性能的同时还能保证性能稳定。 TimSort的设计思路很新颖（当然也可能借鉴了其他算法）：既然单个算法会遇到最好情况和最差情况导致性能不稳定，那么是不是可以先分析数组特征，然后扬长避短在多种算法中选取合适的算法进行排序呢？ 所以实际上TimSort是多种排序算法+分块算法+翻转，是一种“混合排序算法调度算法”。 有很多语言引擎默认使用TimSort作为原生排序算法，如Python（2.3开始）、Java SE 7、Android platform、GNU Octave。 ","date":"2019-07-08","objectID":"/posts/2019-stablesort/:0:0","series":null,"tags":["JavaScript"],"title":"【译】稳定的Array.prototype.sort","uri":"/posts/2019-stablesort/"},{"categories":["JavaScript"],"content":"特性支持 ","date":"2019-07-08","objectID":"/posts/2019-stablesort/:1:0","series":null,"tags":["JavaScript"],"title":"【译】稳定的Array.prototype.sort","uri":"/posts/2019-stablesort/"},{"categories":["JavaScript"],"content":"稳定的Array.prototype.sort Chrome 70+ Firefox混合支持 Safari混合支持 Node 12+ Babel ","date":"2019-07-08","objectID":"/posts/2019-stablesort/:1:1","series":null,"tags":["JavaScript"],"title":"【译】稳定的Array.prototype.sort","uri":"/posts/2019-stablesort/"},{"categories":["JavaScript"],"content":"稳定的%TypedArray%.prototype.sort Chrome 74+ Firefox 67+ Safari混合支持 Node 12+ Babel ","date":"2019-07-08","objectID":"/posts/2019-stablesort/:1:2","series":null,"tags":["JavaScript"],"title":"【译】稳定的Array.prototype.sort","uri":"/posts/2019-stablesort/"},{"categories":["React"],"content":"原文链接：The 10 Component Commandments 创建被很多人用的组件是很难的。如果那些props作为公共API，你需要非常谨慎的考虑哪些props是可以接收的。 这篇文章将给你快速介绍API的最佳实践方法，同时有十条实践戒律清单，你可以在创建组件的时候使用，你的开发者将会很乐意使用它们。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:0:0","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"什么是API？ 一个API或者说一个应用程序接口，基本上就是两段代码相遇的地方。它连接你的代码和剩下的世界。我们称这种连接为接口。它是你可以与之交互的一组定义的actions或者data actions。 后端与前端之间的接口称为API。你可以通过与此API交互访问给定的一组数据和功能。 类和调用该类的代码之间的接口也是API，你可以调用类里面的方法去取数据或者触发封装在其中的功能。 按照同样的思路，你组件接收props同样也是API。这是你的用户和你的组件的交互方式，当你决定暴露哪些公共API，会有很多同样的规则和注意事项。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:0:1","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"API设计中的一些最佳实践 所以在设计API的时候，有哪些适用的规则和考虑因素？我们为此做了一些研究，结果发现那里有很多很棒的资源。我们选择了两篇文章——Josh Tauberer的What Makes a Good API ?和Ron Kurir’s article with the same title——我们提出了4个最佳实践。 稳定的版本控制 当你考虑创建一个API，其中一个最重要的事情就是尽可能保证API的稳定。这意味着要最大限度减少break change。如果你必须引入一个break change，要确保写明确的升级指南，如果可能的话，提供一个代码模块，为使用者自动化升级。 如果你发布一个API，确保遵循语义版本控制。这让使用者决定使用哪个版本变得很容易。 描述性错误信息 每当当调用你的API发生错误，你应该尽可能解释是什么发生了错误，如何修正该错误。没有任何其他上下文的情况下使用“错误使用”响应不是一个好的用户体验。 相反，写描述性错误，帮助用户修正他们调用API时候的错误。 减少开发人员的意外 开发人员是脆弱的生物，你不想在他们使用你的API时候惊吓他们。换句话说，让你的API尽可能的保持直观。你可以根据最佳实践和命名规范实现它们。 要记住的另一件事情是你记得跟你的代码保持一致。如果你在一个地方的boolean值之前加了is或has，但是在下一个地方没有加，很容让人产生困惑。 最小化你的API 虽说我们说的是最小化东西——尽量减少你的API。有很多功能是非常好的，但是你的API越少，你的用户学习起来就越容易。反过来，这被认为是一个易于使用的API。 总有办法控制API的大小——其中一个方法就是从旧的API重构一个新的API。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:0:2","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"十个组件的告诫 这里有4个黄金法则适用于Pascal中的REST API和旧程序，但是如何转化到现代世界的React？ 就像我们前面提到的，组件有它们自己的API。我们称它们为props , 这就是我们如何用数据，回调函数和其他功能来提供组件。我们如何构建不违反上述规则的props对象？我们如何写方便其他开发人员测试的组件？ 我们创建了当你创建你的组件的时候10个需要遵循的规则清单，希望它们对你有用。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:0","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"1.编写文档 如果没有好的文档说明你的组件如何使用，那么根据定义，这个组件是无用的，虽然几乎所有的用户都可以查看组件的实现方式，但是这样做用户体验会很糟糕。 有几种方式来记录组件，但是这里的三种选择是我们所推荐的： Storybook Styleguidist Docz 前两个为你提供组件开发的场所，而第三个让你用MDX编写更自由的文档。 不管你选择哪个，要保证记录API以及如何，何时使用组件。最后一部分在共享组件库中非常重要——所以人们在给定的上下文中使用争取的按钮或者布局网格。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:1","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"2.允许上下文语意 HTML是一种用语义方式构建信息的语言。然而，我们大多数组件使用div标签。这个在某种程度上说是有道理的——因为通用组建无法真正的假设它应该是一个\u003carticle /\u003e或者\u003csection /\u003e或者一个\u003caside /\u003e——但这并不理想。 我们建议你允许你的组件接受一个as作为props，这将始终允许你覆盖正在呈现的DOM元素。这里是如何实现的一个demo： function Grid({ as: Element, ...props }) { return \u003cElement className=\"grid\" {...props} /\u003e } Grid.defaultProps = { as: 'div', }; 我们重命名as为局部变量Element在JSX中使用，同时我们给as一个默认值，在不传递语义标签的时候使用。 当使用这个\u003cGrid /\u003e组件时，你只需要传递正确的标签即可： function App() { return ( \u003cGrid as=\"main\"\u003e \u003cMoreContent /\u003e \u003c/Grid\u003e ); } 注意，这对React组件同样有效。如果你想有一个\u003cButton /\u003e组件，渲染为React Router的\u003cLink /\u003e： \u003cButton as={Link} to=\"/profile\"\u003e Go to Profile \u003c/Button\u003e ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:2","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"3.避免使用布尔类型pops 布尔类型的props听起来很不错，你可以不实用value指定它们，所以它们看起来很优雅： \u003cButton large\u003eBUY NOW!\u003c/Button\u003e 但是即使它们看起来很优雅，布尔属性只允许使用两个属性。on或off，显示或隐藏，1或0。 每当你开始为像大小，颜色或者任何可能不是二元选择的属性使用布尔属性，你可能会陷入麻烦。 \u003cButton large small primary disabled secondary\u003e WHAT AM I?? \u003c/Button\u003e 换句话说，布尔属性无法随着需求的变化而变化。使用类似字符串的枚举值作为属性可能是一个更好的选择： \u003cButton variant=\"primary\" size=\"large\"\u003e I am primarily a large button \u003c/Button\u003e 这并不是说布尔属性没有使用的地方。disabled这样的属性还是应该使用布尔值——因为这里不会有介于启用和禁用的属性之间。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:3","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"4.使用props.children React有一些特殊的属性，它们的处理方式与其他属性不同。其中一个是key，它用于跟踪列表项顺序，另一个就是children。 任何放在打开和闭合的组件标签之间的东西都可以用props.children读取到。你应该尽可能使用它。 这样做的原因是，它比使用contentprops或者通常只接受简单值（比如文本）要简单的多。 \u003cTableCell content=\"some text\"\u003e // vs \u003cTableCell\u003eSome text\u003c/TableCell\u003e 这里有几个使用props.children的好处。首先它类似于常规的HTML的工作方式。其次，你可以自由的传递任何你想传递的！而不是给你的组件添加leftIcon和rightIcon props——只需要将它们作为props.children的一部分。 \u003cTableCell\u003e \u003cImportantIcon /\u003e Some text \u003c/TableCell\u003e 你总是争辩说你的组件只允许传纯文本，在一些情况下，这可能是真实的。但是至少现在，使用props.children可以为不断变化的需求检验你的API。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:4","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"5.让parent hook进入内部逻辑 有时候我们创建有大量内在逻辑和状态的组件，比如自动完成下拉菜单或者交互式图标。 这些组件通常遭遇冗余的API，其中一个原因是随着时间的推移你通常需要支持覆盖量和一些特殊的用法。 如果我们只是提供一个单一，标准化的props，可以被用户控制，作出反应或者覆盖默认行为的组件呢？ Kent C. Dodds 写过关于这个概念的非常赞的文章，叫做“state reducers”。有关概念本身的贴子，另一篇是如何使用React hooks实现它。 快速总结一下，这种传递“state reducers”函数到你组件的模式可以让组件使用者访问组件内部的所有actions。你可以改变state甚至触发副作用。这是一种非常好方式，允许高级定制，而不是所有的props。 function MyCustomDropdown(props) { const stateReducer = (state, action) =\u003e { if (action.type === Dropdown.actions.CLOSE) { buttonRef.current.focus(); } }; return ( \u003c\u003e \u003cDropdown stateReducer={stateReducer} {...props} /\u003e \u003cButton ref={buttonRef}\u003eOpen\u003c/Button\u003e \u003c/\u003e } 顺便说一句，你当然可以创建更简单的方式对事件作出反应。提供一个onClose prop 在前面的例子中可能带来更好的用户体验。保存state reducer模式，以备不时之需。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:5","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"6.传递剩余的props 每当你创建新组建——要确保剩余的props被用于任何有意义的元素。 你不必继续在你的组件上添加props，只需要将它们传递到底层组件或者元素上就行。这样做将让你的API更加稳定，无论何时，下一个开发者需要新的监听器或者aria-tag，都无需大量的小版本的颠簸。 你可以像这样做： function ToolTip({ isVisible, ...rest }) { return isVisible ? \u003cspan role=\"tooltip\" {...rest} /\u003e : null; } 每当你的组件在实现中传递props，例如一个类名或者onClick回调，要确保外部使用者会做同样的事情。在使用calss的时候，你可以简单使用npm 包 classnames或者简单的字符串连接附加props。 import classNames from 'classnames'; function ToolTip(props) { return ( \u003cspan {...props} className={classNames('tooltip', props.tooltip)} /\u003e } 对于点击处理和其他回调，你可以使用工具将它们组合到一个函数，就像这样： function combine(...functions) { return (...args) =\u003e functions .filter(func =\u003e typeof func === 'function') .forEach(func =\u003e func(...args)); } 这里，我们创建了一个接受你的函数list并将它们组合的函数，它返回一个使用相同参数顺序调用函数list的回调。 你可以这样使用它们： function ToolTip(props) { const [isVisible, setVisible] = React.useState(false); return ( \u003cspan {...props} className={classNames('tooltipp', props.className)} onMouseIn={combine(() =\u003e setVisible(true), props.onMouseIn)} onMouseOut={combine(() =\u003e setVisible(false), props.onMouseOut)} /\u003e ); } ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:6","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"7.提供足够的默认值 只要你可以，请确保为你的props提供足够的默认值。通过这种方式，你可以使你必须传递props的数量最少——这样可以大大简化你的实现。 拿onClick处理函数举例。如果你的代码中没有要求，提供一个空函数作为默认值。通过这种方式，你可以调用该函数，就好像它总是被提供。 另一个例子是自定义输入。除非明确提供，否则假设输入的字符串是一个空字符串。这将让你确保你始终处理的是字符串对象，而不是undefined或者null。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:7","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"8.不要重命名HTML的属性 HTML有着自己的props或者说属性，它本身就是HTML元素的API。为什么不继续使用这个API？ 正如我们前面提到的，将API最小化和使其变得直观是优化你的组件API的很好的方式。所以与其在你的组件中使用自己创建的screenReaderLabelprops，为什么不直接使用已经给你提供好的aria-labelAPI？ 所以，为了自己的“易用性”不要重命名任何现有的HTML属性。你甚至不应该用新的API替换现有的API，而是应该在上层添加你自己的。用户可以将aria-label和你定义的screenReaderLabel一起传递，那么最终的value应该是哪个呢？ 另外，你的组件中要确保永远不覆盖HTML的属性。一个好的例子是\u003cbutton\u003e的type属性。它可以是submit（默认值），button或者reset。然而，很多开发者喜欢重定义这个属性的用途作为button的视觉属性（primary, cta和其他）。 通过改变这个props的用途，你必须添加其他属性去覆盖真实的type属性，这只会给用户带来混乱，困惑和痛苦。 相信我——我一次又一次的犯这个错误——这真是一个让人难以接受的决定。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:8","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"9.给props添加types 没有文档会比内嵌在代码中的文档更好（译者注：言外之意是再好的文档也比不上规范的代码，毕竟一目了然）。React提供prop-types包去申明你的组件API。现在，开始使用它。 你可以指定你所需和可选择的props的任何类型和形式，你甚至可以使用JSDoc comments去改善它。 如果你省略所需的pros，或者传递一个无效的或不是期望得到的值，你将在控制台看到一个运行时的warning。这对开发时非常友好，在构建生产环境时可以去除。 如果你使用Typescript或者Flow写React，你可以将这种API文档作为语言特性。这样可以提供更好的工具支持和出色的用户体验。 如果你没有使用类型化JavaScript，你仍然应该考虑为那些使用者提供type定义。通过这种方式，用户在使用你的组件时将变得更容易。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:9","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"10.为开发者设计 最后一个最重要的规则。确保你的API和“组件体验”针对将使用它的人进行优化——你的开发者。 其中一种优化开发者体验的方式是对无效的使用提供足够的错误信息，以及当有更好的方式来使用你的组件的时候的开发警告。 当写你的错误和警告，确保用链接引用你的文档或者提供简单的代码示例。使用者越快弄明白哪里出了错并且如何修复它，就，你的组件使用起来就感觉越好。 事实证明，拥有这些冗长的错误和警告并不会影响你包的最终大小。感觉死码消除的奇迹，所有的这些文字和错误码，在打包到生产环境时都会被移除。 React本身就是一个非常出色的包。每当你忘记给你的list item指定key，或者拼错生命周期，或者忘记正确的类继承或者使用不确定的方式调用hooks，你将在控制台看到错误信息。为什么使用你组件的用户应该期望的比这些少？ 所以为你未来的用户设计。5周内为自己设计。为那些可怜的笨蛋设计，他们必须在你离开后维护你的代码!为开发人员设计。 ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:1:10","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["React"],"content":"总结 我们可以从经典的API设计中学到很多东西。通过本文提到的这些提示，技巧，规则和戒律，你应该创建 使用容易，维护简单并且在必要时非常灵活的组件。 在创建组件的这些tips中，你最喜欢哪一个呢？ ","date":"2019-07-07","objectID":"/posts/2019-componentstips/:2:0","series":null,"tags":["React"],"title":"【译】10个React组件的戒律","uri":"/posts/2019-componentstips/"},{"categories":["Linux"],"content":" 记得第一次接触tmux是在一年前，当时是为了复用终端，不想开多个item2的tab，但是后来发现完全不会用，就一直搁在那儿，直到半年前再次拿起来，开始学习一些tmux的用法，如今半年过去了，真正的明白了为什么说tmux是神器。 在用tmux之前一直都是用的iterm2（在mac上很好用的终端）原生的新开tab和分屏，其实也还好，界面看起来就像这样： 但是分屏很多之后，可以看到很多状态栏，并不是很美观，对比tmux的分屏，看起来就要hack很多，tmux的分屏界面如下： 正是基于这个原因，开始学着始使用tmux。 ","date":"2019-06-23","objectID":"/posts/2019-tmux/:0:0","series":null,"tags":["Linux"],"title":"终端复用神器Tmux","uri":"/posts/2019-tmux/"},{"categories":["Linux"],"content":"安装 tmux的仓库：https://github.com/tmux/tmux 首先安装tmux： # mac安装 brew install tmux # linux 安装 sudo apt-get install tmux 开始学习tmux之前首先要明确几个概念： session：概括一个任务，是一组window的集合，在任务开始前创建一个session，与此任务相关的状态都会保存在session中，通过重新连接session可以方便的继续未完成的任务。session最大的最用就是持久的保存工作状态 window：tmux中的window其实就是我们常说的tab，在chrome中，新开一个tab就会新建一个页面，tmux也类似 pane：单个window可以分成若干pane，就像前面使用iterm2分屏一样 简单来说就是：session包含window，window包含pane ","date":"2019-06-23","objectID":"/posts/2019-tmux/:0:1","series":null,"tags":["Linux"],"title":"终端复用神器Tmux","uri":"/posts/2019-tmux/"},{"categories":["Linux"],"content":"session 新建 安装完成后，在终端直接输入tmux即可进入tmux。进入之后可以看到session的名字是0，这是因为我们直接输入tmux会创建一个无名的会话，如果想要新建session的时候给session命名，可以使用以下命令： tmux new -s your-session-name 断开 如果想要断开当前session可以使用 tmux detach # 断开当前会话 或者使用快捷键[prefix]+d，其中prefx默认为ctrl+b 恢复 退出session之后，想要恢复之前工作的区域，直接在终端输入： tmux attach-session -t your-session-name # 可以简写 tmux a -t your-session-name 其中session-name是可选的，如果不输入，默认进入第一个会话。 关闭 使用完成后，要关闭，可以使用tmux kill命令，kill有以下四种： kill-server：关闭sessions，clients和server，这个命令会将tmux创建的都关闭 kill-session kill-window kill-pane # 关闭session tmux kill-session -t your-session-name # 关闭所有 tmux kill-server 查看 tmux list-session # 简写 tmux ls 或者使用快捷键prefix+s查看所有session，prefix+w查看所有window。 ","date":"2019-06-23","objectID":"/posts/2019-tmux/:0:2","series":null,"tags":["Linux"],"title":"终端复用神器Tmux","uri":"/posts/2019-tmux/"},{"categories":["Linux"],"content":"tmux基础配置 tmux的配置在~/.tmux.conf文件中，如果没有该文件，可以先新建配置文件。 配置tmux前缀 前面介绍session使用的时候，提到过一些快捷键，可以看到都是prefix+xxx的形式，这里的prefix是tmux的前缀键，默认为ctrl+b，只有按下prefix，才会激活tmux，然后再按其他键进行tmux操作，这样做的一个好处是可以有效的避免和其他应用快捷键的冲突。 但是如果经常用tmux，就会发现ctrl和b这两个键按的不是很舒服，我们是否可以修改一个更加舒服的前缀键呢？当然是可以的，只需要在tmux的配置文件中解绑原有的prefix并修改成我们自定义的即可。配置如下： set -g prefix C-a # 解绑原有的prefix unbind C-b bind C-a send-prefix 配置完成后，需要重启tmux，或者按下ctrl+b，然后输入:进入命令模式，输入： source-file ~/.tmux.conf 或者我们给让配置生效添加快捷键： bind r source-file $HOME/.tmux.conf \\; display-message 'Config reloaded' 这样，直接输入prefix+r就可以让配置生效。 分屏 在tmux中，水平和竖直分屏默认快捷键为prefix+\" 和 prefix+%，这两个键可以说很少用而且不容易按到，我们可以自定义自己习惯的快捷键，对于对vim熟悉的用户，可以将其设置为跟vim一样的快捷键： bind C-h splitw -v -c '#{pane_current_path}' bind C-v splitw -h -c '#{pane_current_path}' 这里的splitw其实是split-window的缩写，-c '#{pane_current_path}'表示在打开新pane的时候，默认进入当前目录。 切换pane 在iterm2中，切换标签的快捷键是commond+option+方向键或commond+[或commond+]，相应的在tmux中，切换pane默认快捷为prefix+方向键但是方向键本身和ctrl离的太远，操作不方便，同样的我们可以设置自己喜欢的快捷键，例如设置跟vim一样的快捷键（这里多说一句，其实在vim中最常用的控制方向的键就是hjkl，如果习惯使用vim，可以设置tmux与之相同快捷键）。 bind h select-pane -L # up bind j select-pane -D # down bind k select-pane -U # left bind l select-pane -R # right 开启鼠标支持 在刚上手tmux的时候，总觉得各种命令很麻烦，而且不好记，如果支持鼠标就更好了，其实想要支持鼠标，只需要在配置文件中开启即可： set-option -g mouse on 开启鼠标之后，切换pane可以直接点击激活，调整分屏大小可以直接拖拽实现。 当然了，既然使用了tmux，目的就不只是界面好看而已，而是要提高效率，所以尽量少用鼠标😏 调整pane 如果想要使用快捷键调节pane大小，同样可以设置快捷键实现： bind H resize-pane -L 10 # 向左扩展10 bind L resize-pane -R 10 # 向右扩展10 bind K resize-pane -U 5 # 向上扩展5 bind J resize-pane -D 5 # 向下扩展5 这样通过prefix+HJKL实现pane的扩展 ","date":"2019-06-23","objectID":"/posts/2019-tmux/:0:3","series":null,"tags":["Linux"],"title":"终端复用神器Tmux","uri":"/posts/2019-tmux/"},{"categories":["Linux"],"content":"附 前缀 指令 描述 Ctrl+b ? 显示快捷键帮助文档 Ctrl+b d 断开当前会话 Ctrl+b D 选择要断开的会话 Ctrl+b Ctrl+z 挂起当前会话 Ctrl+b r 强制重载当前会话 Ctrl+b s 显示会话列表用于选择并切换 Ctrl+b : 进入命令行模式，此时可直接输入ls等命令 Ctrl+b [ 进入复制模式，按q退出 Ctrl+b ] 粘贴复制模式中复制的文本 Ctrl+b ~ 列出提示信息缓存 window 前缀 指令 描述 Ctrl+b c 新建窗口 Ctrl+b \u0026 关闭当前窗口（关闭前需输入y or n确认） Ctrl+b 0~9 切换到指定窗口 Ctrl+b p 切换到上一窗口 Ctrl+b n 切换到下一窗口 Ctrl+b w 打开窗口列表，用于且切换窗口 Ctrl+b , 重命名当前窗口 Ctrl+b . 修改当前窗口编号（适用于窗口重新排序） Ctrl+b f 快速定位到窗口（输入关键字匹配窗口名称） pane 前缀 指令 描述 Ctrl+b \" 当前面板上下一分为二，下侧新建面板 Ctrl+b % 当前面板左右一分为二，右侧新建面板 Ctrl+b x 关闭当前面板（关闭前需输入y or n确认） Ctrl+b z 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增） Ctrl+b ! 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） Ctrl+b ; 切换到最后一次使用的面板 Ctrl+b q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 Ctrl+b { 向前置换当前面板 Ctrl+b } 向后置换当前面板 Ctrl+b Ctrl+o 顺时针旋转当前窗口中的所有面板 Ctrl+b 方向键 移动光标切换面板 Ctrl+b o 选择下一面板 Ctrl+b 空格键 在自带的面板布局中循环切换 Ctrl+b Alt+方向键 以5个单元格为单位调整当前面板边缘 Ctrl+b Ctrl+方向键 以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖） Ctrl+b t 显示时钟前缀 — — — Ctrl+b ? 显示快捷键帮助文档 Ctrl+b d 断开当前会话 Ctrl+b D 选择要断开的会话 Ctrl+b Ctrl+z 挂起当前会话 Ctrl+b r 强制重载当前会话 Ctrl+b s 显示会话列表用于选择并切换 Ctrl+b : 进入命令行模式，此时可直接输入ls等命令 Ctrl+b [ 进入复制模式，按q退出 Ctrl+b ] 粘贴复制模式中复制的文本 Ctrl+b ~ 列出提示信息缓存 表二：窗口（window）指令。 前缀 指令 描述 Ctrl+b c 新建窗口 Ctrl+b \u0026 关闭当前窗口（关闭前需输入y or n确认） Ctrl+b 0~9 切换到指定窗口 Ctrl+b p 切换到上一窗口 Ctrl+b n 切换到下一窗口 Ctrl+b w 打开窗口列表，用于且切换窗口 Ctrl+b , 重命名当前窗口 Ctrl+b . 修改当前窗口编号（适用于窗口重新排序） Ctrl+b f 快速定位到窗口（输入关键字匹配窗口名称） 表三：面板（pane）指令。 前缀 指令 描述 Ctrl+b \" 当前面板上下一分为二，下侧新建面板 Ctrl+b % 当前面板左右一分为二，右侧新建面板 Ctrl+b x 关闭当前面板（关闭前需输入y or n确认） Ctrl+b z 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增） Ctrl+b ! 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） Ctrl+b ; 切换到最后一次使用的面板 Ctrl+b q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 Ctrl+b { 向前置换当前面板 Ctrl+b } 向后置换当前面板 Ctrl+b Ctrl+o 顺时针旋转当前窗口中的所有面板 Ctrl+b 方向键 移动光标切换面板 Ctrl+b o 选择下一面板 Ctrl+b 空格键 在自带的面板布局中循环切换 Ctrl+b Alt+方向键 以5个单元格为单位调整当前面板边缘 Ctrl+b Ctrl+方向键 以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖） Ctrl+b t 显示时钟 ","date":"2019-06-23","objectID":"/posts/2019-tmux/:0:4","series":null,"tags":["Linux"],"title":"终端复用神器Tmux","uri":"/posts/2019-tmux/"},{"categories":["Linux"],"content":"参考 Tmux使用手册 iTerm2 快捷键大全 tmux shortcuts \u0026 cheatsheet tmux cheat sheet ","date":"2019-06-23","objectID":"/posts/2019-tmux/:0:5","series":null,"tags":["Linux"],"title":"终端复用神器Tmux","uri":"/posts/2019-tmux/"},{"categories":["Javascript"],"content":" 最近在项目开发中使用Axios请求，API层使用Node，在GET请求传递数组参数时候遇到了一些问题，这里总结一下。 在开发中经常会使用axios作为请求库，在请求过程中，经常会传递数组作为参数，在实际开发过程中发现，如果在POST请求中，直接传递数组即可，但是在GET请求中，本质上是将参数拼接到url后面，作为参数，即http://xx.xx.com?a=1\u0026b=2这样的形式，如果直接传递数组，则在API层拿到的数据就是一个数组样式的字符串，这并不符合我们的要求。那么，如何传递数组呢？ ","date":"2019-05-18","objectID":"/posts/2019-axiosparams/:0:0","series":null,"tags":["Javascript"],"title":"使用Axios请求时如何传递数组？","uri":"/posts/2019-axiosparams/"},{"categories":["Javascript"],"content":"使用JSON.stringify/parse 既然我们传递的只能是一个字符串，最直接的办法就是先把数组变成字符串，然后在API层再做解析。我们可以在前端使用JSON.stringify将数组变成字符串，传递到API层，然后再用JSON.parse做解析，这样就可以成功的将数组从前端传递到API层。 但是，这样做有一个问题，就是如果我们传递太多的数组，会导致前端传递数据的时候有很多JSON.stringify同样的，在Node这边会有很多的JSON.parse导致代码很不美观，那么如何更优雅的处理呢？ ","date":"2019-05-18","objectID":"/posts/2019-axiosparams/:0:1","series":null,"tags":["Javascript"],"title":"使用Axios请求时如何传递数组？","uri":"/posts/2019-axiosparams/"},{"categories":["Javascript"],"content":"使用qs库和axios的参数处理函数 qs是一个用于解析嵌套字符串的库，使用这个库，可以在前端发出请求前，将参数统一stringify，然后在node层也使用qs将参数进行pase，具体处理方式如下： 首先将参数做统一处理： paramsSerializer: function (params) { return qs.stringify(params, {arrayFormat: 'indices'}) } 然后在API层，引入qs库，直接将整个参数进行qs.parse，即可还原传递过来的参数。 这里需要特别说明一下： qs库对数组的format有以下几种形式： qs.stringify({ids: [1, 2, 3]}, { indices: false }) // 形式： ids=1\u0026ids=2\u0026id=3 qs.stringify({ids: [1, 2, 3]}, {arrayFormat: 'indices'}) // 形式： ids[0]=1\u0026aids1]=2\u0026ids[2]=3 qs.stringify({ids: [1, 2, 3]}, {arrayFormat: 'brackets'}) // 形式：ids[]=1\u0026ids[]=2\u0026ids[]=3 qs.stringify({ids: [1, 2, 3]}, {arrayFormat: 'repeat'}) // 形式： ids=1\u0026ids=2\u0026id=3 使用第一种方式传递数组，如果数组元素不止一个，则在API层不用parse直接就可以拿到数组，但是，如果是数组只有一个元素，则拿到的就是一个字符串，所以，最后的办法就是在前端进行stringify，在API层进行parse。 以上就是大概的一个总结，一个小小的坑，总结一下，后面方便查询 ","date":"2019-05-18","objectID":"/posts/2019-axiosparams/:0:2","series":null,"tags":["Javascript"],"title":"使用Axios请求时如何传递数组？","uri":"/posts/2019-axiosparams/"},{"categories":["React"],"content":" 学习React Hooks简单记录一下官方文档关于Hooks的一些特征和使用方式，摘录自官方文档。后续使用后，再做总结 ","date":"2019-03-24","objectID":"/posts/2019-reacthooks/:0:0","series":null,"tags":["React"],"title":"简述 React Hooks 特征和使用方式","uri":"/posts/2019-reacthooks/"},{"categories":["React"],"content":"Basic React Hooks useState const [data, setData] = useState(initData); useState返回一个数组，数组内第一个元素是state的值，初始值为initState，利用js的结构将该数组解构赋值，如果设置多个state可以多次调用useState，但是useState也可以传入一个数组，数组内的项为多个initState，是否可以声明多个state的时候使用一个useState有待研究，后续看下项目 useEffect 用于写有副作用的代码，可以实现生命周期中的componentDidMount，componentUpdate，componentWillUnmount。 useEffect(() =\u003e { effect code... return () =\u003e { cleanup code } }) useEffect可以添加回调，在effect code执行完成后执行，在useEffect中的代码React每次渲染，都会执行，这也意味着性能的损耗（无论是否真的需要执行，state跟之前是否一样），在class组件中可以使用componentDidUpdate： componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count}times`; } 在hooks中可以使用useEffect的第二个参数 useEffect(() =\u003e { document.title = `You clicked ${count}times`; }, [count]); // Only re-run the effect if count changes 如果使用该优化，确保数组包含了来自组件的所有随着时间会变化的value，但是这样实现的是类似于componentDidUpdate，如果想实现componentDidMount和componentWillUnmount，需要给useEffect第二个参数添加空数组[]，这相当于告诉React当前useEffect中的代码不依赖任何来自state或props的值，所以不需要re-render。 useContext const value = useContext(MyContext); ","date":"2019-03-24","objectID":"/posts/2019-reacthooks/:0:1","series":null,"tags":["React"],"title":"简述 React Hooks 特征和使用方式","uri":"/posts/2019-reacthooks/"},{"categories":["React"],"content":"Additional Hooks useReducer const [state, dispatch] = useReducer(reducer, initialArg, init); 使用demo const initialState = {count: 0}; function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); } } function Counter({initialState}) { const [state, dispatch] = useReducer(reducer, initialState); return ( \u003c\u003e Count: {state.count} \u003cbutton onClick={() =\u003e dispatch({type: 'increment'})}\u003e+\u003c/button\u003e \u003cbutton onClick={() =\u003e dispatch({type: 'decrement'})}\u003e-\u003c/button\u003e \u003c/\u003e ); } React可以确保dispatch函数功能的稳定并且在re-render时候不会改变 懒初始化initState 使用useReducer的第三个参数，demo如下 function init(initialCount) { return {count: initialCount}; } function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; case 'reset': return init(action.payload); default: throw new Error(); } } function Counter({initialCount}) { const [state, dispatch] = useReducer(reducer, initialCount, init); return ( \u003c\u003e Count: {state.count} \u003cbutton onClick={() =\u003e dispatch({type: 'reset', payload: initialCount})}\u003e Reset \u003c/button\u003e \u003cbutton onClick={() =\u003e dispatch({type: 'increment'})}\u003e+\u003c/button\u003e \u003cbutton onClick={() =\u003e dispatch({type: 'decrement'})}\u003e-\u003c/button\u003e \u003c/\u003e ); } useCallback const memoizedCallback = useCallback( () =\u003e { doSomething(a, b); }, [a, b], ); 返回记忆化的回调。 该hooks用于实现类似于shouldComponentUpdate的功能。 用于防止不必要的渲染 useCallback(fn, deps)相当于useMemo(() =\u003e fn, deps) useMemo const memoizedValue = useMemo(() =\u003e computeExpensiveValue(a, b), [a, b]); 返回一个记忆化的值。 在计算机科学中，记忆化（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。 传递“create”函数和依赖项数组。useMemo只会重新计算那些依赖发生变化的记忆化的值。这种优化避免了每次渲染的昂贵计算。 传递给useMemo的函数在渲染期间运行，所以不能传递带有副作用的函数。 如果没有数组提供，在每次渲染都会计算新值。 useRef const refContainer = useRef(initialValue); useRef返回值的.current属性就是给useRef传递个初始value。返回的object将可以在整个生命周期使用。 使用demo function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =\u003e { // `current` points to the mounted text input element inputEl.current.focus(); }; return ( \u003c\u003e \u003cinput ref={inputEl} type=\"text\" /\u003e \u003cbutton onClick={onButtonClick}\u003eFocus the input\u003c/button\u003e \u003c/\u003e ); } useRef在内容变更时不会通知你，.current变化不会导致re-render。 useImperativeHandle useImperativeHandle(ref, createHandle, [deps]) useImperativeHandle自定义使用ref时公开给父组件的实例值，和通常一样，应该避免使用refs的命令式代码，useImperativeHandle应该使用forwardRef。 function FancyInput(props, ref) { const inputRef = useRef(); useImperativeHandle(ref, () =\u003e ({ focus: () =\u003e { inputRef.current.focus(); } })); return \u003cinput ref={inputRef} ... /\u003e; } FancyInput = forwardRef(FancyInput); useLayoutEffect 与useEffect相同，但是是在所有的DOM变化完成后同步触发。在浏览器绘制之前，将在useLayoutEffect内部计划的更新将同步刷新，该方法会组织views的更新，但是useEffect是异步的，所以不会阻止。 ","date":"2019-03-24","objectID":"/posts/2019-reacthooks/:0:2","series":null,"tags":["React"],"title":"简述 React Hooks 特征和使用方式","uri":"/posts/2019-reacthooks/"},{"categories":["React"],"content":" 自 React 16 发步以来 React 一直给大家带来很多令人兴奋的新特性，本文旨在将 React 16 发布以来一些重要的特性以及未来将要实现特性串联起来。 ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:0","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["React"],"content":"React Fiber React Fiber 的的重要特性是增量渲染：将渲染事务（work）分块并分布到多个帧去完成。 React Fiber 是 React 16 的重大更新之一，随着 React 大版本发布，旨在提高 React 的性能。基于 React Fiber，React 可以实现更多的性能上的优化。那么什么是 Fiber ？如何理解 React Fiber？ 想要理解 Fiber，首先要理解几个概念。 协调算法 React 的核心思想是当状态发生变化时让整个应用重新渲染，但是如果每次更新都重新渲染整个 app 会极度的浪费性能，为了将变化及时的反应到 view 层，同时保持高性能，React 使用了经过优化的 diff 算法，这就是协调算法的一部分。 协调算法基于“虚拟 DOM”实现（但是其实这个描述并不准确，因为 DOM 这个概念只是在浏览器中有，所以这里称为“虚拟树”更加准确）,当渲染一个 app 时，首先生成节点树保存在内存中，然后再渲染出来，当 app 更新时，会产生新的树，新旧树对比，找到需要更新的节点将其更新并渲染。 协调器 协调算法将虚拟树的变化找到，渲染器将变化渲染出来，React 的渲染器有 React Dom，React Native 等，其中 React Native 将树渲染到原生 iOS 和 Android 视图，所以 React 协调算法是被渲染器共用的。 为了让不同的渲染器共享他们之间的代码。我们将 React 的这一部分称为“协调者”。当一个更新（例如setState()）被安排，协调器调用在树上组件上的render()，安装，更新，卸载它们。 调度（Scheduling） 调度（Scheduling）——确定什么时候做什么事的过程 事务（work）——必须进行的计算，通常是更新的结果（通常是setState引起的） React v16 之前的协调器（堆栈协调器，参见Codebase Overview——Reconcilers）只是按照顺序执行，但是如果在用户界面中，每个更新都立即执行，会导致掉帧，降低用户体验。事实上不同类型的更新具有不同的优先级，如果能人为的干预执行顺序，按照优先级来进行调度，则性能就可以大大提高。 基于该想法，React 团队开始构思如何控制执行顺序——React Fiber 诞生。 如何理解 Fiber 我们知道，函数有调用栈，当一个函数执行时，栈上面会添加新的堆栈结构，这个堆栈结构代表了函数执行的事务。而 React app 在执行的时候，类似于调用一个函数。 但是在处理该用户界面时，如果有太多的事务同时执行，可能会导致卡顿。可能还有一些事务是不需要的，因为它可能被最近的更新取代了。 在最新的浏览器和 RN 实现了两个 API： requestIdleCallback会在浏览器空闲时一次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而不会对像对象动画和用户交互这样的会延迟触发且关键的事情产生影响。 requestAnimationFrame告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。 这两个函数可以让开发者操纵优先级，但是如果想要使用这些 API，就需要将渲染事务分解为增量单元的方法，如果只是依赖调用栈，调用栈将会一直执行下去，直到空。 假如可以中断调用栈，让 React 在需要更新界面的时候，及时更新界面，那么用户交互将不会再卡顿，这就是 React Fiber 的目的，React Fiber 为 React 组件实现了堆栈结构，让 React 可以在需要的时候，中断调用栈，转向更新界面或者其他，从而保证用户交互的顺畅，提高 React app 的性能。 所以 React Fiber 其实就是 虚拟的堆栈结构（virtual stack frame）。 使用 React Fiber 后 React 的调用情况 React 将更新分为两个时期：render/reconciliation 和 commit render/reconciliation 该阶段是可打断的，React 在 workingProgressTree 上复用 current 上的 Fiber 数据结构来一步步构建新的 tree。 React 16 之前在该阶段执行的生命周期： componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate commit 第二个阶段是 commit 阶段，在该阶段 React 将所有的变更一次性更新到 DOM 上，是不可被打断的。 React 16 之前在该阶段执行的生命周期： componentDidMount componentDidUpdate componentWillUnmount 在commit阶段，React 是可以做异步处理的，因为并不会出现像 DOM 更新这样的副作用，但是在render/reconciliation阶段执行的生命周期开发者可能会将更新 DOM 或者setState的代码放到这些生命周期中，而如果该阶段执行过程被打断，React 并不会从上一次执行中断的地方接着执行，而是会重新开始执行，这样假如 React 进行异步更新，可能会带来意想不到的后果，所以在render/reconciliation阶段的钩子都不应该操作 DOM，也不要去setState，而在 commit 阶段则没有这个限制。 为了强制开发者这样做，React 官方在 React v16.3 发布的时候将生命周期做了更改，而原有的生命周期加了UNSAFE前缀，这些生命周期将在 React v17 中彻底移除，开发者应该尽快切换。 ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:1","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["React"],"content":"React v16.3 新的生命周期 React v16.3 之前，生命周期如下图： 更新 React v16.3 后生命周期的变化 Mount constructor() componentWillMount() render() componentDidMount() Update componentWillReceiveProps() / static getDerivedStateFromProps() shouldComponentUpdate() componentWillUpdate() / getSnapshotBeforeUpdate() render() componentDidUpdate() Unmount componentWillUnmount() 可以看到，生命周期更新后，原先在render/reconciliation的生命周期，除了shouldComponentUpdate，其他都被移除，用新的生命周期替代，前面讲到，在这个阶段，开发者可能会在生命周期中执行带有附作用的代码，从而由于该阶段的被打断而带来意想不到的后果，shouldComponentUpdate因不会有副作用的代码而得到保留 React v16.3 之后生命周期变成了下图这样： React v16.3 到 v16.4，生命周期getDerivedStateFromProps触发的时机有一个变化，这是需要注意的一点。在 v16.3 中，只有父组件setState或者forceUpdate才会触发getDerivedStateFromProps，组件自己setState或者forceUpdate不会触发，很明显，这会造成意想不到的结果，具体可以查看 Fiddle Demo。所以 React 在发布 v16.4 后，修复了这个问题，无论是父组件还是自身，都可以触发getDerivedStateFromProps。关于更详细的描述可以查看 Dan 在 React issue#12898的回答。 所以 React v16.4 的生命周期变成了如下： 新生命周期的使用 static getDerivedStateFromProps() static getDerivedStateFromProps(props, state) 该方法是一个静态方法用以替代componentWillReceiveProps，该方法返回一个新的对象，之后它会帮助开发者setState。由于它是一个静态方法，所以在该方法内拿不到实例，也就是说不能在该方法内调用实例方法或者setState。这样就保证了开发者不会将有副作用的代码写在这个生命周期中。 getDerivedStateFromProps在render方法之前调用，该方法应该返回一个更新 state 的对象或者不更新返回null，使用方式如下： static getDerivedStateFromProps(nextProps, prevState) { if (xxxxx) { return { ...prevState, loading: nextProps.loading, }; } return null; } getSnapshotBeforeUpdate() getSnapshotBeforeUpdate(prevProps, prevState); 该方法在render之后执行，而执行时 DOM 元素还没有被更新，可以有机会获取 DOM 信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。 getSnapshotBeforeUpdate(prevProps, prevState) { if (prevProps.list.length \u003c this.props.list.length) { const list = this.listRef.current; return list.scrollHeight - list.scrollTop; } return null; } componentDidUpdate(prevProps, prevState, snapshot) { if (snapshot !== null) { const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; } } componentDidCatch() componentDidCatch(error, info); 当一个子组件抛出错误时候调用该生命周期，它接受两个参数： error抛出的错误 info是带有componentStackkey 的一个对象，该对象包含哪个组件引发错误的信息 componentDidCatch()在commit阶段被调用，因此是允许包含有副作用的代码的，使用方式如下： class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, info) { logComponentStackToMyService(info.componentStack); } render() { if (this.state.hasError) { return \u003ch1\u003eSomething went wrong.\u003c/h1\u003e; } return this.props.children; } } ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:2","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["React"],"content":"Time Slicing 和 Suspense Time Slicing 和 Suspense 是 Dan 在 JSConf Iceland 2018 为大家展示的未来 React 将加入的一些特性，预计在 React v17 中发布，具体演讲可以查看——Dan Abramov- Beyond React 16 - JSConf Iceland 2018。 这两个特性分别从CPU 和 IO来解决 React 的性能问题。 Time Slicing 前面讲到 React Fiber 让 React 可以在 UI 渲染中更快的响应，但是同时带来了跟踪 UI 变化的挑战，这就是 Time Slicing 的用武之地。 Time Slicing 其实就是异步渲染，试想如果是同步渲染，在性能较差的 CPU 的设备上渲染会慢，用户会明显感知到卡顿。 通过 Time Slicing，React 可以在空闲回调期间将子组件的更新计算查分为块儿，并将渲染分散到多个帧上。这就让 React 可以在性能差的 CPU 设备上依旧保持流畅的渲染。而这一切对开发者而已是透明的。 Suspense 在 Suspense 之前，我们一直用 Redux+Saga 等解决网络 IO 的问题，Suspense 的出现意味着 React 本身将提供该问题的解决问题。 Suspense 将 React 的异步 IO 提升到一个新的高度。有了 Suspense 功能，React 可以暂停任何 state 更新直到数据就绪，这就让 React 可以和 REST APIs 或 GraphQL 等这些异步 IO 运算配合的更好。 Suspense 在 React v16.6 已经发布，可以使用React.lazy()和\u003cReact.Suspense\u003e延迟加载组件，但是在 Fetch 数据的时候还无法使用\u003cReact.Suspense\u003e，原因如下： 事实上想要用 Suspense 实现暂停 state 更新直到数据就绪需要使用一个叫react-cache的库。 react-cache react-cache 目前处于开发阶段，API 很有可能会发生变化，官方不建议将其用于生产环境 react-cache 是一个非常小的库，API 和用法如下： unstable_createResource 创建一个resource，返回一个 promise resource.read(key) resource会检查 key 和 cache 如果 cache 没有数据，会执行以下操作： 调用回调函数获取数据 抛出 promise 当 promise resolves，根据 key 将响应的数据存储在 cache 中 重复该过程 如果 cache 中成功读取到数据 将缓存值同步读取到 render 函数中 function fetchUserProfileJSON(id) { return makeFakeAPICall(`/${id}/details`, userProfileJSON[id]); } const UserDetailsResource = unstable_createResource(fetchUserProfileJSON); const user = UserDetailsResource.read(id); return \u003cdiv\u003e {user} \u003c/div\u003e; Suspense 配合 react-cache 实现暂停 state 更新，直到数据就绪： function fetchUserProfileJSON(id) { return makeFakeAPICall(`/${id}/details`, userProfileJSON[id]); } const UserDetailsResource = unstable_createResource(fetchUserProfileJSON); const user = UserDetailsResource.read(id); return ( \u003cSuspense maxDuration={1000} fallback={\u003cSpinner size=\"medium\" /\u003e}\u003e \u003cdiv\u003e {user} \u003c/div\u003e; \u003c/Suspense\u003e ); 关于更详细的用法可以查看官方提供的 Suspense Demo。 ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:3","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["React"],"content":"React Hooks 在 React Conf 2018 Dan 做了题为React Today and Tomorrow and 90% Cleaner React With Hooks的演讲，介绍了 React 即将发布的又一新特性——React Hooks，目前可以在 React v16.8.0-alpha.0 体验。 什么是 Hooks Hooks 是一种函数，该函数可以“钩住”React 状态和生命周期的功能，允许开发者在不写 class 的情况下使用 React。 基本的 Hooks 有以下几种： State Hooks Effect Hooks 自定义 Hooks State Hook 我们用 React 写一个点击按钮数字自动+1 的组件，如果使用 class，写法如下： class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } render() { return ( \u003cdiv\u003e \u003cp\u003eYou clicked {this.state.count} times\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003e Click me \u003c/button\u003e \u003c/div\u003e ); } } 如果使用 React Hooks，写法如下： import { useState } from \"react\"; function Example() { const [count, setCount] = useState(0); return ( \u003cdiv\u003e \u003cp\u003eYou clicked {count} times\u003c/p\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eClick me\u003c/button\u003e \u003c/div\u003e ); } 这里使用的useState就是一个 Hooks，调用方式如下： const [state, setState] = useState(initialState); 该函数返回一对值：state，更新该 state 的函数；在初始渲染的时候，返回的 state 就是 initialState。 声明多个状态变量 function ExampleWithManyStates() { const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]); Effect Hook Effect Hook 允许在函数组件种执行副作用（PS：副作用一般指执行数据提取，订阅或者手动改变来自 React 组件的 DOM）。它与 React 类中的componentDidMount、componentDidUpdate、和 componentWillUnmount 有相同的功能，但是统一为一个 API。 当调用useEffect时，会通知 React 在刷新对 DOM 的更改后运行 effect 函数。Effect 在组件内声明，因此可以访问其 props 和 state。默认情况下，React 在每次渲染后运行 effect，包括第一次渲染。 默认情况下，React 在每次渲染后运行 effect，包括第一次渲染。 useEffect 还可以通过返回一个函数来指定如何清理，例如，在此组件中实现了通过 effect 订阅，并通过取消订阅来清理。 import { useState, useEffect } from \"react\"; function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() =\u003e { ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =\u003e { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return \"Loading...\"; } return isOnline ? \"Online\" : \"Offline\"; } 自定义 Hooks 自定义 Hook 允许将可重用的组件逻辑提取到函数中。 前面使用useEffect实现了订阅和取消订阅，如果想将该逻辑重用，可以将props换成参数，从而实现组件逻辑的复用，调用非常方便，直接传递参数即可： // 自定义Hook import { useState, useEffect } from \"react\"; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() =\u003e { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =\u003e { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } // 调用 function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return \"Loading...\"; } return isOnline ? \"Online\" : \"Offline\"; } 为什么引入 Hooks 为什么要在 React 中引入 Hooks，React 官方给出了以下描述： Hooks 解决了 React 中各种看似不相关的问题，这些问题是我们在开发和维护数以万计的组件时遇到的。无论你是在学习 React，还是每天在使用它，还是选择使用具有类似组件模型的其他库，你都可能会发现这类问题。 ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:4","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["React"],"content":"总结 以上总结了自 React v16.0 发布以来，React 给开发者带来的一些令人惊叹的新的特性，可以看到 React 已经开始慢慢走向一个大而全的框架，而不是像以前那样仅仅只是做 view 层，剩下的交给社区自由发展。相信在不远的未来，React 将更加的好用，性能更高。 ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:5","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["React"],"content":"参考 React Fiber 是什么 React Fiber 架构 「译」React Fiber 那些事: 深入解析新的协调算法 React v16.3 之后的组件生命周期函数 「译」 如何使用 React 生命周期方法 如何评价 React 的新功能 Time Slice 和 Suspense？ Time slice and Suspense API – What’s coming in React 17? react-cache React Change log React Hooks ","date":"2019-01-16","objectID":"/posts/2019-reactnews/:0:6","series":null,"tags":["React"],"title":"React 新特性总结","uri":"/posts/2019-reactnews/"},{"categories":["年终总结"],"content":" 好久没写博客了，不知不觉的，就又到年底了，2018年已经过去，2019已经到来，回望2018这一年，自己又有了新的成长，新的变化，在去年写的一些计划中，自己也实践了一部分并且有所收获，还是非常开心的。这一年总体来说有这么几件大事儿吧，换了一份工作，换了一个身份，开始新的实践，有了新的认知。 ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:0","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["年终总结"],"content":"工作 关于工作，比较大的应该就是这么几件事儿吧： 经历了一段时间非常辛苦的封闭开发 第一次经历上市，知道了上市是怎么回事儿 曾经的团队分崩离析 年底离开小米，来到传说中的宇宙条 参与封闭开发 2018年春节前，接到领导的指派，让我和另一个同事一起参与一个项目，这是一个领导非常重视的项目，我和另一个同事搬工位去另一个办公地，开始了为期两周多的封闭开发，在这段时间内，我们这个项目组，几乎每天都是四五点回家，第二天十一点多来接着上班，周六日也不休息，那两周多我觉得将会是我从事这个行业最辛苦的两周了，十六天后我们做的这个项目上线了，上线那天，我们干到了凌晨6点才回家。因为每天干的非常晚，大家都很累，所以项目后期，我们这边增加了人员来支援这个项目，后端那边也在不断的增加人手，以保证项目如期上线… 现在回想起来，真的不知道该怎么评价当时的自己，当时也没想太多，就是为了做好项目，然后上线，真的是非常单纯。 公司上市 2018年年初的时候，说实话我想过就走，但是想到公司要在7月份上市，而且我觉得能赶上公司上市还是挺幸运的，毕竟一个公司要上市至少要经历七八年吧，所以就没有走留下来了，等着公司的上市（其实我觉得真正的原因还是自己不太想变动，想稳定，还是想待着，记得第一次跳槽的时候也是这样）。七月份的时候公司上市，非常开心能参与公司的上市，也看到了上市是做什么，公司在那天有庆祝活动，还有抽奖活动，不过我运气一向差，所以并没有中任何奖，而且本身我自己也没有期权，所以其实上市跟我关系不太大，只是参与而已… 不过因为公司上市，公司发了一个纪念品，一个铜做的米兔，这个还是很不错的，至少将来拿出来，也可以说明我曾经在小米待过（也就仅此而已）。 心目中的团队——从辉煌到没落 2016年9月底，我跳槽到小米，那一年刚好我们组新成立，我是那一年最后一个入职的。之后17年也陆陆续续来了很多人，团队从原先的十几个人扩展到三十多个，我们那一批可以算是最早的一批了吧。在小米感觉团队还是非常赞的，大家一起同甘共苦，一心只是想做好自己的事儿，没有什么其他的杂念，队友之间也相互信任。 但是2018年年初开始，团队就开始有人离职了，到公司上市的时候，我们那一批基本走了一半多了吧，其实走的原因非常简单，没钱，只有饼，领导各种画饼…没有任何兑现，经历了这次也让我学到了很多，古人云：“见贤思齐焉，见不贤而内自省也”大概就是这个道理了。 说实话，看着自己昔日的队友一个个离开，自己心里也不好受，我不明白为什么领导不努力留下他们而是任其自由，我记得在开周会的时候，领导跟我们说，以前的领导问他“你觉得这个团队离开谁不行？”，说实话听到这个我还是挺震惊的，如此优秀的团队，居然就这么随意，在我看来就是把一副好牌硬生生的打臭了…在随后的日子里，我也开始不再那么努力去干了，真的是寒心，曾经大家那么拼命，不问目的，换来的就是你们爱咋咋，这个有点儿接受不了了。所以在公司上市后，我开始准备面试，我也准备走了，觉得没什么意思，团队里帮派林立，阿谀奉承，这个团队早已不是我熟悉的团队，我也不再适合这里了（事实上我也是2016入职的那一批人最后一个离开，最后一个入职，最后一个离职，也算是给我们这批人画上一个圆满的句号把）。 对了，在我快走的时候，也发生了一件小插曲，现在想想都觉得好笑，那时候我准备走了，然后我这边的这个业务负责人开周会的时候，居然当着我的面指桑骂槐的说年轻人应该把工作当作事业而不是只在乎钱，要学习他，好好工作而不是为了钱，我听了这话真的是感觉这个团队早已不是我认识的那个前端团队。 回想起曾经为了项目完成一起加班到两三点，彼此相互信任，没有任何猜疑，算计，真的感觉非常开心，感觉在小米最开心的事儿就是认识了这群队友。 离开小米到头条 2018年下半年最重要的事情之一了吧，离开小米，来到宇宙条，新的团队，新的环境，一切从头开始，来到头条给我的感觉是各种豪气，电脑是新的，显示器是新的，吃饭是自助，各种福利，但是唯一不太好的地方是下班晚，基本上九点多十点点下班，不过上班也晚，所以还行，就是感觉比较忙，同事领导也很nice，期待在2019年在头条可以作出一番成绩。 ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:1","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["年终总结"],"content":"技术 回想起来，2018年主要成就、认识有以下几点吧： react项目搭建，并将一些心得进行总结，文章链接 从零开始搭建React应用（一）——基础搭建 从零开始搭建React应用（二）——React应用架构 react相关的原理、源码零零散散的学习了一些 因为面试，开始复习基础，学习到了一些基础相关的东西 GitHub的代码提交次数相对较多，也给公共库贡献了一些自己的东西 翻译了几篇文章，其中有一篇关于ES2018的译文比较火，被奇舞团，掘金等转发（本来前端早读也要转发的，但是他给我发的微博私信，我并没有看到，就这么完美的错过了） 文章题目：译 ES2018（ES9）的新特性。 意识到算法的重要性 有意识的使用vim和tmux 总体来说感觉2018年开始深入研究一些东西，也开始参与到了开源中，但是相对来说并没有系统的去研究某个东西并将其整理成册。开源项目虽然有参与，但是参与的只是一些相对简单的东西，并没有贡献自己写的代码逻辑。相比于2017年，2018年自己写文章的次数都少了，感觉在这一点上有所退步了，不过在技术方面，2018年基本涉及了2017年的计划，也还是不错的，希望在2019年开源深入，开源贡献一些自己的逻辑，深入，系统的研究react，并将其总结成册。 ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:2","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["年终总结"],"content":"入市 记得2017年年底的时候，虚拟货币大涨，各种造富神话开始出现，大家疯狂的涌入虚拟货币市场，开始炒币，这让我第一次感受到了贪婪的可怕，也是从那时候起，开始对金融感兴趣，2017年年底总结的时候也写到期望在2018年开始学习金融，开始学习投资。 2018年我怀着极大的好奇心，我开始参与到这个市场中，开始定投基金，到年底的时候开始投资股票，学习金融等等…这是我2018年变化比较大的一点。 可惜的是2018年一整年股市是彻头彻尾的熊市，从年初开始定投基金，到公司上市买入港股美股，再到年底买入A股，无疑不在亏钱，2018年对投资的朋友们来说可以说是心痛的一年，上证，沪深指数各种跌，大家都开玩笑说，2018年不投资就是赚，哈哈。 对于我个人来说，刚开始投资就遇到熊市，这运气也是绝佳了，不过话说回来了，不跌下来，怎么会有上涨的空间呢？我相信冬天来了，春天就一定不会很远。我相信2019年将是非常重要的资产规划的一年，一定要做好资产配置，我相信… ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:3","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["年终总结"],"content":"新的认知 相比于以前，我觉得我在2018年认知变化还是挺大的，新的认知有以下两点： 钱可以生钱 手里拿着锤子，看什么都是钉子 要多读书 其实在2017年的年底的时候，就开始有投资理财的意识，但是还没有付诸行动，从2018年开始，自己也慢慢的开始学着理财，定投基金，买一些定期，到下半年开始慢慢投资股票，但是因为赶上今年整个行情不好，所以导致投资其实是赔钱的，在此期间也看过一些书，越来越坚信一个道理——钱不是攒出来的，钱是理出来的，所以，在2019年，我将继续投资，重点应该是在股票方面。 另一个更重要的认知升级——要跨学科学习，从多个角度认识世界 其实在此之前，自己就也曾经有想法学习一些其他学科的知识，但是因为代码也需要学习很多东西，而且自己本身从事这个工作，所以以学习代码为主。后来看了《穷查理宝典》，才意识到这种做法的不正确，书中反复强调一句谚语——手里拿着锤子的人，看什么都像钉子，这句话说明了我们只学一门专业所带来的局限性，书中讲到，这个世界本身就是复杂的，要用多个角度才能更准确的看到问题的本质，要学习各个学科的基础知识。所以2019年，除了要学习代码相关只是外，还要学习其他知识，从而让自己更准确的看待问题。 ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:4","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["年终总结"],"content":"2019愿望清单 2018年已经过去，新的一年已经来临，在新的一年里，列一些想要做的事儿，希望在新的一年里逐一实现。 学习 多读书：2018年读了七本书，2019年一定要读更多的书，而且要有计划的去读 学习其他学科的知识：2018年已经开始学习《金融学》，但是并没有连续的有计划的进行，2019年一定要有计划的学习其他学科的知识 Code javascript基础学习，将《javaScript权威指南》看完 学习React源码，原理相关的东西并总结成册：2018年已经开始涉及，但是还是零零散散的一些东西，希望在2019年可以系统的有规律的学习并整理React原理相关的一些东西 学习node 学习python，了解后端相关的东西 学习Linux相关的知识 更加熟练的使用vim 生活方面 跟女朋友一起去参加电音节，这个必须列在头一条，因为这个在2017年的时候，就已经想做了，如今都2019年了，一定要实现 减肥啊，又胖了，哎…争取2019年减肥成功 目前能想到的就这些了，当然后续可能还会增加… ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:5","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["年终总结"],"content":"总结 总的来说2018年在代码方面其实并没有太多的成就，但是收获最大的还是提升了一些认知，我觉得还是很重要的，对了最后还有一点最最重要的关于我自己个人的事情，带着女朋友回家了，非常开心。2018年就这样过去了，2019继续努力… ","date":"2019-01-07","objectID":"/posts/2018-2019newyear/:0:6","series":null,"tags":["年终总结"],"title":"再见2018，你好2019","uri":"/posts/2018-2019newyear/"},{"categories":["React"],"content":" 原文链接：How to use React Lifecycle Methods ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:0:0","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"React 生命周期 大体上分三类 Mount Update Unmount ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:1:0","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"Mount constructor() componentWillMount() render() componentDidMount() ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:1:1","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"Update componentWillReceiveProps() / static getDerivedStateFromProps() shouldComponentUpdate() componentWillUpdate() / getSnapshotBeforeUpdate() render() componentDidUpdate() ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:1:2","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"Unmount componentWillUnmount() ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:1:3","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"生命周期方法 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:0","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"componentWillMount（即将移除） componentWillMount() 当 React 渲染一个组件的是你，首先进入该方法。 Note：componentWillMount()是唯一一个在render()之前调用的生命周期方法。因此是在服务端渲染中唯一被调用的方法。 因为componentWillMount()将被删除，所以官方推荐使用constructor()替代该方法 **Update：**该方法应该在新的代码中避免使用 State 可以在该方法中使用this.setState()但是不一定触发重新渲染。 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:1","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"componentDidMount componentDidMount() 当该方法被调用时候，React 已经渲染了组件并且将组件插入 DOM。因此如有有任何依赖于 DOM 的初始化，应该放在这里。 State 该方法中可以使用this.setState()方法，它将触发重新渲染。 Use Cases fetch data 依赖 DOM 初始化 添加事件监听 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:2","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"componentWillReceiveProps（即将移除） componentWillReceiveProps(nextProps) 当组件接收到新的props，该方法会首先被调用，但是需要注意一点，即使props并没有发生改变，该方法也会被调用，所以使用该方法的时候要确保比较this.props和nextProps，避免不必要的渲染。 Update：componentWillReceiveProps将被移除，使用新的static getDerivedStateFromProps代替。 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:3","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"static getDerivedStateFromProps（新增） static getDerivedStateFromProps(props, state) 每次render都会调用该方法——即使props没有发生变化。所以要谨慎使用。 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:4","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"shouldComponentUpdate shouldComponentUpdate(nextState, nextProps) 有些时候需要避免不必要的渲染，可以使用该方法。返回false意味着 React 不执行componentWillUpdate()，render()，componentDidUpdate()。 该方法在初始化时候不执行。 **Note：**根据 React 文档，React 可能将shouldComponentUpdate视做提示而不是严格的根据它的返回结果决定是否执行，也就是说可能出现shouldComponentUpdate返回false，但是还是发生重新渲染。 State 在该方法中不可以设置setState。 Use Case 如前所述，该方法可能有有问题。React 官方提供了另一个解决办法，所以如果发现某个组件慢，可以使用React.PureComponent替代React.component，它将对props和state提供一个浅层对照。 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:5","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"componentWillUpdate（即将移除） componentWillUpdate(nextProps, nextState) 该方法在被渲染前调用。shouldComponentUpdate在新的props进入组件或者state改变的时候调用。 该方法在初始渲染时候不被调用。 Update：shouldComponentUpdate即将被移除。 State 在该方法中不能调用setState。 Use Cases shouldComponentUpdate方法在render()前会被准确调用，所以在该方法中做任何跟 DOM 相关的操作是不合适的，因为很快会过期。 常见的用例有： 根据state的变化设置变量 派发事件 开始动画 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:6","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"getSnapshotBeforeUpdate getSnapshotBeforeUpdate(prevProps, prevState) 该方法在 React 16.3 被添加并且它配合componentDidUpdate。该方法应该覆盖了旧方法shouldComponentUpdate的所有用例。 getSnapshotBeforeUpdate在元素被渲染并写入 DOM 之前调用，这样，你在 DOM 更新前捕获 DOM 信息（例如：滚动位置）。 应该返回一个snapshot值或null，无论返回什么，shouldComponentUpdate都可以接收到snapshot参数。 Use Cases 如果想要获得一个 list 或者一个聊天窗口中的滚动位置，可以在getSnapshotBeforeUpdate中取到这些信息。然后将滚动信息作为snapshot值返回。这允许在shouldComponentUpdate中是设置正确的滚动位置在 DOM 更新后。 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:7","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"componentDidUpdate componentDidUpdate(prevProps, prevState, snapshot) React 更新组件后，调用componentDidUpdate。该方法在初始渲染时候不会被调用。 Use Cases 如果组件更新后需要操作 DOM，可以使用该方法。 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:8","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"componentWillUnmount componentWillUnmount() 在卸载，销毁组件之前调用该方法。 State 在卸载组件时候不能设置 State Use Cases 使用该方法清理 actions。 删除在componentDidMount或其他地方添加的事件监听 断开网络请求 清空计时器 清理在componentDidMount中创建的 DOM 元素 ","date":"2018-07-28","objectID":"/posts/2018-reactlifecycle/:2:9","series":null,"tags":["React"],"title":"「译」如何使用React生命周期方法","uri":"/posts/2018-reactlifecycle/"},{"categories":["React"],"content":"上一篇文章——从零开始搭建 React 应用（一）——基础搭建讲述了如何使用 webpack 搭建一个非常基础的 react 开发环境。本文将详细讲述搭建一个 React 应用的架构。 仓库地址：https://github.com/MrZhang123/Web_Project_Build/tree/master/react-webpack ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:0:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"redux 在我们开发过程中，很多时候，我们需要让组件共享某些数据，虽然可以通过组件传递数据实现数据共享，但是如果组件之间不是父子关系的话，数据传递是非常麻烦的，而且容易让代码的可读性降低，这时候我们就需要一个 state（状态）管理工具。常见的状态管理工具有 redux，mobx，这里选择 redux 进行状态管理。值得注意的是 React 16.3 带来了全新的Context API，我们也可以使用新的 Context API 做状态管理。 Redux 是 JavaScript 状态容器，提供可预测化的状态管理。可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供非常好的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 redux 的数据流如下图所示： redux 的三大原则： 整个应用的state都被存储在一颗 object tree 中，并且这个 object tree 只存在于唯一的 store 中，但是这并不意味使用 redux 就需要将所有的 state 存到 redux 上。 state 是只读的，唯一改变 state 的方式是出发action，action是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改，为了描述 action 如何改变 state tree，需要编写 reducers。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:1:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"中间件（Redux middleware） Redux middleware 提供位于 action 发起之后，到达 reducer 之前的扩展点。dispatch 发起的 action 依次经过中间件，最终到达 reducer。我们可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。本质上来讲中间件只是拓展了 store.dispatch 方法。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:1:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"增强器（Store enhancer） store enhancer 用于增强 store 的功能，一个 store enhancer 实际上就是一个高阶函数，返回一个新的强化过的 store creator。 const logEnhancer = createStore =\u003e (reducer, initialState, enhancer) =\u003e { const store = createStore(reducer, initialState, enhancer) function dispatch(action) { console.log(`dispatch an action: ${JSON.stringify(action)}`) const res = store.dispatch(action) const newState = store.getState() console.log(`current state: ${JSON.stringify(newState)}`) return res } return { ...store, dispatch } } 可以看到logEnhancer改变了 store 的默认行为，在每次dispatch前后，都会输出日志。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:1:2","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"react-redux redux 本身是一个状态 JS 的状态库，可以结合 react，vue，angular 甚至是原生 JS 应用使用，为了让 redux 帮我们管理 react 应用的状态，需要把 redux 与 react 连接，官方提供了react-redux库。 react-redux 提供Provider组件通过 context 的方式向应用注入 store，然后组件使用connect高阶方法获取并监听 store，然后根据 store state 和组件自身的 props 计算得到新的 props，注入该组件，并且可以通过监听 store，比较计算出的新 props 判断是否需要更新组件。 render( \u003cProvider store={store}\u003e \u003cConnectedRouter history={history}\u003e \u003cApp /\u003e \u003c/ConnectedRouter\u003e \u003c/Provider\u003e, document.getElementById('app') ) ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:1:3","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"整合 redux 到 react 应用 合并 reducer 在一个 react 应用中只有一个 store，组件通过调用 action 函数，传递数据到 reducer，reducer 根据数据更改对应的 state。但是随着应用复杂度的提升，reducer 也会变得越来越大，此时可以考虑将 reducer 拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分。 redux 提供combineReducers辅助函数，将分散的 reducer 合并成一个最终的 reducer 函数，然后在 createStore 的时候使用。 整合 middleware 有时候我们需要多个 middleware 组合在一起形成 middleware 链来增强store.dispatch，在创建 store 时候，我们需要将 middleware 链整合到 store 中，官方提供applyMiddleware(...middleware)将 middleware 链在一起。 整合 store enhancer store enhancer 用于增强 store，如果我们有多个 store enhancer 时需要将多个 store enhancer 整合，这时候就会用到compose(...functions)。 使用compose合并多个函数，每个函数都接受一个参数，它的返回值将作为一个参数提供给它左边的函数以此类推，最右边的函数可以接受多个参数。compose(funA,funB,funC)可以理解为compose(funA(funB(funC())))，最终返回从右到左姐收到的函数合并后的最终函数。 创建 Store redux 通过createStore创建一个 Redux store 来以存放应用中所有的 state，createStore的参数形式如下： createStore(reducer, [preloadedState], enhancer) 所以我们创建 store 的代码如下： import thunk from 'redux-thunk' import { createStore, applyMiddleware } from 'redux' import reducers from '../reducers' const initialState = {} const store = createStore(reducers, initialState, applyMiddleware(thunk)) export default store 之后将创建的 store 通过Provider组件注入 react 应用即可将 redux 与 react 应用整合在一起。 注：应用中应有且仅有一个 store。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:1:4","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"React Router React Router 是完整的 React 的路由解决方案，它保持 UI 与 URL 的同步。项目中我们整合最新版的 React Router v4。 在 react-router v4 中 react-router 被划分为三个包：react-router，react-router-dom 和 react-router-native，区别如下： react-router：提供核心路由组件和函数 react-router-dom：供浏览器使用的 react router react-router-native：供 react native 使用的 react router ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:2:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"redux 与 react router React Router 与 Redux 一起使用时大部分情况下都是正常的，但是偶尔会出现路由更新但是子路由或活动导航链接没有更新。这个情况发生在： 组件通过connect()(Comp)连接 redux。 组件不是一个“路由组件”，即组件并没有像\u003cRoute component={SomeConnectedThing} /\u003e这样渲染。 这个问题的原因是 Redux 实现了shouldComponentUpdate，当路由变化时，该组件并没有接收到 props 更新。 解决这个问题的方法很简单，找到connect并且将它用withRouter包裹： // before export default connect(mapStateToProps)(Something) // after import { withRouter } from 'react-router-dom' export default withRouter(connect(mapStateToProps)(Something)) ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:2:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"将 redux 与 react-router 深度整合 有时候我们可能希望将 redux 与 react router 进行更深度的整合，实现： 将 router 的数据与 store 同步，并且从 store 访问 通过 dispatch actions 导航 在 redux devtools 中支持路由改变的时间旅行调试 这些可以通过 connected-react-router 和 history 两个库将 react-router 与 redux 进行深度整合实现。 官方文档中提到的是 react-router-redux，并且它已经被整合到了 react-router v4 中，但是根据 react-router-redux 的文档，该仓库不再维护，推荐使用 connected-react-router。 首先安装 connected-react-router 和 history 两个库： $ npm install --save connected-react-router $ npm install --save history 然后给 store 添加如下配置： 创建history对象，因为我们的应用是浏览器端，所以使用createBrowserHistory创建 使用connectRouter包裹 root reducer 并且提供我们创建的history对象，获得新的 root reducer 使用routerMiddleware(history)实现使用 dispatch history actions，这样就可以使用push('/path/to/somewhere')去改变路由（这里的 push 是来自 connected-react-router 的） import thunk from 'redux-thunk' import { createBrowserHistory } from 'history' import { createStore, applyMiddleware } from 'redux' import { connectRouter, routerMiddleware } from 'connected-react-router' import reducers from '../reducers' export const history = createBrowserHistory() const initialState = {} const store = createStore( connectRouter(history)(reducers), initialState, applyMiddleware(thunk, routerMiddleware(history)) ) export default store 在根组件中，我们添加如下配置： 使用ConnectedRouter包裹路由，并且将 store 中创建的history对象引入，作为 props 传入应用 ConnectedRouter组件要作为Provider的子组件 import React from 'react' import { render } from 'react-dom' import { Provider } from 'react-redux' import { ConnectedRouter } from 'connected-react-router' import App from './App' import store from './redux/store' import { history } from './redux/store' render( \u003cProvider store={store}\u003e \u003cConnectedRouter history={history}\u003e \u003cApp /\u003e \u003c/ConnectedRouter\u003e \u003c/Provider\u003e, document.getElementById('app') ) 这样我们就将 redux 与 react-router 整合完毕。 使用dispatch切换路由 完成以上配置后，就可以使用dispatch切换路由了： import { push } from 'react-router-redux' // Now you can dispatch navigation actions from anywhere! store.dispatch(push('/about')) ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:2:2","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"react-router-config react-router v4 之前——静态路由 在 react-router v4 之前的版本中，我们可以直接使用静态路由来配置应用程序的路由，它允许在渲染之前对路由进行检查和匹配。 在 router.js 中一般会有这样的代码： const routes = ( \u003cRouter\u003e \u003cRoute path=\"/\" component={App}\u003e \u003cRoute path=\"about\" component={About} /\u003e \u003cRoute path=\"users\" component={Users}\u003e \u003cRoute path=\"/user/:userId\" component={User} /\u003e \u003c/Route\u003e \u003cRoute path=\"*\" component={NoMatch} /\u003e \u003c/Route\u003e \u003c/Router\u003e ) export default routes 然后在初始化的时候把路由导入，然后渲染： import ReactDOM from 'react-dom' import routes from './config/routes' ReactDOM.render(routes, document.getElementById('app')) react-router v4——动态路由 从 v4 版本开始，react-router 使用动态组件代替路径配置，即 react-router 就是 react 应用的一个普通组件，随用随写，不必像之前那样，路由跟组件分离。因此 react 应用添加 react-router，首先引入我们需要的东西。 import React from 'react' import { BrowserRouter as Router, Route, Link } from 'react-router-dom' 这里我们将BrowserRouter引入并重新命名为Router，BrowserRouter允许 react-router 将应用的路由信息通过context传递给任何需要的组件。因此要让 react-router 正常工作，需要在应用程序的根结点中渲染BrowserRouter。 import React from 'react' import { BrowserRouter as Router, Route, Link } from 'react-router-dom' class App extends Component { render() { return ( \u003cRouter\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cLink to=\"/\"\u003eHome\u003c/Link\u003e \u003c/div\u003e \u003chr /\u003e \u003cRoute exact path=\"/\" component={Home} /\u003e \u003c/div\u003e \u003c/Router\u003e ) } } 以还使用了Route，当应用程序的 location 匹配到某个路由时，Route将渲染制定的 component，否则渲染null。 想要加入更多的路由，添加Route组件即可，但是这样的写法也许我们会感觉到有点儿乱，因为毕竟路由被分散到组件各处，很难像以前那样很容易的看到整个应用的路由，而且如果项目之前是用的 react-router v4 之前的版本，那么升级 v4 也是成本很大的，官方为解决该问题，提供了专门用来处理静态路由配置的库——react-router-config。 添加 react-router-config 实现使用静态路由 添加了 react-router-config 之后，我们就可以写我们熟悉的静态路由了。同时，利用它，可以将路由配置分散在各个组件中，最后使用renderRoutes将分散的路由片段在根组件合并，渲染即可。 配置静态路由： import Home from './views/Home' import About from './views/About' const routes = [ { path: '/', exact: true, component: Home }, { path: '/about', component: About } ] export default routes 然后在根组件中合并，渲染： import { renderRoutes } from 'react-router-config' import HomeRoute from './views/Home/router' import AboutRoute from './views/About/router' // 合并路由 const routes = [...HomeRoute, ...AboutRoute] class App extends Component { render() { return ( \u003cRouter\u003e \u003cdiv className=\"screen\"\u003e{renderRoutes(routes)}\u003c/div\u003e \u003c/Router\u003e ) } } renderRoutes其实帮我们做了类似的事儿： const routes = ( \u003cRouter\u003e \u003cRoute path=\"/\" component={App}\u003e \u003cRoute path=\"about\" component={About} /\u003e \u003cRoute path=\"users\" component={Users}\u003e \u003cRoute path=\"/user/:userId\" component={User} /\u003e \u003c/Route\u003e \u003cRoute path=\"*\" component={NoMatch} /\u003e \u003c/Route\u003e \u003c/Router\u003e ) 这样就给 React 应用添加了静态路由。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:2:3","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"添加模块热替换(Hot Module Replacement) 模块热替换（HMR）功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要通过以下几种方式： 保留在完全重新加载页面时丢失的应用状态 只更新变更的内容以节省开发时间 更改样式不需要刷新页面 在开发模式中，HMR 可以替代 LiveReload，webpack-dev-server 支持hot模式，在试图重新加载整个页面之前，hot模式尝试使用 HMR 来更新。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:3:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"启用 HMR 在 webpack 配置文件中添加 HMR 插件： plugins: [new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin()] 这里添加的NamedModulesPlugin插件， 设置 webpack-dev-server 开启hot模式： const server = new WebpackDevServer(compiler, { + hot: true, // noInfo: true, quiet: true, historyApiFallback: true, filename: config.output.filename, publicPath: config.output.publicPath, stats: { colors: true } }); 这样，当修改 react 代码的时候，页面会自动刷新，修改 css 文件，页面不刷新，直接呈现样式。 但是会发现一个问题，页面的自动刷新会导致我们 react 组件的状态丢失，那么能否做到更改 react 组件像更改 css 文件那样，页面不刷新（保存页面的状态），直接替换呢？答案是肯定的，可以使用 react-hot-loader。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:3:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"添加 react-hot-loader 添加 react-hot-loader 非常简单，只需要在根组件导出的时候添加高阶方法hot即可： import { hot } from \"react-hot-loader\"; class App extends Component { ... } export default hot(module)(App); 这样，整个应用在开发时候就可以修改 react 组件而保持状态了。 注： 在开发过程中，查阅了一些文章说，为了配合 redux，需要在 store.js 中添加如下代码： if (process.env.NODE_ENV === 'development') { if (module.hot) { module.hot.accept('../reducers/index.js', () =\u003e { // const nextReducer = combineReducers(require('../reducers')) // store.replaceReducer(nextReducer) store.replaceReducer(require('../reducers/index.js').default) }) } } 但是，在 react-hot-loader v4 中，是不需要的，直接添加hot就可以了。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:3:2","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"异步加载组件（Code Splitting） 完成以上配置后，我们的主体已经搭建的差不多了，但是当打开开发者工具会发现，应用开始加载的时候直接把整个应用的 JS 全部加载进来，但是我们期望进入哪个页面加载哪个页面的代码，那么如何实现应用的 Code Splitting 呢？ 其实实现 React Code Splitting 的库有很多，例如： Loadable Components Imported Component React Universal Component React-Loadable 选用其中之一即可，我项目中选用的是 react-loadable。 之前我们已经在项目中配置了静态路由，组件是直接引入的，我们只需要对之前的直接引入的组件做处理就可以，代码如下： import loadable from 'react-loadable' import Loading from '../../components/Loading' export const Home = loadable({ loader: () =\u003e import('./Home'), loading: Loading }) export const About = loadable({ loader: () =\u003e import('./About'), loading: Loading }) const routes = [ { path: '/', exact: true, component: Home }, { path: '/about', component: About } ] export default routes ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:4:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"异步任务流管理 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:5:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"实现异步操作的思路 大部分情况下我们的应用中都是同步操作，即 dispatch action 时，state 会被立即更新，但是有些时候我们需要做异步操作。同步操作只要发出一种 Action 即可，但是异步操作需要发出三种 Acion。 操作发起时的 Action 操作成功时的 Action 操作失败时的 Action 为了区分这三种 action，可能在 action 里添加一个专门的status字段作为标记位： { type: 'FETCH_POSTS' } { type: 'FETCH_POSTS', status: 'error', error: 'Oops' } { type: 'FETCH_POSTS', status: 'success', response: { ... } } 或者为它们定义不同的 type： { type: 'FETCH_POSTS_REQUEST' } { type: 'FETCH_POSTS_FAILURE', error: 'Oops' } { type: 'FETCH_POSTS_SUCCESS', response: { ... } } 所以想要实现异步操作需要做到： 操作开始时，发出一个 Action，触发 State 更新为“正在操作”，View 重新渲染 操作结束后，再发出一个 Action，触发 State 更新为“操作结束”，View 再次重新渲染 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:5:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"redux-thunk 异步操作至少送出两个 Action，第一个 Action 跟同步操作一样，直接送出即可，那么如何送出第二个 Action 呢？ 我们可以在送出第一个 Action 的时候送一个 Action Creator 函数，这样第二个 Action 可以在异步执行完成后自动送出。 componentDidMount() { store.dispatch(fetchPosts()) } 在组件加载成功后，送出一个 Action 用来请求数据，这里的fetchPosts就是 Action Creator。fetchPosts 代码如下： export const SET_DEMO_DATA = createActionSet('SET_DEMO_DATA') export const fetchPosts = () =\u003e async (dispatch, getState) =\u003e { store.dispatch({ type: SET_DEMO_DATA.PENDING }) await axios .get('https://jsonplaceholder.typicode.com/users') .then(response =\u003e store.dispatch({ type: SET_DEMO_DATA.SUCCESS, payload: response })) .catch(err =\u003e store.dispatch({ type: SET_DEMO_DATA.ERROR, payload: err })) } fetchPosts是一个 Action Creator，执行返回一个函数，该函数执行时dispatch一个 action，表明马上要进行异步操作；异步执行完成后，根据请求结果的不同，分别dispatch不同的 action 将异步操作的结果返回回来。 这里需要说明几点： fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。 返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。 在返回的函数之中，先发出一个 store.dispatch({type: SET_DEMO_DATA.PENDING})，表示异步操作开始。 异步操作结束之后，再发出一个 store.dispatch({ type: SET_DEMO_DATA.SUCCESS, payload: response })，表示操作结束。 但是有一个问题，store.dispatch正常情况下，只能发送对象，而我们要发送函数，为了让store.dispatch可以发送函数，我们使用中间件——redux-thunk。 引入 redux-thunk 很简单，只需要在创建 store 的时候使用applyMiddleware(thunk)引入即可。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:5:2","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"开发调试工具 开发过程中免不了调试，常用的调试工具有很多，例如 redux-devtools-extension，redux-devtools，storybook 等。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:6:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"redux-devtools-extension redux-devtools-extension 是一款调试 redux 的工具，用来监测 action 非常方便。 首先根据浏览器在Chrome Web Store或者Mozilla Add-ons中下载该插件。 然后在创建 store 时候，将其加入到 store enhancer 配置中即可： import thunk from \"redux-thunk\"; import { createBrowserHistory } from \"history\"; import { createStore, applyMiddleware } from \"redux\"; + import { composeWithDevTools } from \"redux-devtools-extension/logOnlyInProduction\"; import { connectRouter, routerMiddleware } from \"connected-react-router\"; import reducers from \"../reducers\"; export const history = createBrowserHistory(); const initialState = {}; + const composeEnhancers = composeWithDevTools({ + // options like actionSanitizer, stateSanitizer + }); const store = createStore( connectRouter(history)(reducers), initialState, + composeEnhancers(applyMiddleware(thunk, routerMiddleware(history))) ); ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:6:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"写在最后 本文梳理了自己对 React 应用架构的认识以及相关库的具体配置，进一步加深了对 React 应用架构的理解，但是像数据 Immutable ，持久化，webpack 优化等这些，本文并未涉及，未来会继续研究相关的东西，力求搭建更加完善的 React 应用。 另外在搭建项目过程中升级最新的 babel 后发现@babel/preset-stage-0 即将弃用，建议使用其他代替，更多细节参考： Cannot read property ‘join’ of undefined ( preset-stage-0 ) 关于@babel/preset-stage-0 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:7:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"附 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:8:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"关键字： redux react-router react-router-config 异步加载（Code Splitting） 热更新 异步任务管理——redux-thunk react-redux redux-devtools-extension ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:8:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"部分用到的库 connected-react-router history react-hot-loader react-router-config ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:8:2","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"参考 React 应用架构设计 浅析 Redux 的 store enhancer createStore applyMiddleware combineReducers compose [译]简明 React Router v4 教程 React Router 与 Redux 整合 模块热替换(hot module replacement) react-router4 基于 react-router-config 的路由拆分与按需加载 React Router 4 简介及其背后的路由哲学 异步 Action redux 中间件之 redux-thunk Redux 入门教程（二）：中间件与异步操作 ","date":"2018-07-18","objectID":"/posts/2018-reactproject2/:8:3","series":null,"tags":["React"],"title":"从零开始搭建React应用（二）——React应用架构","uri":"/posts/2018-reactproject2/"},{"categories":["React"],"content":"项目链接：https://github.com/MrZhang123/Web_Project_Build/tree/master/react-webpack ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:0:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["React"],"content":"核心 React:16.3.2 React-dom:16.3.2 Webpack:4.6.0 React-router-dom:4.2.2 Redux:4.0.0 React-hot-loader:4.1.2 ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:1:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["React"],"content":"目录结构 ├── README.md ├── build │ ├── webpack.base.config.js │ ├── webpack.dev.config.js │ └── webpack.production.config.js ├── package.json ├── postcss.config.js ├── src │ ├── App.js │ ├── components │ │ └── Loading │ │ └── index.js │ ├── index.html │ ├── main.js │ ├── redux │ │ ├── actions │ │ │ └── demo.js │ │ ├── middleware │ │ │ └── index.js │ │ ├── reducers │ │ │ ├── demo.js │ │ │ └── index.js │ │ └── store │ │ └── index.js │ ├── static │ │ └── css │ │ └── normalize.css │ ├── styles.scss │ └── views │ ├── Content │ │ ├── About │ │ │ └── index.js │ │ ├── Home │ │ │ └── index.js │ │ ├── Topics │ │ │ └── index.js │ │ └── router.js │ └── RouterLink │ └── index.js └── yarn.lock ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:2:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["React"],"content":"基础搭建 首先搭建一个基础的React开发环境，没有redux和react-router ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:3:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["React"],"content":"安装必须的包 # dependencies yarn add react react-dom # devDependencies yarn add --dev webpack webpack-cli webpack-dev-server babel-core babel-loader babel-polyfill babel-preset-env babel-preset-react babel-preset-stage-0 cross-env css-loader file-loader jsx-loader style-loader url-loader 说明 webpack4的cli(command line interface)已经移动到webpack-cli了，如果要使用CLI,你需要安装webpack-cli，具体使用可以查看webpack-cli的文档。 由于Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign），所以如果想使用这些方法就必须使用babel-polyfill，为当前环境提供一个垫片。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:3:1","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["React"],"content":"配置webpack 在build文件夹下新建三个文件——webpack.base.config.js, webpack.dev.config.js, webpack.production.config.js，将dev和produciton里公共的部分放在base文件中。 // webpack.base.config.js const path = require('path') module.exports = { entry: { main: [ 'babel-polyfill', path.resolve(__dirname, '../src/main.js') ] }, output: { path: path.resolve(__dirname, '../dist'), publicPath: '/', filename: '[name].js', chunkFilename: 'chunk/[name].[chunkhash].js' }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.(js|jsx)$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader' }, { test: /\\.(png|jpg|gif|svg)$/, loader: 'url-loader', options: { limit: 10000, name: '[name].[ext]?[hash]' } } ] }, resolve: { modules: ['node_modules'], extensions: ['.web.js', '.js', '.jsx', '.json'] }, mode: '' // webpack v4 add } 由于是webpack的公共配置文件，所以这里mode设置空，之后在dev和prodctuon中再分别设置。 webpack4的mode 在webpack v4中新增一些默认配置，通过设置mode是development和production（默认）来启用在开发环境和生产环境的默认配置。 1.二者都有的配置 //parent chunk中解决了的chunk会被删除 optimization.removeAvailableModules:true //删除空的chunks optimization.removeEmptyChunks:true //合并重复的chunk optimization.mergeDuplicateChunks:true 2.development的默认配置 //调试 devtool:eval //缓存模块, 避免在未更改时重建它们。 cache:true //缓存已解决的依赖项, 避免重新解析它们。 module.unsafeCache:true //在 bundle 中引入「所包含模块信息」的相关注释 output.pathinfo:true //在可能的情况下确定每个模块的导出,被用于其他优化或代码生成。 optimization.providedExports:true //找到chunk中共享的模块,取出来生成单独的chunk optimization.splitChunks:true //为 webpack 运行时代码创建单独的chunk optimization.runtimeChunk:true //编译错误时不写入到输出 optimization.noEmitOnErrors:true //给模块有意义的名称代替ids optimization.namedModules:true //给模chunk有意义的名称代替ids optimization.namedChunks:true 3.production的默认设置 //性能相关配置 performance:{hints:\"error\"....} //某些chunk的子chunk以一种方式被确定和标记,这些子chunks在加载更大的块时不必加载 optimization.flagIncludedChunks:true //给经常使用的ids更短的值 optimization.occurrenceOrder:true //确定每个模块下被使用的导出 optimization.usedExports:true //识别package.json or rules sideEffects 标志 optimization.sideEffects:true //尝试查找模块图中可以安全连接到单个模块中的段。- - optimization.concatenateModules:true //使用uglify-js压缩代码 optimization.minimize:true 配置webpack.dev.config.js const webpack = require('webpack') const config = require('./webpack.base.config.js') const WebpackDevServer = require('webpack-dev-server') const PORT = process.env.PORT || 8000 // 默认8000端口，可以通过package.json配置 config.entry.main = (config.entry.main || []).concat([ `webpack-dev-server/client?http://localhost:${PORT}/`, 'webpack/hot/dev-server' ]) config.plugins = (config.plugins || []).concat([ new webpack.HotModuleReplacementPlugin() ]) config.mode = 'development' const compiler = webpack(config) const server = new WebpackDevServer(compiler, { hot: true, // 开启wbepack HMR quiet: true, historyApiFallback: true, filename: config.output.filename, publicPath: config.output.publicPath, stats: { colors: true } }) server.listen(PORT, 'localhost', () =\u003e { console.log(`server started at localhost:${PORT}`) }) 关于output.publicPath和devServer.publicPath的区别可以参考我的文章：Webpack中publicPath详解 配置webpack.production.config.js const path = require('path') const webpack = require('webpack') const config = require('./webpack.base.config') const CleanWebpackPlugin = require('clean-webpack-plugin') config.mode = 'production' config.plugins = (config.plugins || []).concat([ new CleanWebpackPlugin(['dist'], { root: path.resolve(__dirname, '../') }), new webpack.HashedModuleIdsPlugin() ]) module.exports = config ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:3:2","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["React"],"content":"结语 至此，一个简单的React开发环境就搭建完成，但是在使用后会发现一些问题，比如webpack将js和css打包在一起，我们在使用webpack的HMR时候，只要保存，页面就会刷新，页面的状态会重置等问题以及加入常用的redux和react-router，下一篇——从零开始搭建React应用（二）——React应用架构将就这些问题作出解决。 ","date":"2018-07-18","objectID":"/posts/2018-reactproject1/:4:0","series":null,"tags":["React"],"title":"从零开始搭建React应用（一）——基础搭建","uri":"/posts/2018-reactproject1/"},{"categories":["Javascript"],"content":"原文链接：https://www.sitepoint.com/es2018-whats-new/ 在这篇文章中，我将介绍ES2018（ES9）的新特性，并介绍如何使用它们。 JavaScript（ECMAScript）是跨多个平台的许多厂商实施的不断发展的标准。ES6（ECMAScript 2015）花费六年的时间敲定，是一个很大的发行版。新的年度发布流程被制定，以简化流程并更快地添加功能。 ES9（ES2018）是撰写本文时的最新版本。 TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript提案沿着一条严格的发展道路前进: Stage 0: strawman——最初想法的提交。 Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。 Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。 Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈 Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:0:0","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"ES2016 ES2016添加了两个小的特性来说明标准化过程： 数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。 a ** b指数运算符，它与 Math.pow(a, b)相同。 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:1:0","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"ES2017 ES2017提供了更多的新特性： Async 函数呈现更清晰的 Promise 语法 Object.values 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同（区别在于for...in循环枚举原型链中的属性） Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for...in循环遍历改对象时返回的顺序一致（区别在于for...in循环也枚举原型链中的属性） Object.getOwnPropertyDescriptors()返回一个对象的所有自身属性的描述符（.value,.writable,.get,.set,.configurable,enumerable） padStart()和padEnd()，填充字符串达到当前长度 结尾逗号，数组定义和函数参数列表 ShareArrayBuffer和Atomics用于从共享内存位置读取和写入 关于ES2017的更多信息请参阅 What’s New in ES2017 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:2:0","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"ES2018 ECMAScript 2018（或者叫ES9）现在已经可用了。以下功能已经到达 stage 4，但是在撰写本文时在各个浏览器的实现还不完整。 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:0","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"异步迭代 在async/await的某些时刻，你可能尝试在同步循环中调用异步函数。例如： async function process(array) { for (let i of array) { await doSomething(i); } } 这段代码不会正常运行，下面这段同样也不会： async function process(array) { array.forEach(async i =\u003e { await doSomething(i); }); } 这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。 ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。例如： async function process(array) { for await (let i of array) { doSomething(i); } } ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:1","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"Promise.finally() 一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。 .finally()允许你指定最终的逻辑： function doSomething() { doSomething1() .then(doSomething2) .then(doSomething3) .catch(err =\u003e { console.log(err); }) .finally(() =\u003e { // finish here! }); } ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:2","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"Rest/Spread 属性 ES2015引入了Rest参数和扩展运算符。三个点（…）仅用于数组。Rest参数语法允许我们将一个布丁数量的参数表示为一个数组。 restParam(1, 2, 3, 4, 5); function restParam(p1, p2, ...p3) { // p1 = 1 // p2 = 2 // p3 = [3, 4, 5] } 展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如Math.max()返回给定数字中的最大值： const values = [99, 100, -1, 48, 16]; console.log( Math.max(...values) ); // 100 ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符，一个简单的例子： const myObject = { a: 1, b: 2, c: 3 }; const { a, ...x } = myObject; // a = 1 // x = { b: 2, c: 3 } 或者你可以使用它给函数传递参数： restParam({ a: 1, b: 2, c: 3 }); function restParam({ a, ...x }) { // a = 1 // x = { b: 2, c: 3 } } 跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。 扩展运算符可以在其他对象内使用，例如： const obj1 = { a: 1, b: 2, c: 3 }; const obj2 = { ...obj1, z: 26 }; // obj2 is { a: 1, b: 2, c: 3, z: 26 } 可以使用扩展运算符拷贝一个对象，像是这样obj2 = {...obj1}，但是 这只是一个对象的浅拷贝。另外，如果一个对象A的属性是对象B，那么在克隆后的对象cloneB中，该属性指向对象B。 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:3","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"正则表达式命名捕获组（Regular Expression Named Capture Groups） JavaScript正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以YYYY-MM-DD的格式解析日期： const reDate = /([0-9]{4})-([0-9]{2})-([0-9]{2})/, match = reDate.exec('2018-04-30'), year = match[1], // 2018 month = match[2], // 04 day = match[3]; // 30 这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。 ES2018允许命名捕获组使用符号?\u003cname\u003e，在打开捕获括号(后立即命名，示例如下： const reDate = /(?\u003cyear\u003e[0-9]{4})-(?\u003cmonth\u003e[0-9]{2})-(?\u003cday\u003e[0-9]{2})/, match = reDate.exec('2018-04-30'), year = match.groups.year, // 2018 month = match.groups.month, // 04 day = match.groups.day; // 30 任何匹配失败的命名组都将返回undefined。 命名捕获也可以使用在replace()方法中。例如将日期转换为美国的 MM-DD-YYYY 格式： const reDate = /(?\u003cyear\u003e[0-9]{4})-(?\u003cmonth\u003e[0-9]{2})-(?\u003cday\u003e[0-9]{2})/, d = '2018-04-30', usDate = d.replace(reDate, '$\u003cmonth\u003e-$\u003cday\u003e-$\u003cyear\u003e'); ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:4","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"正则表达式反向断言（lookbehind） 目前JavaScript在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号： const reLookahead = /\\D(?=\\d+)/, match = reLookahead.exec('$123.89'); console.log( match[0] ); // $ ES2018引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字： const reLookbehind = /(?\u003c=\\D)\\d+/, match = reLookbehind.exec('$123.89'); console.log( match[0] ); // 123.89 以上是 肯定反向断言，非数字\\D必须存在。同样的，还存在 否定反向断言，表示一个值必须不存在，例如： const reLookbehindNeg = /(?\u003c!\\D)\\d+/, match = reLookbehind.exec('$123.89'); console.log( match[0] ); // null ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:5","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"正则表达式dotAll模式 正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现，例如： /hello.world/.test('hello\\nworld'); // false /hello.world/s.test('hello\\nworld'); // true ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:6","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"正则表达式 Unicode 转义 到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为\\p{...}和\\P{...}，在正则表达式中使用标记 u (unicode) 设置，在\\p块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。例如： const reGreekSymbol = /\\p{Script=Greek}/u; reGreekSymbol.test('π'); // true 此特性可以避免使用特定 Unicode 区间来进行内容类型判断，提升可读性和可维护性。 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:7","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"非转义序列的模板字符串 最后，ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。 之前，\\u开始一个 unicode 转义，\\x开始一个十六进制转义，\\后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 C:\\uuu\\xxx\\111。更多细节参考模板字符串。 这是所有的ES2018的新特性，ES2019已经开始，你有什么期待的功能想在明年看到吗？ ","date":"2018-06-20","objectID":"/posts/2018-es2018/:3:8","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Javascript"],"content":"译者参考 javascript正则断言的理解 【RPU-A】正则 Unicode 转义提案进入 ES2018 模板字符串——ES2018关于非法转义序列的修订 非转义序列的模板字符串 正则表达式命名捕获组 ","date":"2018-06-20","objectID":"/posts/2018-es2018/:4:0","series":null,"tags":["Javascript"],"title":"ES2018（ES9）的新特性","uri":"/posts/2018-es2018/"},{"categories":["Webpack"],"content":" 最近自己在搭建一个基于webpack的react项目，遇到关于output.publicPath和webpack-dev-server中publicPath的问题，而官方文档对它们的描述也不是很清楚，所以自己研究了下并写下本文记录。 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:0:0","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"output output选项指定webpack输出的位置，其中比较重要的也是经常用到的有path和publicPath ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:1:0","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"output.path 默认值：process.cwd() output.path只是指示输出的目录，对应一个绝对路径，例如在项目中通常会做如下配置： output: { path: path.resolve(__dirname, '../dist'), } ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:1:1","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"output.publicPath 默认值：空字符串 官方文档中对publicPath的解释是 webpack 提供一个非常有用的配置，该配置能帮助你为项目中的所有资源指定一个基础路径，它被称为公共路径(publicPath)。 而关于如何应用该路径并没有说清楚… 其实这里说的所有资源的基础路径是指项目中引用css，js，img等资源时候的一个基础路径，这个基础路径要配合具体资源中指定的路径使用，所以其实打包后资源的访问路径可以用如下公式表示： 静态资源最终访问路径 = output.publicPath + 资源loader或插件等配置路径 例如 output.publicPath = '/dist/' // image options: { name: 'img/[name].[ext]?[hash]' } // 最终图片的访问路径为 output.publicPath + 'img/[name].[ext]?[hash]' = '/dist/img/[name].[ext]?[hash]' // js output.filename output: { filename: '[name].js' } // 最终js的访问路径为 output.publicPath + '[name].js' = '/dist/[name].js' // extract-text-webpack-plugin css new ExtractTextPlugin({ filename: 'style.[chunkhash].css' }) // 最终css的访问路径为 output.publicPath + 'style.[chunkhash].css' = '/dist/style.[chunkhash].css' 这个最终静态资源访问路径在使用html-webpack-plugin打包后得到的html中可以看到。所以publicPath设置成相对路径后，相对路径是相对于build之后的index.html的，例如，如果设置publicPath: './dist/'，则打包后js的引用路径为./dist/main.js，但是这里有一个问题，相对路径在访问本地时可以，但是如果将静态资源托管到CDN上则访问路径显然不能使用相对路径，但是如果将publicPath设置成/，则打包后访问路径为localhost:8080/dist/main.js，本地无法访问 所以这里需要在上线时候手动更改publicPath，感觉不是很方便，但是不知道该如何解决… 一般情况下publicPath应该以'/‘结尾，而其他loader或插件的配置不要以’/‘开头 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:1:2","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"webpack-dev-server中的publicPath 点击查看官方文档中关于devServer.publicPath的介绍 在开发阶段，我们借用devServer启动一个开发服务器进行开发，这里也会配置一个publicPath，这里的publicPath路径下的打包文件可以在浏览器中访问。而静态资源仍然使用output.publicPath。 webpack-dev-server打包的内容是放在内存中的，这些打包后的资源对外的的根目录就是publicPath，换句话说，这里我们设置的是打包后资源存放的位置 例如： // 假设devServer的publicPath为 const publicPath = '/dist/' // 则启动devServer后index.html的位置为 const htmlPath = `${pablicPath}index.html` // 包的位置 cosnt mainJsPath = `${pablicPath}main.js` 以上可以直接通过http://lcoalhost:8080/dist/main.js访问到。 通过访问 http://localhost:8080/webpack-dev-server 可以得到devServer启动后的资源访问路径，如图所示，点击静态资源可以看到静态资源的访问路径为 http://localhost:8080${publicPath}index.html ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:2:0","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"html-webpack-plugin 这个插件用于将css和js添加到html模版中，其中template和filename会受到路径的影响，从源码中可以看出 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:3:0","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"template 作用：用于定义模版文件的路径 源码： this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); 因此template只有定义在webpack的context下才会被识别，webpack context的默认值为process.cwd()，既运行 node 命令时所在的文件夹的绝对路径 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:3:1","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"filename 作用：输出的HTML文件名，默认为index.html，可以直接配置带有子目录 源码： this.options.filename = path.relative(compiler.options.output.path, filename); 所以filename的路径是相对于output.path的，而在webpack-dev-server中，则是相对于webpack-dev-server配置的publicPath。 如果webpack-dev-server的publicPath和output.publicPath不一致，在使用html-webpack-plugin可能会导致引用静态资源失败，因为在devServer中仍然以output.publicPath引用静态资源，和webpack-dev-server的提供的资源访问路径不一致，从而无法正常访问。 有一种情况除外，就是output.publicPath是相对路径，这时候可以访问本地资源 所以一般情况下都要保证devServer中的publicPath与output.publicPath保持一致。 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:3:2","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"最后 关于webpack中的path就总结这么多，在研究关于webpack路径的过程中看查到的一些关于路径的零碎的知识如下： ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:4:0","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"斜杠/的含义 配置中/代表url根路径，例如http://localhost:8080/dist/js/test.js中的http://localhost:8080/ ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:4:1","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"devServer.publicPath \u0026 devServer.contentBase devServer.contentBase 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。 devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:4:2","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"node中的路径 __dirname: 总是返回被执行的 js 所在文件夹的绝对路径 __filename: 总是返回被执行的 js 的绝对路径 process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:4:3","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["Webpack"],"content":"参考 详解Webpack2的那些路径 webpack 公共路径(Public Path) devServer.publicPath 浅析 NodeJs 的几种文件路径 项目中关于相对路径和绝对路径的问题 ","date":"2018-05-12","objectID":"/posts/2018-webpackpublicpath/:5:0","series":null,"tags":["Webpack"],"title":"Webpack中publicPath详解","uri":"/posts/2018-webpackpublicpath/"},{"categories":["React"],"content":"由于CSS是全局的，所以在写组件的时候，经常会遇到CSS命名重复导致样式覆盖（冲突），所以我们在写CSS的时候一般会这么处理 写复杂的class名，降低冲突的概率 给组件最外层元素添加一个class，限制范围 但是这样做也不一定可以保证不会冲突，而且还导致class名字太复杂，嵌套太深，可维护性差，那么是否可以将CSS也像JS那样，实现模块化呢？答案是肯定的。CSS模块化方案很多，但是主要的就三类： 命名约定 比较常用的有BEM，SMACSS和OOCSS，但是存在以下问题： JS CSS之间依旧没有打通变量和选择器 命名太复杂 CSS in JS 直接在JS中写CSS并内联样式，例如aphrodite，babel-plugin-css-in-js等（点击查看所有CSS in JS的解决方案）但是存在以下问题： 样式代码可能会重复出现 写法上已经和传统的CSS不再相似（例如aphrodite，写法类似于React Native中样式的写法） 不能利用成熟的CSS预处理器（或后处理器） 使用JS来管理CSS模块 使用JS编译原生CSS文件，使其具有模块化，典型的就是CSS Modules。只要使用到webpack，就会使用到css-loader，在webpack中稍加配置即可使用 ","date":"2018-04-13","objectID":"/posts/2018-reactcssmodules/:0:0","series":null,"tags":["React"],"title":"CSS Modules在React中的应用","uri":"/posts/2018-reactcssmodules/"},{"categories":["React"],"content":"使用CSS Modules 配置css-loader启动css modules // webpack.config.js { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: { loader: 'css-loader', options:{ modules: true, minimize: true, localIdentName: '[path][name]__[local]--[hash:base64:5]' } } }) }, // Button.css .button{ font-size: 10px; } // Button.js import styles from './Button.css' console.log(styles) buttonElement.outerHTML = `\u003cdiv class=${styles.button}\u003eButton\u003c/div\u003e` console出来的styles如下： { button:\"src-components-Button-index__button--1mmZb\" large:\"src-components-Button-index__large--2atzR\" normall:\"src-components-Button-index__normall--3prnh\" small:\"src-components-Button-index__small--34Wrr\" } 通过以上配置，css loader为我们生成如上class名字，其中1mmZb是按照[hash:base64:5]生成的，大大降低了命名冲突的概率。 通过这些简单的处理，CSS Modules 实现了以下几点： 所有样式都是局部作用域的，解决了全局污染问题 class 名生成规则配置灵活，可以此来压缩 class 名 只需引用组件的 JS 就能搞定组件所有的 JS 和 CSS 依然是熟悉的CSS，学习成本低 ","date":"2018-04-13","objectID":"/posts/2018-reactcssmodules/:0:1","series":null,"tags":["React"],"title":"CSS Modules在React中的应用","uri":"/posts/2018-reactcssmodules/"},{"categories":["React"],"content":"在React中使用CSS Modules 直接在className处使用css中的class名即可 import React, { Component } from 'react' import { render } from 'react-dom' import styles from './index.css' class Button extends Component { constructor(props) { super(props) } render() { console.log(styles) let buttonClass = '' switch (size) { case 'large': buttonClass = styles.large break case 'small': buttonClass = styles.small break default: buttonClass = styles.normall break } return ( \u003cbutton className={buttonClass}\u003e确定\u003c/button\u003e ) } } export default Button 注 1.使用CSS Modules时发现，它只支持单独的class名字，不能像我们写css的时候一级一级的写，例如：.a .b .c，在CSS Modules中就是一步到位.c。 2.CSS Modules提供了compose组合方法实现样式的复用，代码如下： .font { line-height: 12px; font-size: 12px; } .title-font { composes: font; font-size: 24px; } React CSS Modules 但是有一个问题，我们在写样式的时候，需要频繁使用 styles.xxx，如何能够方便的直接写入class名字呢？可以使用React CSS Modules，它以高阶函数的形式生成className import React, { Component } from 'react' import { render } from 'react-dom' import CSSModules from 'react-css-modules' import styles from './index.css' class Button extends Component { render() { return ( \u003cbutton styleName='normall'}\u003e确定\u003c/button\u003e ) } } export default CSSModules(Button, styles) 可以看到，react-css-modules是运行时的依赖，而且需要在运行时获取className，性能损耗比较大，可否把获取className前置到编译阶段？答案是可以的，可以使用babel-plugin-react-css-modules babel-plugin-react-css-modules babel-plugin-react-css-modules插件可以实现用styleName属性自动加载CSS模块，通过babel插件来进行语法树解析并最终生成className，写的时候，只需要将我们原来写的className替换成styleName即可。 import React, { Component } from 'react' import { render } from 'react-dom' import styles from './index.css' class Button extends Component { render() { return ( \u003cbutton styleName='normall'}\u003e确定\u003c/button\u003e ) } } export default Button 具体配置可以查看文档 ","date":"2018-04-13","objectID":"/posts/2018-reactcssmodules/:0:2","series":null,"tags":["React"],"title":"CSS Modules在React中的应用","uri":"/posts/2018-reactcssmodules/"},{"categories":["React"],"content":"参考 https://github.com/webpack-contrib/css-loader https://juanha.github.io/2017/01/10/react-css-modules/ http://www.alloyteam.com/2017/03/getting-started-with-css-modules-and-react-in-practice/ https://github.com/camsong/blog/issues/5 ","date":"2018-04-13","objectID":"/posts/2018-reactcssmodules/:0:3","series":null,"tags":["React"],"title":"CSS Modules在React中的应用","uri":"/posts/2018-reactcssmodules/"},{"categories":["总结"],"content":" 做了一个多月的售后服务APP在昨天终于上线，期间出现各种问题，反思总结一下，以备后续做项目时候优化流程，更快更好的开发。 ","date":"2018-01-14","objectID":"/posts/2018-maf/:0:0","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"团队 ","date":"2018-01-14","objectID":"/posts/2018-maf/:1:0","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"沟通问题 由于参与开发的前端对后端业务并不是很熟悉，而产品跟后端本身对业务流程存在分歧，所以导致在前端开发过程中，前端根据产品的原型做出页面，在跟后端对接口的时候发现有些数据是给不到的，有些业务流程不是像产品说的那样的，最后，在开始开发一周多后，项目的产品，前端，后端一起开会，共同对了一下关于页面的业务逻辑，数据接口以及可行性！从而导致开发效率很低，很多逻辑/原型图改来改去，接口对来对去。 ","date":"2018-01-14","objectID":"/posts/2018-maf/:1:1","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"解决 让所有参与开发的前端人员参与和产品的会议，如果涉及到后端业务，要和后端一起，在会上确定好业务流程和交互逻辑，从而保证在开发过程中，所有开发人员都对业务有一定的了解。在开发人员充分了解业务和交互的难易程度后再评估工期可能相对更接近实际。 ","date":"2018-01-14","objectID":"/posts/2018-maf/:1:2","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"团队合作开发问题 交互不统一 开发过程中发现的另一个问题就是大家对有些交互不统一，导致一些细节的问题，其中比较明显的就是在调取扫码的时候要跳转还是在当前页面直接渲染（其实直接跳转新页面更好），但是当做完后发现有的是跳转新页面，有的是在当前页面直接渲染，这导致交互的不统一！ 数据结构不统一 项目使用React Native开发，使用Redux管理数据，但是关于在Action和Reducer中应该写什么（比如数据处理放在reducer还是action中）可能会有差异，导致代码并不是很统一，从而导致可维护性下降。 还有一点就是可能需要统一代码中的命名规范，保证代码的统一性 ","date":"2018-01-14","objectID":"/posts/2018-maf/:1:3","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"解决 统一交互 在开始项目之前前端开发人员应该一起讨论一下页面中的交互逻辑，查找是否有不同人做的相同的交互，一定要保证页面交互的统一性！ 定规范 关于Redux中Action和Reducer，应该怎写更合适，要定一个统一的标准，从而保证代码的统一！ ","date":"2018-01-14","objectID":"/posts/2018-maf/:1:4","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"自己 在开发过程中，也发现了一些自己开发流程上问题，需要更改 总是一拿到原型就开发，并没有先看看，交互是否合理，哪里不明白，这会导致开发了一部分，甚至已经做完了，才会发现这里好像不太合理，然后去改，这样导致工期加长 在做另一个APP的时候，后端那边少了一个接口，我这边没有发现，这也可能导致工期加长 所以针对以上两个问题总结以后的工作流程： 开发之前要先充分理解原型上的交互逻辑，并考虑交互的合理性 在对接接口的时候要根据原型图一个个对接，防止遗漏 ","date":"2018-01-14","objectID":"/posts/2018-maf/:2:0","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["总结"],"content":"结语 总结上面所提到的，对于自己来说需要做以下几点： 如果自己参与该项目，要积极主动跟产品，后端沟通，如果有必要，可以让产品组织开发一起开会，对一下需求 积极组织团队成员根据原型对一下交互，看哪里有相同的要统一 总结一份关于React，Redux的规范的草稿放在GitHub上，然后跟团队成员一起讨论规范的合理性，随时修改 优化自己的开发流程，先看原型再开发 / 对接口，防止出错 ","date":"2018-01-14","objectID":"/posts/2018-maf/:3:0","series":null,"tags":["总结"],"title":"MAF项目总结","uri":"/posts/2018-maf/"},{"categories":["年终总结"],"content":" 不知不觉中，2017年已经走到尾声，2018年马上要到来了，回想这一年，无论是工作还是生活都发生了很多变化，如果用一个字来总结2017，那么这个字就是“变”,这些事情让我有了更多的想法，这也让我对2018年有了期待。 ","date":"2017-12-31","objectID":"/posts/2017-2018newyear/:0:0","series":null,"tags":["年终总结"],"title":"再见2017，你好2018","uri":"/posts/2017-2018newyear/"},{"categories":["年终总结"],"content":"工作，技术 2017年，自己所在的项目组发生了很大的变化，业务有所调整，所以自己的工作内容也发生了重大的变化。 回看这一年的周报，可以很明显的看到，在2017年上半年，工作内容集中在海外业务，但是到了下半年，工作内容已经开始逐步转向平台业务系统，开始接触很多的好玩儿的技术，像react，react native，vue等等这些框架开始大量使用。业务量的增长，人员的增多，让我的思想开始发生转变。 HOW ➡️ WHY 之前，由于业务并不是那么多样化，业务量也不是那么多，所以使用的技术相对单一，自己之前虽然也有学一些新的东西，但是这些东西也仅仅停留在学习如何使用上面，而对于为什么要这么用，可能并不会想太多。 原理的理解让我对那些经常使用的技术有了更深入的理解，如果不理解为什么这么写而仅仅只是知道需要这么写就很容易忘记，而且每次写的时候还需要看看官方demo，这可以说是自己的亲身体会吧。 之前在做完一个react项目再做另一个的时候，我发现我还是需要看官方demo才能记得，那个connect怎么写，小括号，花括号怎么放，这让我很无语，这让我开始意识到我该学习一下为什么这里要这么写，所以自己该抽时间学习一下redux的原理，源码，在学习后，感觉写起来要顺利许多，这一点让我感触很深。 还有一点，就是在使用那些新技术的时候，比如像vue，react的时候，最好不要一上来就全家桶，直接redux什么的一起上，最好还是有个渐进的过程，否则对于为什么需要这些库理解可能不会太深。之前做第一个项目的时候，交互虽然复杂，但是并没有用redux，这让我们在做项目的时候，遇到了很多回调，很深的传递，之后在项目中加入redux之后，才对为什么会有这些数据管理库有了更加深入的理解，我觉得这一点也是非常宝贵的， 所以，我觉得今年关于技术思想上变化最大的，也是让我感触最深的是： 要知其然，也要知其所以然，而不是盲目的学完这个学那个，这样的最终结果就是哪个都不是很精，并没有太大用处。 在学习这些技术的同时要理解这些技术解决了开发中的哪些痛点，理解它们出现的原因，记得之前尤大也说过，vue是渐进式的框架，我觉得学习技术也要渐进式的学习，一个一个网上加，而不是搞大而全，这样才能理解更深入。 意识到团队的重要性，开始注重软实力 之前，由于人员相对较少，所以很多时候，可能是怎么方便怎么来，并不会考虑自己写的这些东西别人用的会不会舒服，自己写的代码别人能不能看懂，但是随着人员的增多，项目的增大，大家合作的越来越多，自己有时候也会负责项目的搭建，自己可能会写一些公共的代码块儿在项目中使用，这些工作的出现让我开始意识到团队合作的重要性，自己弄的东西，如何方便他人的使用，一个项目如何搭建更利于后期维护。 现在的前端发展非常快，各种新技术层出不穷，但是在我们忙着学习新东西的时候，我们是否考虑过自己的代码写的足够健壮，如何写让别人读起来更加舒服，技术在更新，各种框架在变化，但是这些软实力并没有因此而变得不重要，它们依旧是考量一个工程师是否优秀的标准之一。 今年开始，自己开始学着如何让项目的可维护性更高，代码如何写，更加健壮，开始注重修炼内功了，但是这并不是那么简单几天几个月就可以学会的，而是一个长期的过程，年底时候考虑过自己写一份代码规范，相当于一个revew规范吧，如何写代码更加合适，但是由于年底工作的繁忙并没有实现这个，我想这个将会是2018年的要做的头一件事儿了。 关于2017年一年在技术方面让我产生思考，并让我发生转变的的就这两方面了，2018年我将沿着这两方面继续走下去✌️ ","date":"2017-12-31","objectID":"/posts/2017-2018newyear/:1:0","series":null,"tags":["年终总结"],"title":"再见2017，你好2018","uri":"/posts/2017-2018newyear/"},{"categories":["年终总结"],"content":"生活 2017年关于生活上的，2017年也发生了很多事儿，尤其是在后半年的一些事儿让我记忆深刻，甚至引发一些思考。 学习英语 英语对于我这种技术人来说其实一直都很重要，因为经常会遇到阅读国外文章，文档的时候，所以英语好对于我来说是非常重要的，所以从2017年下半年开始，我开始再一次拿起英语，我觉得2018年，这也将是重中之重… 开始对金融投资感兴趣 数字货币比特币在2017年底可以说是占尽了风头，在谷歌搜索排行榜达到第一，为什么会这样的呢？因为在2017年，数字货币像比特币，莱特币，以太坊等等可以说是疯长，比特币一路狂飙，一度达到每个十万人民币，要知道这家伙年初的时候也就几千一个，着就说说，如果你持有几十个比特币，基本上离财富自由就不远了。 记得第一次听说比特币是在上大学时候，那时候虽然对这个东西好奇，但是因为是学生，也没什么钱，所以并没有投资这些，之后就渐渐的淡忘了，直到今年年底，新闻开始大量报道比特币疯狂上涨以及各种稀奇古怪的丢失比特币的新闻，比如国外有一哥们儿扔了个硬盘，里面有几千个比特币，找不回来了，估计这哥们儿会后悔一辈子吧，哈哈… 还有就是看到同学开始学着理财，自己也开始尝试，但是只是买了些基金，而且因为不是很懂这些，所以也是在乱买，年底的时候感觉不能这么胡来，得系统学习下这些东西到底是怎么弄的。 这两件事儿让我开始对金融投资产生了兴趣，我觉得2018年我将要认真学习关于金融的东西 参与线下活动 2017年这一年，说实话，参与的活动变得少了，无论是技术还是非技术，相比于2016年少了很多，也许是因为2017年人工智能火爆，而前端相对于2016年热度降低不少，所以很多技术活动都是人工智能方面的，而非技术方面的其他活动，不知道为什么也参加少，可能是没找到好玩儿一点儿的，所以也少了。 2018年还是要多参加活动，这样才能认识更多有意思的人，扩展自己的想法，而不是局限在技术这一个圈子内。 去上海参加Ultra China——人生中第一次参加音乐活动 如果说2016年对于我来说是民谣的一年，那么2017年就是我的电音元年了。2016年年底，开始有意识的听一些电音，开始知道有电音这种音乐风格。 之前虽然也喜欢过各种各样的歌手，但是对于去现场，我并没有多大想法，感觉去不去都一样，没什么意思，直到遇到电音。去参加Ultra，人生中第一次参加音乐节。 2017年初，听说世界顶级电音节之一——Ultra Music Festival要来中国上海了，非常的激动，毕竟自己虽然喜欢电音，但是因为这些音乐节都在国外举行，所以只能看看视频了，并没有去现场看到，这次Ultra来中国，举办首届Ultra China，可以说是必去无疑，虽然是一个人，但是还是决定去一趟。在经过抢票，安排行程住宿后，就盼望着9月8日了。 经过忙碌的工作，耐心的等待，2017年9月8日终于到来，这两天，全国的顶级raver纷纷乘坐各种交通工具来到上海，参加属于他们的顶级电音节。 我记得8号我坐动车去上海，动车给我晚点了，我也是醉了。最终在晚点90分钟后，成功在凌晨抵达上海，也是够艰难的😂。 两天的狂欢即将开始… 两天的狂欢可以说是让人精疲力尽，各种腰酸腿疼，但是并不后悔，因为之前对于音乐，从未有过如此喜欢的感觉。虽然难说再见，各种不舍，但是最终还是在9月11日，踏上回京的高铁… 再见Ultra，2018年上海，不见不散… 前几天听说2018年，EDC要来中国上海了，又一大顶级电音节登陆上海，我想说，tomorrowland来中国还远吗？哈哈，看来明年至少去一趟上海了✌️。 附： Armin Van Buuren tomorrowland 2017 live Armin Van Buuren Year Mix 2017 Martin Garrix tomorrowland 2017 live Hardwell Year Mix 2017 live ","date":"2017-12-31","objectID":"/posts/2017-2018newyear/:2:0","series":null,"tags":["年终总结"],"title":"再见2017，你好2018","uri":"/posts/2017-2018newyear/"},{"categories":["年终总结"],"content":"结语 此刻，距离2018年还有不到一个小时。今天，对这一年的小确幸送上微笑，也向这一年的遗憾送上拥抱；对这一年坚持过的自己说声“谢谢”，也向这一年放弃过的自己说声“在努力”；为这一年世界的美好点赞，也向这一年流过的泪告别。 再见2017，你好2018… ","date":"2017-12-31","objectID":"/posts/2017-2018newyear/:3:0","series":null,"tags":["年终总结"],"title":"再见2017，你好2018","uri":"/posts/2017-2018newyear/"},{"categories":["React Native"],"content":" React Native Version:0.51 RN 在 0.37 版本中加入了WebView功能，所以想要在使用WebView,版本必须\u003e=0.37，发送的 message 只能是字符串，所以需要将其他格式的数据转换成字符串，在接收到后再转换回去，其实直接用JSON.stringify和JSON.parse就可以 ","date":"2017-12-20","objectID":"/posts/2017-rnwebview/:0:0","series":null,"tags":["React Native"],"title":"RN Webview与Web的通信与调试","uri":"/posts/2017-rnwebview/"},{"categories":["React Native"],"content":"加载 html source属性用于指定加载的 html，可以加载在线的页面，也可以加载本地的页面，代码如下： // 加载线上页面 \u003cWebview source={{uri: 'http://www.mi.com'}} /\u003e // 加载本地html文件 \u003cWebView source={require('../src/html/index.html')} /\u003e 注意 ⚠️ 在 RN 中可以加载 WebView，但是无法调试，也不能使用 alert 来验证代码 js 代码是否运行成功，只能通过往 html 写入东西（innerHTML）来验证 js 是否运行成功 ","date":"2017-12-20","objectID":"/posts/2017-rnwebview/:1:0","series":null,"tags":["React Native"],"title":"RN Webview与Web的通信与调试","uri":"/posts/2017-rnwebview/"},{"categories":["React Native"],"content":"WebView 与 html 的通信 webview 发送信息到 html WebView 给 html 发送信息需要使用postMessage，而 html 接收 RN 发过来的信息需要监听message事件，代码如下： // RN class WebViewExample extends Component { onLoadEnd = () =\u003e { this.refs.webview.postMessage = 'this is RN msg' } render() { return ( \u003cWebView ref=\"webview\" source={require('../html/index.html')} onLoadEnd={this.onLoadEnd} /\u003e ) } } export default WebViewExample // web window.document.addEventListener('message', function(e) { const message = e.data }) 这里需要注意一点 postMessage需要在 webview 加载完成之后再去 post，如果放在commponentWillMount里由于页面没有加载完成就 post 信息，会导致 html 端无法监听到 message 事件。 html 发送信息到 webview // RN class WebViewExample extends Component { handleMessage = e =\u003e { const message = e.nativeEvent.data } render() { return ( \u003cWebView ref=\"webview\" source={require('../html/index.html')} onMessage={e =\u003e this.handleMessage(e)} /\u003e ) } } export default WebViewExample // web window.postMessage('this is html msg') ","date":"2017-12-20","objectID":"/posts/2017-rnwebview/:2:0","series":null,"tags":["React Native"],"title":"RN Webview与Web的通信与调试","uri":"/posts/2017-rnwebview/"},{"categories":["React Native"],"content":"debug RN 中 debug webview 和安卓开发中看起来是差不多的，连接好设备后，在 chrome 中输入 chrome://inspect 就可以看到安卓设备上正在运行的 webview 了，点击inspect就会开启一个调试页面，就可以进行 debug 了，RN 似乎默认开启了 debug 调试，直接就可以看到 webview 中输出的信息。 但是我发现我打开的调试界面是一个错乱的界面，不知道为什么，无奈–！ ","date":"2017-12-20","objectID":"/posts/2017-rnwebview/:3:0","series":null,"tags":["React Native"],"title":"RN Webview与Web的通信与调试","uri":"/posts/2017-rnwebview/"},{"categories":["React Native"],"content":"注意 ⚠️ 这里需要注意一点的，由于安卓版本的差异，所以内部的 webview 对 js 的支持程度也不同，为了保证兼容性，如果使用了 ES6，请转成 ES5，否则会报错 ","date":"2017-12-20","objectID":"/posts/2017-rnwebview/:3:1","series":null,"tags":["React Native"],"title":"RN Webview与Web的通信与调试","uri":"/posts/2017-rnwebview/"},{"categories":["Javascript"],"content":" 这周在开发后端系统的时候，遇到了需要将后端传过来的转义字符进行转义然后再渲染到html中，因为之前也没有遇到过，所以研究了研究，记录一下。 记得上大学时候学习C语言就有提到过转义字符，比如\\n表示回车，\\t表示水平制表符等等。其实所有编程语言都有转移字符，转移字符出现的原因基本上就两点： 使用转义字符来表示字符集中定义的字符，比如ASCll里面的控制字符及回车换行等字符，这些字符都没有现成的文字代号。所以只能用转义字符来表示 某一些特定的字符在编辑语言中被定义为特殊用途的字符。这些字符由于被定义为特殊用途，它们失去了原有的意义。例如在html中，\u003c被HTML定义为标签的开始，所以当我们转入\u003c时，HTML就会把它当作为开始，而不是当作一个\u003c来看待 由于不同的语言关键字不同，例如在一般的编程语言中，\"会被当作代码的一部分，但是在html中它会被直接渲染，再如常见的编程语言中\\n表示回车，但是在html中\u003cbr\u003e表示回车 这就导致了如果后端返回的是想要在前端展示的一段代码，则必然会包含转移字符，而这些转义字符html是无法识别的 ","date":"2017-11-25","objectID":"/posts/2017-jsdecode/:0:0","series":null,"tags":["Javascript"],"title":"JS转换转义字符","uri":"/posts/2017-jsdecode/"},{"categories":["Javascript"],"content":"解决——js转换转义字符 由于html与js所用的转义字符不同所以导致了无法正常渲染，所以需要在js中先将转义字符转换，然后在渲染到html中，在js中转换转义字符常用的有两种方法： eval() JSON.parse() eval()函数会将传入的字符串当做JavaScript代码进行执行。这个函数一般是不推荐使用的，因为他执行的代码拥有着执行者的权利。如果用eval()运行的字符串代码被恶意方操控修改,可能会利用最终在用户机器上运行恶意方部署的恶意代码，并导致失去对网页或者扩展程序的权限。所以这种方法是不推荐的 JSON.parse()方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象，经过这个转换，由于代码的执行，转义字符会被自动转义，从而拿到我们想要的效果，但是使用这个方法解析的时候需要注意一点：必须组合成JSON字符串，所以我们需要将拿到的数据进行包装： decodeValueFun(value) { const decodeValue = JSON.parse(`{\"key\":${value}}`); return decodeValue.key; }, 这样返回的数据就是经过转义的数据了 ","date":"2017-11-25","objectID":"/posts/2017-jsdecode/:1:0","series":null,"tags":["Javascript"],"title":"JS转换转义字符","uri":"/posts/2017-jsdecode/"},{"categories":["Javascript"],"content":"疑问🤔️ 在实际测试的时候发现，如果将后端返回的数据直接贴入前端js代码中然后去直接展示到页面中，转义字符会被自动识别，但是如果将后端返回的字符串直接渲染到html页面中，则字符串中的转义字符直接被当作字符串处理，这说明在js使用字符串的时候已经将转义符自动转义，不知道这个是什么原因。 ","date":"2017-11-25","objectID":"/posts/2017-jsdecode/:2:0","series":null,"tags":["Javascript"],"title":"JS转换转义字符","uri":"/posts/2017-jsdecode/"},{"categories":["Javascript"],"content":"附： 常见的HTML转义字符 字符 十进制 转义字符 \" \u0026#34; \u0026quot; \u0026 \u0026#38; \u0026amp; \u003c \u0026#60; \u0026lt; \u003e \u0026#62; \u0026gt; 不断开空格(non-breaking space) \u0026#160; \u0026nbsp; 更多html转义字符见链接：http://tool.oschina.net/commons?type=2 常见的编程语言的字符表 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符''' 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 \\? 代表一个问号 063 \\0 空字符(NULL) 000 \\ooo 1到3位八进制数所代表的任意字符 三位八进制 \\xff 1到2位十六进制所代表的任意字符 二位十六进制 ","date":"2017-11-25","objectID":"/posts/2017-jsdecode/:3:0","series":null,"tags":["Javascript"],"title":"JS转换转义字符","uri":"/posts/2017-jsdecode/"},{"categories":["Javascript"],"content":"动态吸底：开始时fixed在页面上，当页面滚动到距离底部一定距离的时fixed部分固定。 这个是需要计算页面滚动距离的，如果使用Jquery或者原生js实现是非常好实现的，但是由于使用react并不推崇操作DOM，但是如果使用virtual DOM的话是无法实现该效果的，所以还是要引入js去直接获取DOM进行操作。 react在componentDidMount之后页面渲染完成，所以可以在这里面直接用js原生方法获取DOM元素，进而进行操作。 componentDidMount() { this.changeFixed() } //計算高度 changeFixed(){ //getDOMNode const layoutNode = document.querySelectorAll('.page-layout')[0]; const orderPriceNode = document.querySelectorAll('.test-price')[0]; window.addEventListener('scroll', function (e) { const windowInnerHeight = window.innerHeight; const layoutNodeHeight = layoutNode.offsetHeight; //滚动超出视野距离 let scrollTop = window.pageYOffset|| document.documentElement.scrollTop || document.body.scrollTop; const distanceBottom = layoutNodeHeight - scrollTop - windowInnerHeight; //120的时候吸底 if(distanceBottom \u003c= 120){ orderPriceNode.classList.remove('fixed'); }else{ orderPriceNode.classList.add('fixed'); } }) } 这样就实现了当距离底部120的时候吸底 ","date":"2017-10-22","objectID":"/posts/2017-reactdom/:0:0","series":null,"tags":["Javascript"],"title":"小记：React操作真实DOM实现动态吸底部","uri":"/posts/2017-reactdom/"},{"categories":["Git"],"content":" 之前看一个github的开源项目，看到要求使用angular的git commit规范，刚好自己项目中也需要规范git commit，所以就研究总结一下。 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:0:0","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"配置检测git commit是否合法 npm install --save-dev @commitlint/cli husky 新建commitlint.config.js配置git提交规范（这里使用的是angular的提交规范） module.exports = { rules: { 'body-leading-blank': [1, 'always'], //body开始于空白行 'body-tense': [1, 'always', ['present-imperative']], 'footer-leading-blank': [1, 'always'], //footer开始于空白行 'footer-tense': [1, 'always', ['present-imperative']], 'header-max-length': [2, 'always', 72], 'scope-case': [2, 'always', 'lowerCase'], //scope小写 'subject-empty': [2, 'never'], //subjec不t为空 'subject-full-stop': [2, 'never', '.'], //subject结尾不加'.' 'subject-tense': [1, 'always', ['present-imperative']], //以动词开头，使用第一人称现在时，比如change，而不是changed或changes 'type-case': [2, 'always', 'lowerCase'], //type小写 'type-empty': [2, 'never'], //type不为空 'type-enum': [ 2, 'always', [ 'build', 'chore', //构建过程或辅助工具的变动 'docs', //文档（documentation） 'feat', //新功能（feature） 'fix', //修补bug 'perf', 'refactor', //重构（即不是新增功能，也不是修改bug的代码变动） 'revert', 'style', //格式（不影响代码运行的变动） 'test', //增加测试 ], ], //type关键字必须是其中之一 }, }; 配置husky { \"scripts\": { \"commitmsg\": \"commitlint -e\" } } 配置完成之后，提交所写的commit如果不符合规范，则无法进行下一步操作 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:1:0","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"Commit message 的格式 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer \u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e // 空一行 \u003cbody\u003e // 空一行 \u003cfooter\u003e Header是必需的，Body和Footer可以省略 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:2:0","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"header Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需） type 该字段用于说明commit的类型，被指定在上面的type-enum中 'build', 'chore', //构建过程或辅助工具的变动 'docs', //文档（documentation） 'feat', //新功能（feature） 'fix', //修补bug 'perf', 'refactor', //重构（即不是新增功能，也不是修改bug的代码变动） 'revert', 'style', //格式（不影响代码运行的变动） 'test', //增加测试 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况建议是不要放入 scope 用于说明commit的影响范围 subject subject是 commit 目的的简短描述，不超过50个字符 要求如下： 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:2:1","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"body body 部分是对本次 commit 的描述，可以分成多行，例如： More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点: 使用第一人称现在时，比如使用change而不是changed或changes 应该说明代码变动的原因，以及跟以前提交的对比 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:2:2","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"footer footer只用于以下两种情况： 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. 关闭Issue 如果当前 commit 针对某个issue，那么可以在 footer 部分关闭这个 issue //关闭一个 Closes #1 //关闭多个 Closes #2, #3, #4 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:2:3","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，必须以revert:开头，后面跟着被撤销 commit 的 header revert: refactor(compiler): introduce `TestBed.deprecatedOverrideProvider` (#19558) This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit \u003chash\u003e.，其中的hash是被撤销 commit 的 SHA 标识符 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:2:4","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"Example refactor(compiler): introduce `TestBed.deprecatedOverrideProvider` (#19558) This allows use to fix `TestBed.overrideProvider` to keep imported `NgModule`s eager, while allowing our users to still keep the old semantics until they have fixed their tests. PR Close #19558 ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:2:5","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["Git"],"content":"生成change log 如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。 生成的文档包括以下三个部分。 New features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 $ npm install -g conventional-changelog $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。 如果你想生成所有发布的 Change log，要改为运行下面的命令。 $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。 { \"scripts\": { \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -w -r 0\" } } 以后，直接运行下面的命令即可。 $ npm run changelog ","date":"2017-10-18","objectID":"/posts/2017-gitcommint/:3:0","series":null,"tags":["Git"],"title":"Git Commint规范","uri":"/posts/2017-gitcommint/"},{"categories":["React"],"content":" 最近一段时间一直在使用react ／ react native结合redux做一些东西，所以总结一下在使用这些东西的时候自己遇到的一些问题 ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:0:0","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React"],"content":"setState是异步的 在react中，setState是非常常见的，有时候想要在setState之后再执行某些操作，可能会这样写： this.setState({xxState}) if(this.state.xxState){ ... } 当执行时候发现，this.state.xxState并没有被改变，原因在于setState是异步的，而js执行代码的顺序是同步 =\u003e 异步 =\u003e 回调，所以会先执行if的语句，如果想要在设置完state之后再执行后面的语句，代码如下： this.setState({xxState},()=\u003e{ if(this.state.xxState){ ... } }) ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:1:0","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React"],"content":"对redux中action变量命名的理解 在redux中有action，reducer和store，我们在写的时候分别写在三个文件夹中，每个模块对应一个action，reducer，但是最终在运行应用的时候会组和在一起，将所有的action合并成一个文件，通过action去找到对应模块的reducer，从而找到正确的方法。 如果把redux比做一本书的话，action是一本书的目录，而reducer则相当于书的每一章的内容，书的目录是不能重复的，否则会导致在寻找内容的时候出现找到两处对应的内容，这在redux中是不允许的。如下图所示： 所以action中的常量名在整个项目中是不能重复的，否则会在执行当前模块的reducer时候同时执行其他模块的reducer，导致数据的混乱。 ##使用react router进行页面传值 首先说明一下，router的跳页方式有两种，一种是直接写Link，另一种是使用hashHistory.push： import { Router,Route,hashHistory} from 'react-router' \u003cLink to=\"/a/b\"\u003e链接\u003c/Link\u003e //or clickFun(){ hashHistory.push(\"/a/b\") } \u003cdiv onClick={()=\u003ethis.clickFun()}\u003e\u003c/div\u003e 有时候需要在跳页的时候给下一个页面传递数据，使用react router有三种方式可以实现该需求： ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:2:0","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React"],"content":"props.params 我们可以给\u003cRoute\u003e指定一个path，然后指定通配符可以携带参数到指定的path： import { Router,Route,hashHistory} from 'react-router' class App extends React.Component { render() { return ( \u003cRouter history={hashHistory}\u003e \u003cRoute path='/a/:params' component={UserPage}\u003e\u003c/Route\u003e \u003c/Router\u003e ) } } //取值 export default class UserPage extends React.Component{ constructor(props){ super(props); } render(){ return(\u003cdiv\u003ethis.props.params.name\u003c/div\u003e) } } 上面的方法可以传递一个或多个值，但是每个值的类型都是字符串，没法传递一个对象,如果传递的话可以将json对象转换为字符串，然后传递过去，传递过去之后再将json字符串转换为对象将数据取出来。 ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:2:1","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React"],"content":"query 使用query可以像get方式一样显示传递数据 let data = {a:3,b:'b',c:36}; let path = { pathname:'/user', query:data, } \u003cLink to={path}\u003e跳转\u003c/Link\u003e //or hashHistory.push(path) //取值 const {a,b,c} = this.props.location.query ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:2:2","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React"],"content":"state state传递数据方式类似于post，使用方式与query类似，取值的时候使用this.props.location.state ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:2:3","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React"],"content":"Object.assign()的使用 在reducer中，使用Object.assign将新的state与默认的state进行合并 const initState = { ajaxState:false, orderData: { current_page: 0, per_page_count: 0, total_count:0, total_page:0, data_list: [], } } export default (state = initState , action) =\u003e { const {type , ajaxState , orderData = {}} = action; switch(type){ case ORDERDATA: return Object.assign({},state,{orderData}) } } 这里initState相当于一个默认值，拿到新的state时候就将原有的覆盖掉。 但是在做项目时候遇到一个问题，如果传递部分数据（比如orderData只传递传递了current_page和per_page_count），没有传递的希望保持默认，这样使用Object.assign合并会导致合并的结果中未传递的部分直接丢失。 Object.assign在合并对象的时候，可以合并简单对象的元素，但是如果对象中在嵌套对象，则子对象不会合并而会直接覆盖，代码如下： const obj = { a:1, b:2 } const init = { name:'', obj:{ a:'', b:'', c:'', } } Object.assign({},init,obj) /*结果 [object Object] { obj: [object Object] { a: 1, b: 2, }, name: \"\" } */ 所以，如果要让不传递的数据使用默认值，就需要在reducer开始拿到传递到的数据时候，将没有传递过来的数据加到传过来的数据上，就需要使用两次Object.assign，分别对子对象和对象进行 export default (state = initState , action) =\u003e { const {type , ajaxState , orderData = {}} = action; //将没有传递过来的数据的默认值加到传过来的state中 const defaultOrderData = Object.assign({},initState.orderData,{orderData}) switch(type){ case ORDERDATA: return Object.assign({},state,{orderData:defaultOrderData}) } } 这样就可以实现传递部分数据，不传递的使用默认值 从该例子中可以看出，在reducer中，尽量不要使用嵌套对象，因为每嵌套一层，就需要Object.assign一次 以上就是最近做react项目的一些总结… ","date":"2017-08-13","objectID":"/posts/2017-reactsum/:3:0","series":null,"tags":["React"],"title":"React使用小记","uri":"/posts/2017-reactsum/"},{"categories":["React Native"],"content":"突然发现自己的博客已经从原来的几天更新一次变成了如今的一个月更新一次[捂脸]，最近这一个月实在是太忙了，上个月月初的时候，接了一个RN的项目，做一个app，那时候老大问谁感兴趣，我直接说我。其实自己对RN一直很有兴趣，但是那时候由于在看Vue，所以并没有去搞，现在刚好有个项目，正好我可以去了解一下RN。说实话，这一答应不要紧，差点儿被RN气死，以前觉得RN应该比较成熟了，经过这段时间做项目，发现RN的坑还是很多的。 在项目中我用到的比较多的是长列表，所以这篇文章主要是记一下对RN的ListView和SectionList的一些总结。我项目中使用的RN是0.44，关于为什么不用性能更好的FlatList而使用老的ListView，是因为自己本身第一次接触RN，所以担心用不好FlatList而且担心会有什么bug，毕竟这个是在0.43版本才添加的。 ","date":"2017-06-11","objectID":"/posts/2017-reactnativelist/:0:0","series":null,"tags":["React Native"],"title":"RN长列表--ListView \u0026\u0026 SectionList","uri":"/posts/2017-reactnativelist/"},{"categories":["React Native"],"content":"ListView 对于ListView最重要的两个属性，一个是数据源（dataSource），再一个就是列表项渲染（renderRow）。ListView可以根据不同的数据结构对应的生成普通长列表和分组长列表。 ","date":"2017-06-11","objectID":"/posts/2017-reactnativelist/:1:0","series":null,"tags":["React Native"],"title":"RN长列表--ListView \u0026\u0026 SectionList","uri":"/posts/2017-reactnativelist/"},{"categories":["React Native"],"content":"普通长列表 普通长列表使用cloneWithRows(dataBlob, rowIdentities)创建datasource，在项目中dataBlob的数据结构如下： [ {id:1}, {name:'Mark'}, ... ] 在使用renderRow(rowData, sectionID, rowID, highlightRow)渲染列表项的时候，rowData就是数组中每一个对象。 ","date":"2017-06-11","objectID":"/posts/2017-reactnativelist/:1:1","series":null,"tags":["React Native"],"title":"RN长列表--ListView \u0026\u0026 SectionList","uri":"/posts/2017-reactnativelist/"},{"categories":["React Native"],"content":"分组长列表 在项目中，遇到分组长列表，由于RN版本为0.44，所以有ListView和SectionList两种选择方案，最终我选择了SectionList，因为我发现ListView的section只能是一个简单的字符串，不能是一个对象（这里说实话我也不知道对不对，若不对，请指正并说明如何使用ListView实现section是一个对象）。 这里我要吐槽一下RN的文档，真的是有些地方写的太简单，比如在ListView这里写到使用cloneWithRowsAndSections的使用，只是简单的说跟cloneWithRows差不多，而接受的数据结构也就简单的说明有三种： { sectionID_1: { rowID_1: \u003crowData1\u003e, ... }, ... } //or { sectionID_1: [ \u003crowData1\u003e, \u003crowData2\u003e, ... ], ... } //or [ [ \u003crowData1\u003e, \u003crowData2\u003e, ... ], ... ] 但是具体这里的是些什么，我觉得没有说清楚。所以我在项目中试了下用ListView的cloneWithRowsAndSections实现带有粘性标题的列表，发现前两种sectionID只能是一个简单的字符串或者数字，不能是一个对象，数据结构如下： const dataSource1 = [ ['row1','row2'], ['row3','row4'], ['row5','row6'], ]; const dataSoure2 = { 'id1':['row1','row2'], 'id2':['row3','row4'], 'id3':['row5','row6'], } const dataSoure3 = { 'id1':{'row1','row2'}, 'id2':{'row3','row4'}, 'id3':{'row5','row6'}, } cloneWithRowsAndSections(dataSource); dataSoure1生成的sectionHeader是数组的下标，而第二个第三个分别是对应的key，在项目中我的sectionHeader是一个对象，类似于{headerName:'',headerContent:''}，所以无法使用。 ","date":"2017-06-11","objectID":"/posts/2017-reactnativelist/:1:2","series":null,"tags":["React Native"],"title":"RN长列表--ListView \u0026\u0026 SectionList","uri":"/posts/2017-reactnativelist/"},{"categories":["React Native"],"content":"SectionList分组长列表 SectionList和FlatList一样是新增的高性能长列表，在文档中关于SectionList接受的数据结构描述如下： \u003cSectionList renderItem={({item}) =\u003e \u003cListItem title={item.title} /\u003e} renderSectionHeader={({section}) =\u003e \u003cH1 title={section.title} /\u003e} sections={[ // homogenous rendering between sections {data: [...], title: ...}, {data: [...], title: ...}, {data: [...], title: ...}, ]} /\u003e \u003cSectionList sections={[ // heterogeneous rendering between sections {data: [...], title: ..., renderItem: ...}, {data: [...], title: ..., renderItem: ...}, {data: [...], title: ..., renderItem: ...}, ]} /\u003e 说实话我第一次看到这个描述的时候很懵逼，这好像并没说明data里具体的数据结构是什么样子的，renderSectionHeader中的数据又该如何取，在网上看了一个简单的讲解才大概知道sections里的数据应该怎么写，代码如下： import React , {Component} from 'react'; import { AppRegistry, StyleSheet, Text, View, SectionList } from 'react-native'; const dataSource = [ {data:[{name:'nader'},{name:'chris'}],key:'A'}, {data:[{name:'nick'},{name:'amanda'}],key:'B'} ]; export default class SectionListExample extends Component { renderItem = (item) =\u003e { return \u003cText style={styles.text}\u003e{item.item.name}\u003c/Text\u003e } renderHeader = (headerItem) =\u003e { return \u003cText style={styles.header}\u003e{headerItem.section.key}\u003c/Text\u003e } render(){ return( \u003cView style={styles.container}\u003e \u003cSectionList renderItem={this.renderItem} renderSectionHeader={this.renderHeader} sections={dataSource} keyExtractor={(item)=\u003eitem.name} /\u003e \u003c/View\u003e ) } } 这里需要注意一点就是renderItem所用的数据key必须是data，而且key必须是唯一的，然后其余的数据用在headerItem中，这样就非常容易在sectionHeader中渲染出多个后台给定的数据。 SectionList和FlatList需要注意几点： 文档中提到为了优化内存占用同时保持滑动的流畅，列表内容会在屏幕外异步绘制。这意味着如果用户滑动的速度超过渲染的速度，则会先看到空白的内容。这是为了优化不得不作出的妥协，而我们也在设法持续改进。所以如果不想在滑动过快导致白屏出现，就只能使用ListView。 在我的项目中设置stickySectionHeadersEnabled={true}的时候，粘性标题在往下滑动一会儿再滑动回去的时候，标题会消失，这不知道是我代码有问题还是本身SectionList的粘性标题在安卓下就有问题，不过在官方文档中写到Only enabled by default on iOS because that is the platform standard there.所以可能是SectionList粘性标题在安卓下就有问题。 SectionList和FlatList提供了一个叫legacyImplementation的属性，该属性如果设置为true则使用旧的ListView实现。在上述提到的两个问题中，如果将SectionList的legacyImplementation设置为true，则两个问题均解决。个人觉得这是官方提供的一个降级的办法，所以其实我们可以抛弃ListView转而使用FlatList和SectionList，如果有什么问题，让它们用旧的ListView实现。 ","date":"2017-06-11","objectID":"/posts/2017-reactnativelist/:2:0","series":null,"tags":["React Native"],"title":"RN长列表--ListView \u0026\u0026 SectionList","uri":"/posts/2017-reactnativelist/"},{"categories":["React Native"],"content":"最后 最后列几个长列表（ListView，SectionList，FlatList）的常用属性 onEndReached（function）：当列表到达底部时候触发的事件，关于这个事件需要注意一点，当第一次渲染时，如果数据不足一屏（比如初始值是空的），这个事件也会被触发，需要自行过滤 onEndReachedThreshold（number）：距离最后一个列表元素多少像素时候触发onEndReached事件 initialListSize（number）：初始化时候渲染多少条数据，如果不写择时逐条渲染 showsVerticalScrollIndicator（bool）：默认情况下，ListView有滚动条，当设置为false的时候不显示该滚动条（继承自ScrollView） pageSize（number，仅ListView有）：每次事件循环（每帧）渲染的行数，常用于分页，数据请求回来后渲染多少条，不设置则逐条渲染。 ","date":"2017-06-11","objectID":"/posts/2017-reactnativelist/:3:0","series":null,"tags":["React Native"],"title":"RN长列表--ListView \u0026\u0026 SectionList","uri":"/posts/2017-reactnativelist/"},{"categories":["Javascript"],"content":" 前段时间做了一个简单调用Google Map API的项目，因为之前没有接触过这些，所以在看了文档做出来之后自己稍微总结一下。 ","date":"2017-06-11","objectID":"/posts/2017-googlemap/:0:0","series":null,"tags":["Javascript"],"title":"调用Google Map Api实现自定义Google Map","uri":"/posts/2017-googlemap/"},{"categories":["Javascript"],"content":"加载 Google Maps JavaScript API 官方指导教程中写的引入的Google Map API是异步调用的，引入方式如下： \u003cscript\u003e var map; function initMap() { map = new google.maps.Map(document.getElementById('map'), { center: {lat: -34.397, lng: 150.644}, zoom: 8 }); } \u003c/script\u003e \u003cscript async defer src=\"https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY\u0026callback=initMap\"\u003e\u003c/script\u003e 这里需要注意一点官方提供是异步加载Google Maps JavaScript API，这样会让网站运行速率更高，但是这样会有一个问题，就是在自己写的js必须与引用在引入api之前，否则会报错。由于项目中js api只能在自己写的js的后面，所以只能使用同步的方式引入api js，引入方式如下： \u003cscript src=\"https://maps.googleapis.com/maps/api/js?key=yourkey\"\u003e\u003c/script\u003e 这里的key是通过申请成为谷歌开发者然后获取的密钥。 ","date":"2017-06-11","objectID":"/posts/2017-googlemap/:1:0","series":null,"tags":["Javascript"],"title":"调用Google Map Api实现自定义Google Map","uri":"/posts/2017-googlemap/"},{"categories":["Javascript"],"content":"创建地图对象 地图的 JavaScript 类是 Map 类。该类的对象定义页面上的单个地图。（创建该类的多个实例–每个对象都将定义页面上的一个不同地图。）我们利用 JavaScript new 运算符来新建该类。 //初次进入页面只显示首都不显示坐标，只定义地图 const map = new google.maps.Map(document.getElementById('map'), { center: capitalLatLng, zoom: mapZoom, maxZoom: mapMaxZoom, minZoom: mapMinZoom, //禁用街景地图 streetViewControl:false, mapTypeId: google.maps.MapTypeId.ROADMAP, //控制地图类型控件的位置 mapTypeControlOptions: { style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR, position: google.maps.ControlPosition.TOP_RIGHT }, }); center：设置地图初始化后中心点的位置，接受经纬度对象{lat: -25.363, lng: 131.044} zoom：地图初始化后的缩放比例 mapTypeId：设置地图类型，这里设置的就是普通的街道地图 mapTypeControlOptions：修改地图类型控件 谷歌地图默认会显示缩放控件（zoomControl），地图类型控件（mapTypeControl），街景小人（streetViewControl），全屏按钮（fullscreenControl，移动设备可见），除此之外还有旋转控件（rotateControl，默认情况下，该控件是否显示取决于给定地图类型在当前的缩放级别和位置上是否存在 45° 图像），比例控件（scaleControl，默认不显示）。但是有些时候可能需要调节他们的位置或者是否显示，可以通过相应的Options去控制，例如在上面初始化中，控制地图类型控件的位置。 ","date":"2017-06-11","objectID":"/posts/2017-googlemap/:2:0","series":null,"tags":["Javascript"],"title":"调用Google Map Api实现自定义Google Map","uri":"/posts/2017-googlemap/"},{"categories":["Javascript"],"content":"创建地图marker 我们在创建好地图后需要根据坐标去在地图中标注出相应的位置（marker对象），创建方式如下： //latlngArr为所地理位置数组 latlngArr.map((position, index) =\u003e { let marker = new google.maps.Marker({ position, zIndex: 0, map }); }); 其中map为前面所创建的地图，postion则为marker的坐标位置。 给marker添加事件 经常见到在点击marker出现弹窗，这个效果可以通过给marker添加点击事件 marker.addListener('click', function (e) { map.setZoom(mapMaxZoom); }); 这里实现了一个点击设置地图放大到最大的效果，这里需要多说一句，就是在对象中的熟悉是可以通过set去设置的。 *设置marker自动居中 当设置了多个marker在地图中后，会发现点击某个不在中心的marker后，它并不会自动居中，这一点很不友好，为了设置点击自动居中，需要添加如下代码： //map auto center const bounds = new google.maps.LatLngBounds(); latlngArr.map((position, index) =\u003e { let marker = new google.maps.Marker({ position, icon: notSelect, zIndex: 0, map }); bounds.extend(marker.position); }); map.fitBounds(bounds); map.panToBounds(bounds); 一个LatLngBounds实例表示地理坐标中的矩形，包括穿过180度纵向子午线在内的矩形 LatLngBounds类下的extend方法用于扩展这个边界以包含给定的点（marker） fitBounds设置视口包含给定的边界 *设置地图缩放自动调整 根据marker的分布自动调整地图缩放比例是很常见的交互，Google Map API提供了panToBounds方法用于根据给定的LatLngBounds绘制出包含最小边界的地图，所以在代码中只需要设置map.panToBounds(bounds)即可。 ","date":"2017-06-11","objectID":"/posts/2017-googlemap/:3:0","series":null,"tags":["Javascript"],"title":"调用Google Map Api实现自定义Google Map","uri":"/posts/2017-googlemap/"},{"categories":["Javascript"],"content":"总结 真心觉得Google的文档写的很好，而且Google Map的功能很强大，我在项目中只是使用了些简单的功能，更复杂功能请参考Google Map API：https://developers.google.com/maps/documentation/javascript/reference?csw=1 ","date":"2017-06-11","objectID":"/posts/2017-googlemap/:4:0","series":null,"tags":["Javascript"],"title":"调用Google Map Api实现自定义Google Map","uri":"/posts/2017-googlemap/"},{"categories":["Javascript"],"content":"前段时间有一个项目需要用一个前端分页，说实话之前自己从来没搞过，这次准备自己搞一下，所以先找了几篇文章看看怎么写，但是网上的文章写分页的都基本看不懂，完全不知所云，所以决定在自己搞定分页后写一下如何弄这个。 通过看网上的一些例子可以看出，分页基本上都是在html中写一个带id的元素，然后使用js动态添加的html的。 首先确定以下数据 总共的数据数——totalData 每页的要显示的数据——totalData 当超过多少页后分页中出现…——minPage 当前后都出现…后，当前页前后有几个分页块——interval 确定需要的html结构 \u003c!--1,2,3,4,5,6,7--\u003e \u003cdiv class=\"xm-pagenavi\"\u003e \u003ca class=\"prev disabled\" href=\"javascript:;\"\u003e\u0026lt;\u003c/a\u003e \u003ca class=\"btn current\" href=\"javascript:;\" data-page=\"1\"\u003e1\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"2\"\u003e2\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"3\"\u003e3\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"4\"\u003e4\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"5\"\u003e5\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"6\"\u003e6\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"7\"\u003e7\u003c/a\u003e \u003ca class=\"next\" href=\"javascript:;\"\u003e\u0026gt;\u003c/a\u003e \u003c/div\u003e \u003c!--\u003c 1,2,3,4,5,6,7...11 \u003e--\u003e \u003cdiv class=\"xm-pagenavi\"\u003e \u003ca class=\"prev disabled\" href=\"javascript:;\"\u003e\u0026lt;\u003c/a\u003e \u003ca class=\"btn current\" href=\"javascript:;\" data-page=\"1\"\u003e1\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"2\"\u003e2\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"3\"\u003e3\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"4\"\u003e4\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"5\"\u003e5\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"6\"\u003e6\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"7\"\u003e7\u003c/a\u003e \u003cb class=\"pn-break\"\u003e...\u003c/b\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"100\"\u003e100\u003c/a \u003e\u003ca class=\"next\" href=\"javascript:;\"\u003e\u0026gt;\u003c/a\u003e \u003c/div\u003e \u003c!--\u003c 1...4,5,6,7,8...11 \u003e--\u003e \u003cdiv class=\"xm-pagenavi\"\u003e \u003ca class=\"prev\" href=\"javascript:;\"\u003e\u0026lt;\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"1\"\u003e1\u003c/a\u003e \u003cb class=\"pn-break\"\u003e...\u003c/b\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"5\"\u003e5\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"6\"\u003e6\u003c/a\u003e \u003ca class=\"btn current\" href=\"javascript:;\" data-page=\"7\"\u003e7\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"8\"\u003e8\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"9\"\u003e9\u003c/a\u003e \u003cb class=\"pn-break\"\u003e...\u003c/b\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"100\"\u003e100\u003c/a\u003e \u003ca class=\"next\" href=\"javascript:;\"\u003e\u0026gt;\u003c/a\u003e \u003c/div\u003e \u003c!--\u003c 1...5,6,7,8,9,10,11 \u003e--\u003e \u003cdiv class=\"xm-pagenavi\"\u003e \u003ca class=\"prev\" href=\"javascript:;\"\u003e\u0026lt;\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"1\"\u003e1\u003c/a\u003e \u003cb class=\"pn-break\"\u003e...\u003c/b\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"94\"\u003e94\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"95\"\u003e95\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"96\"\u003e96\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"97\"\u003e97\u003c/a\u003e \u003ca class=\"btn current\" href=\"javascript:;\" data-page=\"98\"\u003e98\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"99\"\u003e99\u003c/a\u003e \u003ca class=\"btn\" href=\"javascript:;\" data-page=\"100\"\u003e100\u003c/a\u003e \u003ca class=\"next\" href=\"javascript:;\"\u003e\u0026gt;\u003c/a\u003e \u003c/div\u003e ","date":"2017-05-07","objectID":"/posts/2017-pagination/:0:0","series":null,"tags":["Javascript"],"title":"写一个简单的分页插件","uri":"/posts/2017-pagination/"},{"categories":["Javascript"],"content":"初始化页面 根据不同的总页数以及分页块最多有多少个，初始化为两种。 总页数少于分页块最多数时候，此时分页很简单，就是1,2,3,4,5,6这类的，此时只需要根据点击的分页块显示出对应的数据即可。 总页数多于分页快儿最多数的时候，此时候分页形式为\u003c 1,2,3,4,5,6,7...11 \u003e，此时还需要根据不同的当前页数，变换分页的形式。 所以初始化页面的代码如下： function initDraw() { let $pagenaviBox = $('\u003cdiv\u003e').addClass('xm-pagenavi'); $page.append($pagenaviBox); if (pageTotal \u003c= minPage) { $('\u003ca\u003e').addClass('prev disabled').attr('href', 'javascript:;').html('\u003c').appendTo($pagenaviBox); for (let i = 1; i \u003c= pageTotal; i++) { let $btnLink = $('\u003ca\u003e').addClass('btn').attr('href', 'javascript:;').attr('data-page', i).html(i).appendTo($pagenaviBox); if (i == 1) { $btnLink.addClass('current'); } } $('\u003ca\u003e').addClass('next').attr('href', 'javascript:;').html('\u003e').appendTo($pagenaviBox); } else { draw($pagenaviBox,1); } } ","date":"2017-05-07","objectID":"/posts/2017-pagination/:1:0","series":null,"tags":["Javascript"],"title":"写一个简单的分页插件","uri":"/posts/2017-pagination/"},{"categories":["Javascript"],"content":"根据当前页生成不同的html 这里的draw()用于根据不同的当前页生成\u003c 1,2,3,4,5,6,7...11 \u003e，\u003c 1...5,6,7,8,9,10,11 \u003e，\u003c 1...4,5,6,7,8...11 \u003e这三种形式的分页。 这里需要判断三种分页展示形式的变换临界点(项目中当前页前后分别有前后两页) 如果当前页往前三页的分页与第一页的距离为1，则展示为\u003c 1,2,3,4,5,6,7...11 \u003e 如果当前页往后三页的分页与最后一页的距离位1，则展示为\u003c 1...5,6,7,8,9,10,11 \u003e 除以上两种情况外的情况展示为\u003c 1...4,5,6,7,8...11 \u003e function draw(pagenaviBox,dataPage) { $('\u003ca\u003e').addClass('prev disabled').attr('href', 'javascript:;').html('\u003c').appendTo(pagenaviBox); $('\u003ca\u003e').addClass('btn').attr('href', 'javascript:;').attr('data-page', 1).html(1).appendTo(pagenaviBox); if (dataPage - 3 \u003c= 1 + 1) { // \u003c 1,2,3,4,5,6,7...11 \u003e for (let i = 2; i \u003c= minPage - 2; i++) { let $btn = $('\u003ca\u003e').addClass('btn').attr('href', 'javascript:;').attr('data-page', i).html(i).appendTo(pagenaviBox); } $('\u003cb\u003e').addClass('pn-break').html('...').appendTo(pagenaviBox); } else if (dataPage + 3 \u003e= pageTotal - 1) {// \u003c 1...5,6,7,8,9,10,11 \u003e $('\u003cb\u003e').addClass('pn-break').html('...').appendTo(pagenaviBox); for (let i = pageTotal - 6; i \u003c= pageTotal - 1; i++) { $('\u003ca\u003e').addClass('btn').attr('href', 'javascript:;').attr('data-page', i).html(i).appendTo(pagenaviBox); } } else {// \u003c 1...4,5,6,7,8...11 \u003e $('\u003cb\u003e').addClass('pn-break').html('...').appendTo(pagenaviBox); for (let i = dataPage - 2; i \u003c= dataPage + 2; i++) { $('\u003ca\u003e').addClass('btn').attr('href', 'javascript:;').attr('data-page', i).html(i).appendTo(pagenaviBox); } $('\u003cb\u003e').addClass('pn-break').html('...').appendTo(pagenaviBox); } $('\u003ca\u003e').addClass('btn').attr('href', 'javascript:;').attr('data-page', pageTotal).html(pageTotal).appendTo(pagenaviBox); $('\u003ca\u003e').addClass('next').attr('href', 'javascript:;').html('\u003e').appendTo(pagenaviBox); $('.btn').removeClass('current'); $('[data-page=\"' + dataPage + '\"]').addClass('current'); } ","date":"2017-05-07","objectID":"/posts/2017-pagination/:2:0","series":null,"tags":["Javascript"],"title":"写一个简单的分页插件","uri":"/posts/2017-pagination/"},{"categories":["Javascript"],"content":"添加点击事件 需要添加点击事件的有两类按钮，一类是分页按钮btn，一类是往前往后一页按钮prev，next按钮。 function btnClick() { let $pagenaviBox = $('.xm-pagenavi'); $pagenaviBox.on('click', function (e) { let $target = $(e.target); let targetClass = $target.attr('class'); // 根据不同的class定义不同的事件 if (targetClass == 'btn') { let dataPage = parseInt($target.attr('data-page')); if (pageTotal \u003c= minPage) { //1,2,3,4,5,6,7,8,9 $('.btn').removeClass('current'); $target.addClass('current'); } else { // 重新绘制 $pagenaviBox.empty(); draw($pagenaviBox,dataPage); } let $prev = $('.prev'); let $next = $('.next'); $prev.removeClass('disabled'); $next.removeClass('disabled'); if (dataPage == 1) { $prev.addClass('disabled'); } if (dataPage == pageTotal) { $next.addClass('disabled'); } } if (targetClass == 'prev') { let dataPage = parseInt($('.current').attr('data-page')) - 1; if (pageTotal \u003e minPage) { $pagenaviBox.empty(); draw($pagenaviBox,dataPage); }else{ $('.btn').removeClass('current'); $('[data-page=\"' + dataPage + '\"]').addClass('current'); } let $prev = $('.prev'); let $next = $('.next'); $prev.removeClass('disabled'); $next.removeClass('disabled'); if (dataPage == 1) { $prev.addClass('disabled'); } if (dataPage == pageTotal) { $next.addClass('disabled'); } } if (targetClass == 'next') { let dataPage = parseInt($('.current').attr('data-page')) + 1; if (pageTotal \u003e minPage) { $pagenaviBox.empty(); draw($pagenaviBox,dataPage); }else{ $('.btn').removeClass('current'); $('[data-page=\"' + dataPage + '\"]').addClass('current'); } let $prev = $('.prev'); let $next = $('.next'); $prev.removeClass('disabled'); $next.removeClass('disabled'); if (dataPage == 1) { $prev.addClass('disabled'); } if (dataPage == pageTotal) { $next.addClass('disabled'); } } }); } ","date":"2017-05-07","objectID":"/posts/2017-pagination/:3:0","series":null,"tags":["Javascript"],"title":"写一个简单的分页插件","uri":"/posts/2017-pagination/"},{"categories":["Javascript"],"content":"总结 经过这三步，基本就完成了一个非常简单的分页，在我开始自己写之前参考也曾经看了一些比较好的jquery插件的源码，但是感觉并没有找到思路，反而越看越乱，所以说呢…需要写一个东西，直接上手写是最好的，边写边想即可，如果一味的希望先找到思路，想好各个步骤再写，反正对我来讲，会让我越想越混乱。 最后附代码地址：https://github.com/MrZhang123/Js_Plugin/tree/master/page ","date":"2017-05-07","objectID":"/posts/2017-pagination/:4:0","series":null,"tags":["Javascript"],"title":"写一个简单的分页插件","uri":"/posts/2017-pagination/"},{"categories":["CSS"],"content":" 最近在写博客主题的时候发现一个很严重的问题，由于css的命名并不是很规范，导致自己在后期修改的时候很是头疼，有些样式需要在浏览器中打开开发者工具去找，很是无奈。所以决定在写完主题之后学习下CSS命名规范中大名鼎鼎的BEM命名规范。 ","date":"2017-04-05","objectID":"/posts/2017-cssbem/:0:0","series":null,"tags":["CSS"],"title":"理解CSS命名规范--BEM","uri":"/posts/2017-cssbem/"},{"categories":["CSS"],"content":"什么是BEM BEM其实是块（block）、元素（element）、修饰符（modifier）的缩写，利用不同的区块，功能以及样式来给元素命名。这三个部分使用__与--连接（这里用两个而不是一个是为了留下用于块儿的命名）。命名约定的模式如下： .block{} .block__element{} .block--modifier{} block 代表了更高级别的抽象或组件 block__element 代表 block 的后代，用于形成一个完整的 block 的整体 block--modifier代表 block 的不同状态或不同版本 上图很直观的反映出BEM的含义，block代表一个组，而element代表组里面的成员，而modifier，虽然在上图没有画出，但是可以知道这个则是用于描述每一个元素的具体的属性。可以看出范围在一步步缩小，使命名更加具体。 ","date":"2017-04-05","objectID":"/posts/2017-cssbem/:0:1","series":null,"tags":["CSS"],"title":"理解CSS命名规范--BEM","uri":"/posts/2017-cssbem/"},{"categories":["CSS"],"content":"BEM的优势 BEM的关键是光凭class名字就可以让其他开发者知道某个标记用来做什么的，明白各个模块之间的关系，例如如下的命名： .nav{} .nav__item{} .nav--blue{} .nav--item__hand{} 这几个class名很明显能看出各个块儿的作用，顶级快儿是nav，它有一些元素比如item，item又有一些属性，例如blue，但是如果写成常规的css就会很难看得出它们的关系： .nav{} .item{} .blue{} 虽然看每一个class名知道它们代表什么，但是却看不出它们之间的关系，这样对比，很明显能看出BEM命名的优势。 再看一个更具体的例子，如果写一个搜索模块，按照常规，我们会写出如下代码： \u003cform class=\"site-search full\"\u003e \u003cinput type=\"text\" class=\"field\"\u003e \u003cinput type=\"Submit\" value =\"Search\" class=\"button\"\u003e \u003c/form\u003e 但是如果时用BEM规范去写，代码如下： \u003cform class=\"site-search site-search--full\"\u003e \u003cinput type=\"text\" class=\"site-search__field\"\u003e \u003cinput type=\"Submit\" value =\"Search\" class=\"site-search__button\"\u003e \u003c/form\u003e 对比一下不难发现使用BEM可以使我们的代码可读性更高。 ","date":"2017-04-05","objectID":"/posts/2017-cssbem/:0:2","series":null,"tags":["CSS"],"title":"理解CSS命名规范--BEM","uri":"/posts/2017-cssbem/"},{"categories":["CSS"],"content":"BEM与SCSS 现在的开发很多时候都会用到SCSS，那么如果使用SCSS的嵌套写BEM规范呢，在SCSS中可以使用@at-root： .block { @at-root #{\u0026}__element { } @at-root #{\u0026}--modifier { } } /*生成的css*/ .block { } .block__element { } .block--modifier { } 非常的方便。 ","date":"2017-04-05","objectID":"/posts/2017-cssbem/:0:3","series":null,"tags":["CSS"],"title":"理解CSS命名规范--BEM","uri":"/posts/2017-cssbem/"},{"categories":["CSS"],"content":"最后 在自己的博客主题项目中，因为命名的随意导致后来再看样式的时候都需要通过开发者工具去看具体这部分是做什么的，非常难受，所以想到应该用一套规范约束一下命名，而BEM最为一个非常有用，强大的命名规范可以让我们的代码更容易阅读和理解，也更容易控制，虽然这种命名方式看起来有点儿奇怪，但是却非常有用，非常值得学习。 ","date":"2017-04-05","objectID":"/posts/2017-cssbem/:0:4","series":null,"tags":["CSS"],"title":"理解CSS命名规范--BEM","uri":"/posts/2017-cssbem/"},{"categories":["Blog"],"content":" 好长时间不写东西了，都在忙工作，去年三月份的时候我搞了一个hexo的博客，主题换过两三个吧，感觉都大部分的hexo主题都是东西比较多，有那么两三个比较简单的，但是自己并不是很喜欢，所以去年的时候就想着自己抽时间写一个自己的主题，但是当初看了几个hexo主题的源码，完全看不懂是什么，所以放弃了，今年又定了一个目标，写一个自己的hexo主题，终于终于在文章写一个自己的Hexo主题和该文中提到的作者自己写的主题hexo-showonne的启发下，开始了自己的hexo主题之旅，之后更参考自己用了很长时间的hexo主题——hexo-theme-icarus进行了修正。 我的博客就是用的我写的主题，博客地址：https://mrzhang123.github.io/ 项目地址：https://github.com/MrZhang123/hexo-theme-SpecLumn ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:0:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"搭建项目 参考大多数的hexo主题的目录结构不难发现，大部分都会有layout、source以及配置文件_config.yml，所以具体目录如下： ├── _config.yml #主题的配置文件 ├── layout #布局模版文件夹 │ ├── comment #评论相关模版 │ ├── common #公共的模版 │ │ └── post #post页相关模版 │ └── plugin #插件 ├── source #主题的css和js │ └── css │ └── images #主题中用到的图片 └── source_src #scss所在的文件夹 └── scss ├── code-style └── markdown-style 项目基于gulp搭建，hexo默认使用stylus，但是我使用的scss，然后生成css，但是在项目过程中发现一个问题（同时明白为什么hexo默认使用stylus,可以直接识别styl文件），hexo提供了hexo-config方法，可以读取_config.yml中的配置。所以如果想要在_config.yml中动态设置代码的高亮主题，可以在stylus中写如下代码： /* 一个三元表达式设置默认主题 然后在index.styl中设置引入的表达式 */ highlight = hexo-config(\"customize.highlight\") || \"tomorrow\" @import \"highlight/\" + highlight 但是我在项目中使用的是gulp-sass编译成的css文件，无法实现根据_config.yml动态的引入文件，所以准备下次改的时候直接换stylus（虽然hexo可以通过装插件识别scss，但是自己测试并未成功）。 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:1:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"布局 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:2:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"布局文件layout.ejs 在layout文件夹下，布局被写在layout.ejs中，由于hexo支持模块儿化布局，使用hexo提供的局部函数partial载入其他模版文件，配合ejs的语法，布局文件layout.ejs： \u003c%- partial('common/head') %\u003e \u003cdiv class=\"content\"\u003e \u003c%- partial('common/header') %\u003e \u003cdiv class=\"main\"\u003e \u003c%- body %\u003e \u003c/div\u003e \u003c/div\u003e \u003c%- partial('common/footer') %\u003e \u003c%- partial('common/foot') %\u003e \u003c/body\u003e \u003c/html\u003e hexo默认使用ejs语法，但是可以通过安装插件使用Haml和Jade（Jade以前看过，并不喜欢缩进的写法，所以在开发工程中也没用使用同样使用缩进语法的stylus）。 项目中直接使用了ejs，所以这里简要列一下ejs中tag的使用： \u003c%' 脚本标签，用于控制流程，不会输出 \u003c%= 将转义的值输出到模版 \u003c%- 将未转义的值输出到模版 \u003c%# 注释标签 \u003c%% 输出 ‘\u003c%’ %\u003e 闭合标签 -%\u003e Trim-mode (‘newline slurp’) 标签, 移除随后的换行符 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:2:1","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"其他模版 Url Description Layout / 首页 index.ejs /yyyy/mm/dd/:title/ 文章 post.ejs /archives/ 归档 archive.ejs /tags/:tagname/ 某个标签的归档 tag.ejs /:else/ 其他 page.ejs 在我的主题中只有主页index.ejs，文章页post.ejs。 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:2:2","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"变量 模版中获取文章，调用配置项等会使用到变量，hexo提供了很多变量供我们使用（hexo提供的变量），其中比较重要的有： page：针对该页面的内容以及 front-matter 所设定的变量 config：网站配置（hexo的_config.yml） theme：主题配置（theme的_config.yml） url：当前页面的完整网址 path：当前页面的路径（不含根路径） 另外在参看主题hexo-theme-icarus的源码发现一些变量的使用，但是我在官方文档中并没有找到。 post.title：文章的题目 post.excerpt：文章的摘要，即写文章的时候``之上的那段儿，首页显示 post.comments：评论模块 post.photots：文章中插入的图片 post.content：文章内容 post.date：文章的时间 以上均获取的是hexo生成的markdown文件中的配置。 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:3:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"辅助函数 在hexo中同样提供了很多辅助函数方便在博客主题中使用，但是同样很多都用不着，常用的有： url_for：输出路径 partial：载入其他模版文件 css：载入css文件 js：载入js文件 data_xml：插入 XML 格式的日期 paginator：生成分页，其中可以插入配置，partial一样，例如改变上一页下一页的文字，可以配置{ prev_text: '« 上一页', next_text: '下一页 »'} 关于partical需要注意几点 它可以添变量，在被引用文件直接可以饮用，例如： /*引用*/ \u003c%- partial('plugin/scripts', { isHead: true }) %\u003e /*被引用文件判断*/ \u003c% if (typeof(isHead) !== 'undefined' \u0026\u0026 isHead) { %\u003e \u003c% } %\u003e 可以添加class名字 \u003c%- partial('post/date', { class_name: 'article-date', date_format: null }) %\u003e ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:4:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"其他 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:5:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"评论 hexo中添加评论只需要在ejs中添加相应的script标签插入代码即可，以前的时候用多说，现在多说要关闭了，准备换个，但是找来找去没找到一个比较适合的，同事介绍有一个叫来必力的还不错，试用确实觉得可以，可以替代多说，所以推荐一下。官方网站。 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:5:1","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"代码高亮 代码高亮其实就是引入一段css的代码，为了实现可以通过配置文件动态引入，就需要配合hexo-config，前面已经提到过，这里不再重复。 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:5:2","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"最后 最后写一点自己的想法，说实话，hexo的官方文档，实在是烂的没话可说，跟webpack1的文档不相上下，估计连作者自己都不一定看得懂，所以要想自己写一个主题的同学们还是在github参考一下写的比较好的主题的源码吧。 另外，当前这个版本功能相对简单一点儿而且在后期的修改过程中发现用scss确实不如直接用stylus方便一些，所以准备在以后改用stylus。 ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:6:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Blog"],"content":"参考 hexo-theme-icarus 写一个自己的Hexo主题 hexo-showonne ","date":"2017-04-01","objectID":"/posts/2017-hexotheme/:7:0","series":null,"tags":["Blog"],"title":"如何写一个自己的hexo主题","uri":"/posts/2017-hexotheme/"},{"categories":["Git"],"content":" 前几天在公司合代码的时候出现了问题，需要reset回去，在同事的帮助下利用git的log进行了reset，虽然很简单，但是还是想记录一下。 ","date":"2017-03-04","objectID":"/posts/2017-gitreset/:0:0","series":null,"tags":["Git"],"title":"使用git回退远程库代码","uri":"/posts/2017-gitreset/"},{"categories":["Git"],"content":"本地代码回滚 首先需要使用git log查看需要回退的hash码，但是因为是多人合作，所以我在gitlab中切换到自己的分支，然后在Graphs-\u003eNetwork中查看树桩gitlog图，在其中有每一次git操作的hash码，如果想回退到某个git操作，只需要进行如下操作： $ git reset --hard \"commit id\" 即可回退到当前提交，这次提交之后的所有提交的log也会随着回退而全部消失。 但是这样的回退只是本地代码回退，远程代码库依然是已经更新过的，接下来需要让远程代码库更新。 ","date":"2017-03-04","objectID":"/posts/2017-gitreset/:1:0","series":null,"tags":["Git"],"title":"使用git回退远程库代码","uri":"/posts/2017-gitreset/"},{"categories":["Git"],"content":"reset \u0026 revert 在git的命令中，这两个命令都是回退，不同的在于，reset在回退后，回退点之前的记录也会被清空，但是revert会保留，所以回退的时候使用哪一个可以自己选择。 这里有两个命令需要区别一下， ","date":"2017-03-04","objectID":"/posts/2017-gitreset/:1:1","series":null,"tags":["Git"],"title":"使用git回退远程库代码","uri":"/posts/2017-gitreset/"},{"categories":["Git"],"content":"更新远程代码库 因为reset之后本地库落后于远程库一个版本，因此需要强制提交。 $ git push origin master -f 这里的-f可以强制将本地代码库提交到远程。 ","date":"2017-03-04","objectID":"/posts/2017-gitreset/:2:0","series":null,"tags":["Git"],"title":"使用git回退远程库代码","uri":"/posts/2017-gitreset/"},{"categories":["Webpack"],"content":" 本篇为在学习Vue2.x的时候使用Webpack2.x的踩坑与总结，关于Vue2.x的踩坑与总结，点击链接 项目地址：https://github.com/MrZhang123/Vue_project/tree/master/vue2.x 本地安装npm包后如何在命令行运行 在npm安装包的时候，如果使用全局安装，即npm install \u003cpackageName\u003e -g，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包npm install --save-dev \u003cpackageName\u003e，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行： $ node_modules/.bin/\u003cpackageName\u003e 除了可以这样在命令行运行外，还可以在文件中运行 //index.js let webpack = require('webpack'); webpack(); $ node index.js webpack1.x升级2.x ","date":"2017-02-07","objectID":"/posts/2017-webpack/:0:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"1.module.loaders改成了module.rules 旧的loaders被新的rules取代，后者允许配置loader以及其他更多项。 module: { - loaders: [ + rules: [ { test: /\\.css$/, - loaders: [ + use: [ { loader: \"style-loader\" }, { loader: \"css-loader\", - query: { + options: { modules: true } ] }, { test: /\\.jsx$/, loader: \"babel-loader\", // Do not use \"use\" here options: { // ... } } ] } 以上写法中，Rule.loader是Rule.use: [ { loader } ]的简写。 ","date":"2017-02-07","objectID":"/posts/2017-webpack/:1:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"2.链式调用loaders 在webpack1.x中loaders可以链式调用，在2.x中依旧有该特性，使用rule.use配置项，use中设置一个loaders的数组而在1.x中使用!连接各个loader，旧版写法只有在使用旧的module.loaders时有效。 module: { - loaders: { + rules: { test: /\\.less$/, - loader: \"style-loader!css-loader!less-loader\" + use: [ + \"style-loader\", + \"css-loader\", + \"less-loader\" + ] } } ","date":"2017-02-07","objectID":"/posts/2017-webpack/:2:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"3.取消在模块中自动添加-loader后缀 webpack2.x中不再添加-loader module: { rules: [ { use: [ - \"style\", + \"style-loader\", - \"css\", + \"css-loader\", - \"less\", + \"less-loader\", ] } ] } 根据官方说法，做出这样更改的原因是省略-loader会对新手造成误解，所以去掉这个功能，如果想打开这个旧的功能，可以配置resolveLoader.moduleExtensions，但是并不推荐这么做，具体参阅issues#2986 + resolveLoader: { + moduleExtensions: [\"-loader\"] + } ","date":"2017-02-07","objectID":"/posts/2017-webpack/:3:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"4.使用options配置loader 在webpack1.x中可以通过webpack.config.js的自定义属性来配置loader，这在webpack2.x中无法执行 module.exports = { ... module: { use: [{ test: /\\.tsx?$/, loader: 'ts-loader' }] }, // does not work with webpack 2 ts: { transpileOnly: false } } //webpack2 use options module.exports = { ... module: { use: [{ test: /\\.tsx?$/, loader: 'ts-loader' options: { transpileOnly: false } }] } } webpack插件的使用 ","date":"2017-02-07","objectID":"/posts/2017-webpack/:4:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"webpack-dev-server1.x升级2.x 1.在CLI使用的时候，–inline默认开启，无需在输入命令时添加 2.删除contentBase用proxy代替 3.减少控制台无用输出，在1.x中，当我们停掉服务器后，控制台会一直输出错误信息，但是在2.x中只会输出[WDS] Disconnected! ","date":"2017-02-07","objectID":"/posts/2017-webpack/:5:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"extract-text-webpack-plugin 在使用webpack将vue_spa打包后，并不会出现css，因为css被打包入build.js，如果从vue组件中抽离出css，需要安装插件extract-text-webpack-plugin，在使用的时候需要配合v2版本的才可以使用（如果使用了webpack2，则对应的插件版本都需要用v2版本）。具体配置如下： module:{ rules:[ { test: /\\.vue$/, loader: 'vue', options: { loaders:{ css: extractTextPlugin.extract({ loader: 'css-loader', fallbackLoader: 'vue-style-loader' }) } } } ] }, plugins: [ new webpack.HotModuleReplacementPlugin(), new extractTextPlugin({ filename:'/style.css', allChunks:true }) ], 在options中： options.loader: string | object | loader[] (必填项) 这里的 loader(s) 用于将资源转换为css导出模块 options.fallbackLoader: string | object | loader[] 当css没有被导出的时候这里的 loader(s) 会被使用 （即当在plugins模块中设置allChunks:false的时候） 在plugins中： filename：可以设置被导出的css文件的路径以及名字 allChunks：从所有附加块中提取（默认情况下，它只从初始块中提取） ","date":"2017-02-07","objectID":"/posts/2017-webpack/:6:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"html-webpack-plugin plugins: [ new htmlWwebpackPlugin({ filename: 'assets/admin.html' }), ] title：用于生成文档的document filename：要注入的html文件，默认为index.html。可以自定义（例如：assets/admin.html） inject： true | ‘head’ | ‘body’ | false 将资源注入所给的template或templateContent，当设置为 true 或者 ‘body’，所有的资源会被注入到body底部。而head则会将js放到headelement favicon: 在输出的html中添加favicon hash: true | false 如果为true，则将一个唯一的webpack编译散列附加到所有包含的脚本和CSS文件。这对缓存清除很有用。 cache: true | false 如果为true（默认），尝试仅在更改后才发出文件。 ","date":"2017-02-07","objectID":"/posts/2017-webpack/:7:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"是否要更换preset？ webpack2.x默认支持es6的模块，所以在编译时候没有必要将它们先转换为CommonJS模块再处理，所以在github中出现了babel-preset-es2015-webpack，但是这个模块我在使用的时候出现了Cannot remove 'babel-plugin-transform-es2015-modules-commonjs' from the plugin list.的问题，根据babel-preset-es2015-webpack中的叙述以及issues#14可知，babel-preset-es2015已经支持不转换模块中的import和export，只需要设置.babelrc { \"presets\": [ [ \"es2015\", { \"modules\": false } ] ] } ","date":"2017-02-07","objectID":"/posts/2017-webpack/:8:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Webpack"],"content":"使用CommonsChunkPlugin将第三方库单独打包 很多情况下我们会引入第三方库，但是默认情况下，webpack会将第三方库与我们自己写的js一起打包进生成文件中，为了让第三方库与我们自己写的js分开，webpack2.x内置一个插件CommonsChunkPlugin，它可以让webpack在打包的时候将我们自己写的js与第三方库分开，具体用法如下： entry:{ app: './src/main.js', vendor: [ 'lodash', 'axios', 'vue', 'vue-router' ] }, output: { path: path.resolve(__dirname + '/dist'), publicPath: '/dist', filename: '[name].js' }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name:'vendor' }) ] 这里需要注意一点，这里在在输出的时候需要使用filename: '[name].js'，否则会报错。 参考： 从 webpack v1 迁移到 webpack v2 What’s new in webpack dev server 2.0 ","date":"2017-02-07","objectID":"/posts/2017-webpack/:9:0","series":null,"tags":["Webpack"],"title":"Webpack2.x踩坑与总结","uri":"/posts/2017-webpack/"},{"categories":["Vue"],"content":" 年前就打算学习并总结一下vue2.x，但是因为年前工作比较多，所以进展十分缓慢，现在终于学了一大部分，而且自己在学习开发中也踩了不少坑也总结了不少，所以将自己踩过的坑总结一下分享出来。因为在项目中使用了webpack2.x，所以对于webpack2.x也有一个踩坑总结，点击链接。 项目地址：https://github.com/MrZhang123/Vue_project/tree/master/vue2.x vue2.x ","date":"2017-02-07","objectID":"/posts/2017-vue/:0:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"1.独立构建vs运行时构建 在按照vue1.0的配置配置好webpack后，会出现Failed to mount component: template or render function not defined. (found in root instance) 的错误，这里涉及到vue2.0与vue1.0的第一个不同的地方。具体区别独立构建 vs 运行时构建。解决方法为在webpack配置文件中添加如下配置项： resolve: { alias: { 'vue$': 'vue/dist/vue.common.js' } } ","date":"2017-02-07","objectID":"/posts/2017-vue/:1:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"2.挂载点的选择 在原来的vue1.0的项目中我使用body元素作为挂载点，但是在vue2.0中，如果使用body或者html作为挂载点，则会报以下警告：Do not mount Vue to \u003chtml\u003e or \u003cbody\u003e - mount to normal elements instead. 在vue1.0中允许开发者以body或者html作为根实体的挂载点，但是到了2.0后，只能通过独立的节点挂载，例如：div等，否则报警告 ","date":"2017-02-07","objectID":"/posts/2017-vue/:2:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"3.动态组件渲染（跟1.x类似） 多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 元素，动态地绑定到它的 is 特性： \u003c!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --\u003e \u003ccomponent :is=\"componentId\"\u003e\u003c/component\u003e \u003c!-- 也能够渲染注册过的组件或 prop 传入的组件 --\u003e \u003ccomponent :is=\"$options.components.child\"\u003e\u003c/component\u003e ","date":"2017-02-07","objectID":"/posts/2017-vue/:3:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"keep-alive 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数： \u003ckeep-alive\u003e \u003ccomponent :is=\"currentView\"\u003e \u003c!-- 非活动组件将被缓存！ --\u003e \u003c/component\u003e \u003c/keep-alive\u003e ","date":"2017-02-07","objectID":"/posts/2017-vue/:3:1","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"4.ref 有时候需要直接在父组件中访问子组件实例，或者直接操作DOM元素，此时需要使用ref。 ref被用来给元素或子元素注册引用信息。引用信息会根据父组件的$refs对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素，如果用在子组件上，引用信息就是组件实例。 \u003c!-- vm.$refs.p will be the DOM node --\u003e \u003cp ref=\"p\"\u003ehello\u003c/p\u003e \u003c!-- vm.$refs.child will be the child comp instance --\u003e \u003cchild-comp ref=\"child\"\u003e\u003c/child-comp\u003e 当 v-for 用于元素或组件的时候，引用信息将是包含DOM节点或组件实例数组。 关于ref注册时间的重要说明: 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模版中做数据绑定。 ","date":"2017-02-07","objectID":"/posts/2017-vue/:4:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"5.自定义事件 在vue自定义事件使用$on与$emit，前者用于触发监听，后者用于触发，监听可以有两种方式 \u003c!--使用v-on在html中监听--\u003e \u003cmy-component v-on:test=\"callbackFun\"\u003e\u003c/my-component\u003e \u003cscript\u003e //直接用$on监听 vm.$on('text',function(){}) \u003c/script\u003e ","date":"2017-02-07","objectID":"/posts/2017-vue/:5:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"6.组件命名的约定 当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase // 在组件定义中 components: { // 使用 kebab-case 形式注册 'kebab-cased-component': { /* ... */ }, // register using camelCase 'camelCasedComponent': { /* ... */ }, // register using TitleCase 'TitleCasedComponent': { /* ... */ } } 在 HTML 模版中，只能使用 kebab-case 形式： \u003c!-- 在HTML模版中始终使用 kebab-case --\u003e \u003ckebab-cased-component\u003e\u003c/kebab-cased-component\u003e \u003ccamel-cased-component\u003e\u003c/camel-cased-component\u003e \u003ctitle-cased-component\u003e\u003c/title-cased-component\u003e 当使用字符串模式时可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用： \u003c!-- 在字符串模版中可以用任何你喜欢的方式! --\u003e \u003cmy-component\u003e\u003c/my-component\u003e \u003cmyComponent\u003e\u003c/myComponent\u003e \u003cMyComponent\u003e\u003c/MyComponent\u003e ","date":"2017-02-07","objectID":"/posts/2017-vue/:6:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"7.子组件中使用this 有时候子组件简单，可以在父组件中直接注册，此时在子组件内使用this就是子组件实例并不是父组件，例如： export default{ data(){ return{ parentMsg:'hello!' } }, components:{ child:{ props:['inputMessage'], template:'\u003cspan\u003e{{inputMessage}}\u003c/span\u003e' }, 'child-secound':{ props:['inputMessage'], template:'\u003cspan\u003e{{upperCase}}\u003c/span\u003e', computed:{ upperCase(){ return this.inputMessage.toUpperCase(); } } } } } ","date":"2017-02-07","objectID":"/posts/2017-vue/:7:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"8.key的使用 一般情况下，vue在渲染完成后，如果数据发生变化，只会重新渲染数据，不会重新渲染整个元素，但是有时候我们需要元素被重新渲染，此时就需要使用key关键字，使用v-bind绑定key关键字，可以实现在数据发生变化时候重新渲染整个元素。**注：**同一父级元素下所有子元素如果都要在数据变化后重新渲染元素，则需要被绑定的key ","date":"2017-02-07","objectID":"/posts/2017-vue/:8:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"9.v-move的使用 在使用\u003ctransition-group\u003e时候，不仅可以定义进入离开动画，还可以使用新增的v-move特性，与过渡一样，默认为v-move，可以用name进行自定义前缀，也可以用move-class属性手动设定。用了这个之后就可以实现移动过程中的动画。 ","date":"2017-02-07","objectID":"/posts/2017-vue/:9:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"10.跳过css检测 对于只使用js过度的元素使用v-bind:css=\"false\"跳过vue对css的检测。 ","date":"2017-02-07","objectID":"/posts/2017-vue/:10:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"render函数的使用 createElement接受三个参数： {String | Object | Function}即一个HTML标签 | 组件选项 | 一个函数，必须返回上述其中一个 {Object}一个对应HTML标签属性的数据对象（可选） {String | Array}子节点（VNode）（可选） ⚠️ 关于第三个参数的说明 createElement第三个参数，如果是String，则类似于innerHTML，如果是Array，则可以写入一个执行函数，这个函数用于创建另一个DOM结构（而且这里如果想写入一个执行函数，必须是数组！！） 每个createElement只能创建一个元素，所以如果是创建多个元素相互嵌套，需要多个createElement函数相互嵌套，最后再render，这个跟原生js创建DOM元素类似 如果需要同时渲染多个元素，则需要在第三个参数的数组中，分别写入需要渲染的元素，此时Vue会按照数组中顺序进行渲染 完整数据对象： { // 和`v-bind:class`一样的 API 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API style: { color: 'red', fontSize: '14px' }, // 正常的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 \"on\" // 所以不再支持如 v-on:keyup.enter 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令. 注意事项：不能对绑定的旧值设值 // Vue 会为您持续追踨 directives: [ { name: 'my-custom-directive', value: '2' expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // Scoped slots in the form of // { name: props =\u003e VNode | Array\u003cVNode\u003e } scopedSlots: { default: props =\u003e h('span', props.text) }, // 如果子组件有定义 slot 的名称 slot: 'name-of-slot' // 其他特殊顶层属性 key: 'myKey', ref: 'myRef' } vue-router2.x ","date":"2017-02-07","objectID":"/posts/2017-vue/:11:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"1.router-view 在vue-router2中\u003crouter-view\u003e是最顶层的出口，渲染最高级路由匹配到组件。同样地，一个被渲染组件同样可以包含自己的嵌套\u003crouter-view\u003e。 ","date":"2017-02-07","objectID":"/posts/2017-vue/:12:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"2.挂载 在router1.0中，挂载节点的方式为router.start()而在router2.0中使用vue自己的$mount手动挂载 ","date":"2017-02-07","objectID":"/posts/2017-vue/:13:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"3.给link添加事件 在vue-router1中使用v-link写入路由，但是在vue-router2中要使用router-link写入路由，在浏览器渲染的时候会把router-link渲染成a。 有时候需要为router-link注册事件，对于一般的html元素，直接使用@click=\"eventFun\"即可，但是对于router-link，像普通html元素那样注册事件后并不管用，需要添加.native才会成功注册。 事实上给组件绑定原生事件就需要.native修饰v-on，否则无法注册成功。 \u003cmy-component v-on:click.native=\"doTheThing\"\u003e\u003c/my-component\u003e ","date":"2017-02-07","objectID":"/posts/2017-vue/:14:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"4.利用vue-router做导航 在利用vue-router做导航的时候，需要用到redirect关键字的重定向功能，具体写法如下： const router = new VueRouter({ routes : [ {path:'/',redirect:'/ZY'}, {path:'/ZY',component:ZY} ] }); ","date":"2017-02-07","objectID":"/posts/2017-vue/:15:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Vue"],"content":"5.路由嵌套 vue-router的路由嵌套指的是子组件会在父组件中渲染出来，必须是子组件的父组件，祖先不可以实现，例如： /user/foo/profile /user/foo/posts +------------------+ +-----------------+ | User | | User | | +--------------+ | | +-------------+ | | | Profile | | +------------\u003e | | Posts | | | | | | | | | | | +--------------+ | | +-------------+ | +------------------+ +-----------------+ 参考： Vue.js官方文档 vue-router 2官方文档 ","date":"2017-02-07","objectID":"/posts/2017-vue/:16:0","series":null,"tags":["Vue"],"title":"Vue2.x踩坑与总结","uri":"/posts/2017-vue/"},{"categories":["Javascript"],"content":" 以前在面试的时候经常遇到问关于跨域的事儿，所以自己对跨域有一定的概念性了解，知道什么是跨域以及解决跨域的方法，但是具体实际从来没有操作过，直到最近在公司项目中，遇到了一个需要使iframe跨域进行POST提交的实际案例，我才明白具体如何使用iframe进行跨域操作。 说到跨域，就不得不提起浏览器的同源策略。 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。 ","date":"2017-01-06","objectID":"/posts/2017-iframepost/:0:0","series":null,"tags":["Javascript"],"title":"iframe跨域POST提交","uri":"/posts/2017-iframepost/"},{"categories":["Javascript"],"content":"源 如果协议，端口（如果指定了一个）和主机对于两个页面是相同的，那么这两个页面就具有相同的源。 从这个定义可以看出，如果两个页面的协议，端口，主机三个只要有一个不一样，就是不同的源，想要相互之间进行交互，就需要进行跨域。 ","date":"2017-01-06","objectID":"/posts/2017-iframepost/:1:0","series":null,"tags":["Javascript"],"title":"iframe跨域POST提交","uri":"/posts/2017-iframepost/"},{"categories":["Javascript"],"content":"iframe跨域POST无刷新提交 跨域的方法有很多，像JSONP、iframe、CORS、postMessage等等，由于项目中用到了iframe进行POST跨域，所以本文主要总结一下如何利用iframe进行POST无刷新提交。 我们知道一般提交使用form表单进行提交，但是这种提交会导致页面跳转，所以交互效果不是友好，为了实现无刷新提交，我们会使用Ajax，但是此时可能会出现一个问题—-跨域，那么如何解决这个问题呢，可以使用一个隐藏的iframe，我们将要提交的数据提交到这个隐藏的iframe，然后让这个iframe去跳转，这样就可以在视觉上实现页面无跳转刷新（实际上页面还是跳转了，只是iframe被隐藏，我们看不到）。 在提交后我们还要获取到后台给我们返回回来的数据，所以需要在iframe中进行数据的交互同时拿到返回回来的data。 为了让数据可以顺利的进行数据交互，我们通常使用document.domain将域设置到顶级域。 为了拿到返回回来的data，需要使用一个函数，函数名后台已经告知。 ","date":"2017-01-06","objectID":"/posts/2017-iframepost/:2:0","series":null,"tags":["Javascript"],"title":"iframe跨域POST提交","uri":"/posts/2017-iframepost/"},{"categories":["Javascript"],"content":"附实现代码 \u003cform action=\"You POST Link\" method=\"post\" target=\"target\" id=\"J_commenting\"\u003e \u003cselect name=\"category\" class=\"select J_filter\" id=\"J_typeFilter\"\u003e \u003coption value=\"0\" selected=\"selected\"\u003eSelect Category\u003c/option\u003e \u003coption value=\"1\"\u003eLife\u003c/option\u003e \u003coption value=\"2\"\u003ePeople\u003c/option\u003e \u003coption value=\"3\"\u003eLandscape\u003c/option\u003e \u003coption value=\"4\"\u003eTech\u003c/option\u003e \u003coption value=\"5\"\u003eOthers\u003c/option\u003e \u003c/select\u003e \u003cinput name=\"title\" type=\"text\" class=\"misstion-title J_misstion-title\"\u003e \u003ctextarea name=\"desc\" class=\"misstion-description J_description\" maxlength=\"200\"\u003e\u003c/textarea\u003e \u003cbutton class=\"button J_button\" type=\"submit\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003ciframe name=\"target\" style=\"display:none;\"\u003e\u003c/iframe\u003e var $button = $('.J_button'); var $commenting = $('#J_commenting'); var $filter = $('.J_filter'); var $misstionTitle = $('.J_misstion-title'); var $description = $('.J_description'); $button.on('click', function () { var filterValue = $filter.val(); var misstionTitleValue = $misstionTitle.val(); var descriptionValue = $description.val(); if (filterValue === '0' || misstionTitleValue === '' || descriptionValue === '') { alert('Check if you filled out all the fields required'); } else { $commenting.submit(); } }); $commenting.on('submit', function () { document.domain = 'aa.com'; window.addData = function (data) { var dataCode = data.code; var dataMsg = data.message; if (dataCode === 0) { alert('submit success!'); } else { alert('submit failed!'); } } }); 点击提交后，后台返回的数据： document.domain = \"aa.com\"; var data = {\"code\":-2,\"info\":\"please login first\",\"message\":\"please login first\"}; if( typeof(parent.window['addData']) == \"function\"){ parent.window['addData'](data); }else if( typeof(window.top['addData']) == \"function\"){ window.top['addData'](data); } ","date":"2017-01-06","objectID":"/posts/2017-iframepost/:3:0","series":null,"tags":["Javascript"],"title":"iframe跨域POST提交","uri":"/posts/2017-iframepost/"},{"categories":["年终总结"],"content":" 今天是2016年12月31日，2016年的最后一天，记得那天组长让组里面每个成员做年终总结，自己想了想，真心不知道该说什么，因为其实自己来到小米的时间并不长，做的东西也不多，所以需要总结的东西很少。但是其实今年对于我个人来说，2016年是难忘的一年，发生了很多事情，值得我去回忆，去思考，但是，让我铭记的也许只有这两件：离开，开始新的生活。 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:0:0","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"回望2016 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:1:0","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"人生中的第一次跳槽 2016年的9月26日星期一，我来到小米报到，完成了我人生中的第一次跳槽。  记得今年年初的时候，我初六来到公司，拿到了开工红包，开始了2016的一年的工作，那时候并没有想到，自己会在未来的几个月中，开始尝试的去找工作，去想着换一家公司。因为在原公司待着感激并没有什么前途，同时也觉得自己在工作中，并不是那么开心，所以在今年6月底开始尝试的去找工作，但是其实自己并没有说想着必须离开这里，只是那时候自己觉得当时在的那家公司虽然说自己本身的技术并不会在工作中有多大的提升，但是因为并不是很忙，所以自己支配的时间也比较多，同时也是为了检验一下自己的技术到底有多少提升，所以就偶尔会投几家公司，然后去跟面试官当面较量，从而让我知道自己在哪方面还有所欠缺。所以从6月底开始一直到9月都在陆陆续续的面试，虽然时间长，但是面试并不多，因为其间我动摇过，曾经自己也告诉自己，其实公司挺不错的，感觉在这里也会被领导重视，在这里可以做一些我想做的，比如曾经公司CTO还让自己给大家讲vue，同时记得那时候CTO找我们每一个技术谈话，跟我说，把学到的东西都去用，当时非常高兴觉得自己在公司很受重视，所以决定留下来。  但是后来自己在公司的非常好的朋友因为身体不舒服请假了，在这其间，我开始了一个人中午吃饭，其实现在回想起来，到底那时候是我自己不主动跟别人说话，还是别人确实也不搭理我，我不知道，但是确实后来自己在公司开始不再说话，每天听着音乐，做着我自己喜欢做的事儿（因为那时候我也没什么工作需要做），那时候真的是感觉，一副耳机，几首曲子，一个项目，整个世界。就这样我在公司待到九月初，那小子回来了，终于有个能聊到一起的了。  记得我是9月8日的时候，我去小米面试，那时候其实没有想的自己能过，自己把自己做过的讲了一些，然后等待晚上的回复，那天下午等的非常焦急，我想去，但是也不知道自己表现怎么样，那天晚上等到7点多的时候还没电话，感觉可能没戏了，但是在7点30左右的时候hr打电话过来，告诉我过了，我当时真的非常高兴。第二天下午，公司要去组织去团建，可以说这次团建让我彻底决定，我要走了，这里并不适合我，俗话说：道不同，不相与谋。所以在收到offer的那一刻，我立马提离职，随后在一周之内办理离职，成功在2016年6月26日，来到小米，开始我在兔厂的工作生涯… ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:1:1","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"新的环境，新的伙伴 来到小米，开始新的工作，一切都是陌生的，一切从头开始，但是既然选择了，就不会害怕。  这里给我的第一印象是，大家每一个人都在认真工作，每一个人各司其职，认真做自己的事儿，没有一个闲逛的人，大家都在努力的为公司出自己的一份力。在随后的时间里，我发现大家对自己公司的产品可以说是非常的欣赏（事实上产品确实非常优秀），都在为做出最酷的产品而一起奋斗，在年终总结的时候，我们组的一个同学也说，自己当初来小米，就是因为看到这里是一个可以认真做事儿地方。这一点让我非常欣赏，也非常感动，我也感觉这里才是真正做事情的地方。  在今年10月25日，小米发布了让世人惊艳的概念机—-小米MIX，在发布会期间，雷总讲到开发这款手机当时是多么的艰难，随后是如何克服困难，一步步做出来的。当你看到这款手机，你会为之而感到惊艳，但是其背后的艰难又有多少人而得知呢？回头看看我的团队，他们每一个人，说真的在我刚来的时候，我并没有感觉他们有多厉害，因为他们并不是那么爱炫耀，也不喜欢到处去宣讲东西，但是在后来我发现他们各个都是高手，只是我不了解而已。所以在这里，我感受到的另一点，我想也是这个企业的企业文化之一吧—-厚积而薄发。我们做什么事情，并不需要别人知道，做出来的成绩，也不会到处去宣扬，告诉别人，这是我们做的，你看看，多么牛逼，我们做的，只是我们该做的，仅此而已。  记得在11月初的时候，看过一个关于雷总的一篇报道，雷总说自己从1989年开始创业，如果是第一次创业，早就买十几辆跑车了，但是自己并没有很着走，也没有自我膨胀，大家觉得他很成功，而自己觉得自己不算很成功。看到这句话，我真的感觉到，有这样的老板，公司何愁不上市？而雷总的这种想法，做法也深深的影响着这里的每一位员工，这一点让我非常欣赏。  团队里的每一个人都非常热心，大家经常互帮互助，一起工作，一起玩儿，这才是我理想的地方，这才是我理想中的团队，在这里我感觉到非常的开心。 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:1:2","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"其他一些事儿 参加活动  在2016年我参加的技术活动可以说非常多，但是渐渐的我发现，其实在这些免费活动中，真正有质量的技术活动并不多，而且讲的东西都是非常流行的一些框架什么的，大部分活动可以说是出去宣传自己的公司了，所以后来我索性就不指望能学到些什么，就是参加一些活动，认识一些人，扩大自己的圈子吧，所以在2016年，自己在技术方面的圈子可以说是有所扩大，也算是一种收获吧。 开始去记录一些东西  在2016年，我自己弄了一个博客，其实初衷是记录一些自己学到技术吧，但是后来因为是自己的，所以其实写什么随意啦，所以开始写一些总结，写一些自己的想法，也算是记录，为给以后的自己看吧，哈哈… ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:1:3","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"展望2017  现在是2016年12月31日23:07分，2017年马上就要到来，对于即将到来的2017年，可以说是充满期待，感觉在接下来的一年中会有很多新的好玩儿的事情发生，对自己的2017有以下几点吧 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:2:0","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"学习新的东西  作为前端开发者，必须要适应快速变化的形式，同时学习不能停止，所以在接下来的一年中，我会学习一些新的东西，像vue2.0，weex等等这些框架吧，然后学习http，网络等，了解数据是如何传递的，然后学习一下node，koa，让自己可以简易搭一个后台，从而实现整套网站的简易搭建。学习前端的一些工具，例如webpack。 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:2:1","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"开始锻炼  再过几个月就是春天了，开春了，北京的雾霾会好很多，自己也该开始锻炼了。2016年，得益于自己在春夏秋的锻炼，一年都没怎么生病，所以锻炼不能停，减肥不能停，还的继续加油啊，哈哈，期望自己在2017年，身体依然棒棒哒。 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:2:2","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"参加非技术活动  2016年，自己参加的技术活动真的是非常多了，当然2017年也不能停，毕竟要跟上时代嘛，看看别人家的技术，反思一下自己所知道的技术，弥补自己的不足。但是吧，我觉得我该参加一些其他活动，其实2016年就有这个想法，但是一直没有勇气去做（我自己并不喜欢一个人去参加活动），所以在2017年，我希望自己可以鼓起勇气，自己去接触一些新的东西，认识一些新的领域的人，加油！ ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:2:3","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["年终总结"],"content":"学我的乐器  2016年年初的时候自己定了目标要学吉他，随后买了把吉他，自己开始玩儿，但是后来也因为自己还要学一些其他东西，在年末就不怎么碰它了，所以在2017年，我要重拾我的吉他，要学会，从而让自己的生活更加丰富多彩，毕竟生活不只是代码。 再见，2016；你好，2017😊 ","date":"2016-12-31","objectID":"/posts/2016-2017newyear/:2:4","series":null,"tags":["年终总结"],"title":"再见，2016；你好，2017","uri":"/posts/2016-2017newyear/"},{"categories":["Javascript"],"content":" 最近一直在用空余时间研究node，当我写了一个简单的复制一个文件夹中的文件到另一个位置的时候，我看到了所谓的回调地狱，虽然只是四五个回调嵌套，但是这已经让我感到害怕，我写这么简单的一个小demo就写成这样，那稍微复杂点儿还了得？记得在看ES6的时候，里面提到过一种新的解决回调的方式－－－Promise，而且在node中也常用这个解决大量嵌套，所以这几天花了点儿时间看了看Promise，让我对Promise的认识更加清晰，所以写一些东西总结一下。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:0:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise状态的理解 用new Promise实例化的Promise对象有三个状态： “has-resolution” - Fulfilled reslove(成功时)，调用onFulfilled “has-rejection” - Rejected reject(失败时)。调用Rejected “unresolve” - Pending 既不是resolve也不是reject状态，也就是Promise刚刚被创建后的初始化状态。 在Chrome中输出resolve可以得到Promise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}，可以看出[[PromiseStatus]]中存储的就是Promise的状态，但是并没有公开访问[[PromiseStatus]]的用户API，所以暂时还无法查询其内部状态。 Promise中的then的回调只会被调用一次，因为Promise的状态只会从Pending变为Fulfilled或者Rejected，不可逆。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:1:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise的使用 在使用Promise实现有序执行异步的基本格式如下： //defined Promise async function function asyncFun(){ return new Promise((reslove,reject)=\u003e{ if(reslove){ reslove(/*reslove parameter*/); }else{ reject(new Error(/*Error*/)); } }) } //use Promise\u0026then asyncFun().then(/*function*/).then(/*function*/)... reslove方法的参数就是要传给回调函数的参数，即resolve将运行得到的结果传出来，而then接受该参数给回调继续执行后面的，如果这个then的中的函数还会返回Promise，则会重复执行该步骤直到结束。 reject方法的参数一般是包含了reject原因的Error对象。reject和resolve一样，也会将自己的参数传出去，接收该参数的是then的第二个fun或者是catch。其实.catch只是Promise.then(onFulfilled,onRejected)的别名而已。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:2:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"快捷创建Promise 一般情况下我们会使用new Promise来创建prmise对象，除此之外我们也可以使用Promise.reslove和Promise.reject来直接创建，例如Promise.resolve(42)可以认为是以下代码的语法糖 new Promise((reslove)=\u003e{ reslove(42); }); 这段代码可以让这个Promise对象立即进入resolve状态，并将42传递给后面then里所指定的onFulfilled函数。此外Promise.resolve还有一个作用，就是将非Promise对象转换为Promise对象。 Promise.reject(value)与之类似。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:3:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise.then()异步调用带来的思考 var promise = new Promise(function (resolve){ console.log(\"inner promise\"); // 1 resolve(42); }); promise.then(function(value){ console.log(value); // 3 }); console.log(\"outer promise\"); // 2 /*输出： \"inner promise\" \"outer promise\" 42 */ 从以上的这段代码我们可以看出Promise.then()是异步调用的，这也是Promise设计上规定的，其原因在于同步调用和异步调用同时存在会导致混乱。 以上那段代码如果在调用onReady之前DOM已经载入的话，对回调函数进行同步调用，如果在调用onReady之前DOM还没有载入的话，通过注册DOMContentLoader事件监听器来对回调进行异步调用。这会导致该代码在源文件中不同位置输出不同的结果，关于这个现象，有如下几点： 绝对不能对异步函数（即使在数据已经就绪）进行同步调用 如果对异步回调函数进行同步调用，处理顺序可能会与预期不符，带来意外的结果 对异步回调函数进行同步调用，还可能导致栈溢出或者异常处理错乱等问题 如果想在将来的某个时刻调用异步回调，可以使用setTimeout等异步API 所以以上代码应该使用 setTimeout(fn, 0)进行调用。 function onReady(fn) { var readyState = document.readyState; if (readyState === 'interactive' || readyState === 'complete') { setTimeout(fn, 0); } else { window.addEventListener('DOMContentLoaded', fn); } } onReady(function () { console.log('DOM fully loaded and parsed'); }); console.log('==Starting=='); 所以在Promise中then是异步的。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:4:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise链式调用 各个Task相互独立 如果想实现Promise的链式调用，要求每次链式调用都返回Promise。所以每个异步执行都需要使用Promise包装，这里有一个误区：每个then，catch会返回也会反回一个新的Promise，但是这仅仅实现了链式调用，如果不将异步操作用Promise进行包装，依然不行。下面的例子就是错误的。 function pro1(){ return new Promise((reslove,reject)=\u003e{ if(reslove){ setTimeout(()=\u003e{console.log(1000)},1000); reslove(); } }) } function pro2(){ setTimeout(()=\u003e{console.log(2000)},2000); } function pro3(){ setTimeout(()=\u003e{console.log(3000)},3000); } pro1().then(pro2).then(pro3); function pro1(){ setTimeout(()=\u003e{console.log(1000)},1000); } Promise.resolve().then(pro1).then(pro2).then(pro3); 上面的写法有两处错误： 虽然在第一个函数返回了一个Promise，但是由于后面的异步操作并没有被Promise包装，所以并不会起任何作用，正确的做法是每一个异步操作都要被Promise包装 resolve()调用的时机不对，resolve需要在异步操作执行完成后调用，所以需要写在异步操作内部，如果像上面那样写在异步操作外面，则不会起作用。 所以正确写法如下： //直接返回Promise function pro1(){ return new Promise((resolve,reject)=\u003e{ setTimeout(()=\u003e{console.log(1000);resolve();},1000); }) } function pro2(){ return new Promise((resolve,reject)=\u003e{ setTimeout(()=\u003e{console.log(5000);resolve();},5000); }); } function pro3(){ return new Promise((resolve,reject)=\u003e{ setTimeout(()=\u003e{console.log(500);resolve();},500); }) } pro1().then(pro2).then(pro3); //or使用Promise.reslove() function pro1(cb){setTimeout(()=\u003e{console.log(1000);cb()},1000)}; function pro2(cb){setTimeout(()=\u003e{console.log(3000);cb()},3000)}; function pro3(cb){setTimeout(()=\u003e{console.log(500);cb()},500)}; Promise.resolve() .then(()=\u003enew Promise(resolve=\u003epro1(resolve))) .then(()=\u003enew Promise(resolve=\u003epro2(resolve))) .then(()=\u003enew Promise(resolve=\u003epro3(resolve))); 各个Task需要参数的传递 在Promise的链式调用中，有可能各个task之间存在相互依赖，例如TaskA想给TaskB传递一个参数，像下面这样： /*例1.使用Promise.resolve()启动*/ let task1 = (value1)=\u003evalue1+1; let task2 = (value2)=\u003evalue2+2; let task3 = (value3)=\u003e{console.log(value3+3)}; Promise.resolve(1).then(task1).then(task2).then(task3);//console =\u003e 7 /*例2.普通的返回一个Promise*/ function task1(value1){ return new Promise((resolve,reject)=\u003e{ if(resolve){ resolve(value1+1); }else{ throw new Error(\"throw Error @ task1\"); } }); } function task2(value2){ return new Promise((resolve,reject)=\u003e{ if(resolve){ resolve(value2+2); }else{ throw new Error(\"throw Error @ task1\"); } }); } function task3(value3){ return new Promise((resolve,reject)=\u003e{ if(resolve){ console.log(value3+3); }else{ throw new Error(\"throw Error @ task1\"); } }); } task1(1).then(task2).then(task3);//console =\u003e 7 关于reslove与reject有以下两点说明： reslove函数的作用是将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果作为参数传递出去； reject函数的作用是将Promise对象状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时候调用，并将异步操作报出的错误作为参数传递出去； 所以从上面的例子和它们的用法可以看出，如果想要传递给后面task有两种方法： 如果使用Promise.resolve()启动Promise，则像例1中那样在需要传递的参数前面加return即可。 如果是利用Promise包装了任务，则把想要传递给下一个task的参数传入resolve()即可。 特别说明：如果需要resolve()往后传递多个参数，不能直接写resolve(a1,a2,a3)，这样只能拿到第一个要传的参数，需要以数组或对象去传递 let obj = {a1:a1,a2:a2,a3:a3}; resolve(obj) //or let arr =[a1,a2,a3]; resolve(arr); ","date":"2016-12-13","objectID":"/posts/2016-promise/:5:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"then与catch返回新的Promise 在Promise中无论是then还是catch方法，都会返回返回一个新的Promise对象。 var aPromise = new Promise(function (resolve) { resolve(100); }); var thenPromise = aPromise.then(function (value) { console.log(value); }); var catchPromise = thenPromise.catch(function (error) { console.error(error); }); console.log(aPromise !== thenPromise); // =\u003e true console.log(thenPromise !== catchPromise);// =\u003e true 所以像下面这样将链式调用分开写是不成功的 // 1: 对同一个promise对象同时调用 `then` 方法 var aPromise = new Promise(function (resolve) { resolve(100); }); aPromise.then(function (value) { return value * 2; }); aPromise.then(function (value) { return value * 2; }); aPromise.then(function (value) { console.log(\"1: \" + value); // =\u003e 100 }); 由于每次调用then方法都会返回一个新的Promise，所以导致最终输出100而不是100 * 2 * 2。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:6:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise.all()的使用 有时候需要多个彼此没有关联的多个异步任务全部执行完成后再执行后面的操作，这时候就需要用到Promise.all()，它接收一个Promise的对象的数组作为参数，当这个数组里的所有Promise对象全部变成resolve或者reject的时候，它才会去调用后面的.then()。 这里需要说明一点，两个彼此无关的异步操作会同时执行，每个Promise的结果（即每个返回的Promise的resolve或reject时传递的参数）和传递给Promise.all的Promise数组的顺序一致。也就是说，假设有两个异步操作TaskA和TaskB，如果传入顺序为Promise.all([TaskA,TaskB])，则执行完成后传给.then的顺序为[TaskA,TaskB]。 function setTime(time){ return new Promise((resolve)=\u003e{ setTimeout(()=\u003eresolve(time),time); }) } let startTime = Date.now(); Promise.all([setTime(1),setTime(100),setTime(200)]) .then((value)=\u003e{ console.log(value); //[1,100,200] console.log(Date.now() - startTime); //203 }); 从上面函数的输出值可以看出Promise.all()里的异步操作是同时执行的而且传给.then()的顺序和Promise.all()里的顺序一样。最终执行时间约为200ms，为什么不是200ms，这里涉及到关于setTimeout的精准问题，不在这里讨论。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:7:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise.race()的使用 Promise.rance()的用法与Promise.all()类似，不同的地方在于Promise.all()是在接收到的所有Promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，而Promise.rance()只要有一个Promise对象进入FullFilled或者Rejected状态，就会继续进行后续处理。这相当于Promise.rance()进行“且”运算而Promise.rance()进行或运算。但是这里有一点需要注意一下： var taskA = new Promise(function (resolve) { setTimeout(function () { console.log('this is taskA'); resolve('this is taskA'); }, 4); }); var taskB = new Promise(function (resolve) { setTimeout(function () { console.log('this is taskB'); resolve('this is taskB'); }, 1000); }); Promise.race([winnerPromise, loserPromise]).then(function (value) { console.log(value); }); /* 输出结果： this is taskA this is taskA this is taskB */ 从这里可以看出，在第一个Promise变为FulFiled状态运行then里的回调后，后面的Promise并没有停止运行，而是接续执行。也就是说， Promise.race 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:8:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"Promise的reject和异步操作error的理解 function ReadEveryFiles(file){ return new Promise((resolve,reject)=\u003e{ if(resolve){ fs.readFile(`${__dirname}/jQuery/${file}`,(err,data)=\u003e{ if(err){ console.log(err); }else{ let obj = {data:data,file:file}; resolve(obj); } }); }else{ //promise reject error } }); } 这里的readFile的error和Promise的reject不一样，一个是readFile过程中导致的错误，而另一个是Promise做处理的时候导致的错误，可以这样理解，假设读取文件成功了，但是Promise还需要讲这个异步操作得到的数据拿到处理，在Promise做这些操作的时候可能出错。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:9:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"写在最后 这几天开始用Promise写了一些东西，发现其实如果用Promise，会使得代码量加大，因为每一个异步都要被Promise封装，但是这样换来的却是更加容易的维护，所以还是值得的，当代码写完后，我们很容易就能看出代码的执行过程，相对于原来用嵌套去写要直观许多，而如果想要解决Promise的代码量过大的问题，我们可以使用Generator函数，另外，在ES7标准中推出了更加牛的异步解决方案Async/Await，关于它们，我将会在随后继续深入。 ","date":"2016-12-13","objectID":"/posts/2016-promise/:10:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["Javascript"],"content":"参考 JavaScript Promise迷你书（中文版） ECMAScript 6 入门—Promise对象 ","date":"2016-12-13","objectID":"/posts/2016-promise/:11:0","series":null,"tags":["Javascript"],"title":"Promise－－优雅解决回调嵌套","uri":"/posts/2016-promise/"},{"categories":["github"],"content":" 好长时间不写东西了， 因为换了工作，所以在忙着熟悉公司的项目代码，所以没什么时间搞自己的东西，回想了一下，在计划中要总结一下关于如何使用终端的git连接github，所以写一下这个。 ","date":"2016-11-13","objectID":"/posts/2016-gitgithub/:0:0","series":null,"tags":["github"],"title":"Git连接Github总结","uri":"/posts/2016-gitgithub/"},{"categories":["github"],"content":"创建github仓库 在注册了账号后登陆点击头像旁边的+选择New repository创建一个个人的仓库。填写仓库名称，如图所示： ","date":"2016-11-13","objectID":"/posts/2016-gitgithub/:1:0","series":null,"tags":["github"],"title":"Git连接Github总结","uri":"/posts/2016-gitgithub/"},{"categories":["github"],"content":"安装git客户端 如果是windows，建议安装gitbash 如果是mac，先安装Homebrew，然后再使用homebrew安装git。 $ brew install git 如果是linux直接在终端使用apt-get安装： sudo apt-get install git ","date":"2016-11-13","objectID":"/posts/2016-gitgithub/:2:0","series":null,"tags":["github"],"title":"Git连接Github总结","uri":"/posts/2016-gitgithub/"},{"categories":["github"],"content":"配置git ","date":"2016-11-13","objectID":"/posts/2016-gitgithub/:3:0","series":null,"tags":["github"],"title":"Git连接Github总结","uri":"/posts/2016-gitgithub/"},{"categories":["github"],"content":"1.初始化git 一般我们是要将自己的本地项目上传到github，实现开源共享，那么就首先需要让git知道它需要跟踪这个项目，所以，我们首先在终端进入项目，初始化git(以mac为例，假设项目在桌面)： //进入项目 $ cd Desktop/myproject //初始化git $ git init 2.创建ssh key 为了让github能够识别是我们自己上传文件，需要创建ssh key $ ssh-keygen -t rsa -C \"your_email@youremail.com\" 这里的your_email@youremail.com是你的邮箱地址，在输入后会询问你是否保存创建的ssh key，点回车就好，然后要求输入你要设置的密码，如果直接回车表示不设密码。然后会提示你ssh key已经创建好。 3.将ssh可以写入github 创建好本地的ssh key后，我们需要让github知道这个ssh key是我们自己，所以需要将生成的ssh key复制出来，写入github，在mac下在终端输入 cat ~/.ssh/id_rsa.pub 此时在终端会显示出刚刚创建好的ssh key，复制出来，在github在点击头像，然后点击setting，在找到SSH and GPG keys，创建一个new ssh key，然后将刚刚复制的ssh key填入即可。 4.验证是否连接成功 在终端输入 $ ssh -T git@github.com 如果回车看到：You’ve successfully authenticated, but GitHub does not provide shell access 。表示已成功连上github。 5.设置username和email 在把本项目上传到github之前还需要分别输入设置username和email，因为github每次commit都会记录他们。所以分别输入如下命令： $ git config --global user.name \"your name\" $ git config --global user.email \"your_email@youremail.com\" 6.添加远程地址 在与github连接成功后，如何才能让相应的项目上传到对应的仓库呢？这里就需要添加远程地址，从而让我们的本地项目顺利到达对应的仓库。 打开终端，输入 $ git remote add origin git@github.com:yourName/yourRepo.git 后面的yourName和yourRepo分别是你的github的用户名和刚才新建的仓库名。 ","date":"2016-11-13","objectID":"/posts/2016-gitgithub/:3:1","series":null,"tags":["github"],"title":"Git连接Github总结","uri":"/posts/2016-gitgithub/"},{"categories":["github"],"content":"上传项目 进入项目，在终端运行 $ git status 查看要上传的文件是否正确，然后将项目下的所有文件添加到git跟踪范围。 $ git add . 记录此次提交并上传 $ git commit -m 'my project push' $ git push origin master 这里的master指的是主分支名，如果是其他分支，则填写相应的分支名。 这样我们就将我们的项目上传到github仓库。 ","date":"2016-11-13","objectID":"/posts/2016-gitgithub/:4:0","series":null,"tags":["github"],"title":"Git连接Github总结","uri":"/posts/2016-gitgithub/"},{"categories":["Linux"],"content":" 自己一直对linux充满好奇，这次换了新的工作后，由于使用Mac OS和linux，所以国庆回来，给自己的电脑装了ubuntu来熟悉linux。在安装完成后遇到一些问题，经过谷歌都一一解决了，写这篇博文分享给大家。 ","date":"2016-10-02","objectID":"/posts/2016-linuxstudy/:0:0","series":null,"tags":["Linux"],"title":"Linux日常使用总结","uri":"/posts/2016-linuxstudy/"},{"categories":["Linux"],"content":"1．设置获取root权限 sudo passwd root //设置root密码 然后输入当前系统账户的密码并设置新的UNIX密码，密码更新成功后在终端输入su然后输入刚刚设置好的新的UNIX密码，即可进入root权限，如果想退出，输入exit。 ","date":"2016-10-02","objectID":"/posts/2016-linuxstudy/:1:0","series":null,"tags":["Linux"],"title":"Linux日常使用总结","uri":"/posts/2016-linuxstudy/"},{"categories":["Linux"],"content":"２．在linux下如何安装shadowsocks 因为自己是搞开发的，而且非常喜欢谷歌，所以就需要一个自由的网络环境，博主用的是shadowsocks，在windows下，有客户端，但是现在装了linux，既然装了linux，能用命令行搞定的就尽量用命令行，所以我选择在终端安装shadowsocks客户端，步骤如下： 安装shadowsocks客户端 sudo apt-get update sudo apt-get install python-gevent python-pip pip install shadowsocks 建立配置文件 打开终端，运行vim /etc/ss.json，然后写入json { \"server\" : \"you server\", \"server_port\" : 0000, \"local_address\" : \"127.0.0.1\", \"local_port\" : 1080, \"password\" : \"you password\", \"method\" : \"aes-256-cfb\", //shadowsocks的加密方式 \"fast_open\" : false } 开启shadowsocks sslocal -c /etc/ss.json // 开启后显示以下内容，代表开启成功： // INFO loading libcrypto from libcrypto.so.1.0.0 // INFO starting local at 127.0.0.1:1080 设置开机启动 // 打开图形化开机启动项管理界面 gnome-session-properties // 添加(Add) -\u003e 名称(name)和描述(comment)随便填，命令(Command)填写如下： sslocal -c /etc/ss.json 火狐浏览器配置 设置→首选项→高级→网络→链接→设置→手动配置代理→socks主机：127.0.0.1 端口：1080→确定 chrome配置 在终端中输入如下命令： chromium-browser --proxy-server=socks5://127.0.0.1:1080 进入后安装SwitchyOmega，然后配置此插件： 情景模式→删除原有的情景模式，新建情景模式（原有的情景模式无socks代理）→手动配置→SOCKS代理：127.0.0.1 端口1080→保存 →ok note: 我在这里运行这个命令后依然无法进入，不清楚是怎么回事儿，所以我直接找了个host进行了替换，关于host，我推荐老d博客中提供的，具体用法他博客中有写。然后才进入的应用商店下载好。 ","date":"2016-10-02","objectID":"/posts/2016-linuxstudy/:2:0","series":null,"tags":["Linux"],"title":"Linux日常使用总结","uri":"/posts/2016-linuxstudy/"},{"categories":["Linux"],"content":"３．安装相应的软件 安装Gdebi软件包安装程序 在ubuntu中有自己的软件中心，但是有些软件在里面找不到，需要自己去官网下载客户端然后安装（比如网易云音乐，搜狗拼音等），下载好的安装包大部分都是.deb文件，查阅了需要资料，安装这个用gdebi比较方便，在软件中心搜索Gdebi软件包安装程序安装就好，但是，既然用linux了，就用一下它强大的终端，所以我说一下在终端如何安装 在终端输入 sudo apt-get install gdebi 但是我在这里输入后，提示我缺少相应的依赖，并让我运行 sudo apt-get install -f 运行完成这个命令后，相应的依赖就被安装好了，这里的这个命令主要是修复依赖关系（depends）的命令，之后重新运行sudo apt-get install gdebi即可。 安装对应的软件 在安装完成这个后，安装软件就方便很多，我比如安装chrome浏览器，直接进入下载好文件的目录，运行 sudo gdebi chrome.deb //这里是你要安装包的名字 完成后去搜索即可。在安装时候我发现有的软件在安装完成后需要重启下电脑才会有。 卸载apt-get安装的东西 有时候需要卸载一些apt-get安装的东西，需要命令为 sudo apt-get remove XXX //XXX为要卸载的东西 安装node 做前端开发，node是必不可少的，所以需要安装一下，在windows下都是直接下载安装包安装，我本来也在linux下下了个安装包安装了，但是查了一下发现用nvm安装node的比较多，而且那天在公司老大也说在mac下推荐使用nvm安装，所以自己决定试下。 1.安装 nvm 之后最好先删除下已安装的 node 和全局 node 模块： npm ls -g --depth=0 //查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装 sudo rm -rf /usr/local/lib/node_modules //删除全局 node_modules 目录 sudo rm /usr/local/bin/node //删除 node cd /usr/local/bin \u0026\u0026 ls -l | grep \"../lib/node_modules/\" | awk '{print $9}'| xargs rm //删除全局 node 模块注册的软链 话说最后一条命令运行会报rm使用错误，不知道怎么弄… 2.安装nvm 运行以下两条命令之一 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash //or wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash 然后进入(~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc)这些文件，看哪个文件有，在最后一行添加. export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 . \"$NVM_DIR/nvm.sh\" # This loads nvm 这里如果不太会改这个的话，可以设置终端从而达到效果，在终端打开编辑→配置文件首选项→命令中勾选以登录shell方式运行命令。在ubuntu中没有执行命令时更新登录登录记录，如果有，一起勾选，然后在终端输入 nvm 即可看到帮助，之后运行 nvm install node 就可以安装到最新版本的node，更多关于nvm的用法可参考node版本管理工具nvm-Mac下安装及使用 至此，linux下常用的软件就安装完成… ","date":"2016-10-02","objectID":"/posts/2016-linuxstudy/:3:0","series":null,"tags":["Linux"],"title":"Linux日常使用总结","uri":"/posts/2016-linuxstudy/"},{"categories":["感悟"],"content":" 2016年9月23日，对于我来说是一个特殊的日子，我离开了我工作一年多的公司，这是我第一家公司，我的职业之路起于这里，这里是我起飞的地方。 ","date":"2016-09-24","objectID":"/posts/2016-thoughts/:0:0","series":null,"tags":["感悟"],"title":"北京的这一年，写在离开的这一天","uri":"/posts/2016-thoughts/"},{"categories":["感悟"],"content":"初到北京求职  2015年9月，我离开家乡，和同学一起踏上从太原去往北京的火车。对于北京，我并不陌生，之前来过几次玩儿，但是这次与以往不同，这次我要去梦想之地去实现自身的价值，所以心里还是蛮激动的，对于以后在北京的生活也充满了期待。三个小时后，我们到达了北京，九月初的北京温度还没有降下来，下车后，那种熟悉的感觉迎面而来，我又回到了我熟悉的地方—北京。  到达北京后的第一件事是找住的地方，因为每个人并不知道要去哪儿工作，所以我们需要先找个临时住所，那时候我在北京认识的人很少，幸亏有同学认识人，帮我们找了一个比较便宜的住的地方，我记得那时候在去住的地方的路上越走越懵逼，给我的感觉是我们刚到北京就要出北京市，经过几次换乘公交车，我们到达了我们要住的地方—老牛湾，熟悉北京的朋友应该知道那里是什么情况，当时到达那个地方后的第一反应是，这里是北京么？？这…我姥姥村都比这个强啊，后来想想北京的房价很高，而我们又是临时住，这里对于我们来说，是最合适的。  安顿好的第二天，我们各自开始踏上求职之路，因为之前在太原就投过很多公司，所以面试也不少，来到北京后直接可以找公司面试了。因为我们住的地方离北京市确实远，所以我们每天早晨7点起来开始各自准备准备出发，先坐公交到昌平线，然后再做地铁进入北京市。第一次在昌平线坐车的时候吓死我了，人多到爆，上车时候都不用自己动，人流会把你推上去的，这让我第一次见识到北京上班的高峰期！  可能是初生牛犊不怕虎吧（其实本身也没什么），第一次面试，我去了58同城，见识到了真正的前端面试，至今让我记忆尤新。我到了地方，坐着58的班车，到达曾经在互联网上见过无数次的公司，经过一番面试，面试官给了我一句话：“不好意思，我们需要的是一个能独揽一条产品线的人，你并不合适。”其实这句话并没有打击到我，因为于我来讲，我知道自己的水平在哪儿，来学习一些面试的东西也是值得的，所以也觉得无所谓。在之后的面试中，去的都是一些创业公司，面试的问的东西也是各式各样，因为有58同城的参考，所以时至今日，我都觉得他们的那些面试真的很不专业。从周一开始找工作，找到周五，别的同学都有了相应的offer，但是我自己却一个没有，那时候确实自己有点儿慌了，感觉压力也越来越大。在这五天内，我听到最多的，也是至今最烦的一句话：“等通知吧”…直到周五下午。  周五的下午，我来到我接下来供职一年多的公司面试，其实那时候我并没有投，是hr主动联系我让我去面试，那时候想，既然让去那就去吧。可能是一个offer都没有吧，很失望，所以那时候去公司面试并没有报太大希望，当时到了公司后，给我的感觉是，这个公司似乎很沉闷（事实上我后来发现我完全错了）。进去之后首先是填了张表，然后就开始面试，我老大并没有问我太多的前端的问题，只是简单的聊了聊，就把我要了（后来他说那时候觉得我比较踏实，所以就要了。），然后hr进来跟我聊了聊薪资什么的，最后走的时候送我一瓶饮料，嘿嘿。这次面试之后，我决定直接在这里入职了，不再面了，因为每天面试成本太高了。 ","date":"2016-09-24","objectID":"/posts/2016-thoughts/:1:0","series":null,"tags":["感悟"],"title":"北京的这一年，写在离开的这一天","uri":"/posts/2016-thoughts/"},{"categories":["感悟"],"content":"职业生涯的开始  2015年9月16日，我来到公司报到，开始了自己人生新的篇章。那时候我们还在老牛湾住，而公司在北京的南边，所以我每天上班先坐公交后坐地铁，每天上班两小时，下班两小时，现在想想也是相当可以了，哈哈。差不多我在公司上班一周后，我们开始找自己各自的住处，一部分在北京的北边，另一部分来到了南边。安顿好住处后，我开始了属于自己的职场生活。  刚去公司每天就是学习一些东西，后来开始做一些项目。记得刚去的时候我开始做的是整个公司网站的一个改版，大部分都更改，这算是一个比较大的工程吧，因为刚开始工作吧，对于团队协作什么的仅仅停留在概念上，所以在合作的时候时不时的出一些问题，有几次犯的错比较都被创始人说了，幸运的是我遇到一个好的老大，有什么事儿都帮我说话，所以我并没有什么事儿。记得有一次因为更改了php文件中的几个参数导致推广页面无法使用，连累我老大被CEO说，具体怎么说他的我不清楚，他只是跟我说：“没事儿，谁都会犯错，我那时候工作也犯过错误，改正就好。”从那时起我下定决心一定要把工作做好，要对得起我老大。  在忙碌的工作中，我度过了2015年，这半年，公司的人数涨了很多，同时在大家的共同努力下，公司从天使轮走到了A轮。不知不觉中，来到公司的年会，年会上，很多人喝的很嗨，因为自己并不爱喝酒，所以并没有喝趴下，哈哈。年会上，CEO总结了一下公司这一年来的发展，并说在明年年会上，公司的人数要翻一番。那时候开始觉得公司是非常有前途。但是在第二年的开春开始上班的时候，我发现和我一批来的就剩下我和我哥们儿了，大部分都离开了公司（包括招我进来的hr），至于什么原因就不说了，直到现在有时候还会怀念他们，如果不是公司的hr，我也没机会来这里上班。 ","date":"2016-09-24","objectID":"/posts/2016-thoughts/:2:0","series":null,"tags":["感悟"],"title":"北京的这一年，写在离开的这一天","uri":"/posts/2016-thoughts/"},{"categories":["感悟"],"content":"失望，离开  由于在公司工作并不是很忙，所以我有机会可以学习一些新的东西，这让我自己的技术在这一年中有了一定的提高，这一点上我非常感激公司。但是后来我发现我学到这些东西后，我不知道我该怎么用到公司的项目中，其实我自己在后来有跟公司提过，同时公司还让我分享过一些我自己学到的东西，曾经想过试着凭借自己学到的东西帮助公司在前端开发方面效率提上去，但是后来我发现，仅限于此，自己提出的一些东西公司领导会考虑一下，然后…就没有然后了…  在公司经历了一年，渐渐的发现，也许自己并不适合这里，所以经过一些面试后，自己找到了自己合适的工作，在2016年9月19日，我在QQ上跟我老大说我想离职，我老大并没有说什么，只是问我找到工作了么，我告诉他我找到了，之后问了一些关于手续的事儿，就这样，我在9月23日下午，我办完所有的交接，拿着离职证明，离开了我工作一年的公司。  对于离开这里，我并没有不舍，因为我深知自己并不适合这里，只是有时候觉得对不起我老大，虽然他在前端技术方面不是很让我折服，但是这一年来，他对我的照顾我还是非常感激的，最后跟他说我要离职，他问我找好下家了么的时候我知道，其实他早知道我要走了，可能就在等我这句话吧。我记得有一次我有点儿不舒服，请假回家，他还非常关心的问我怎么回事儿，不行就去医院看看，买点儿药，公司可以报销。真的非常感激他，虽然我们之间的对话大部分都是关于工作的事儿…  对于我自己来说，我其实并不喜欢经常跳槽，因为在一个公司待久了会有自己熟悉的人，有自己喜欢干的事儿，会对自己的公司产生一种感情，但是这些都是建立在工作非常开心，融入公司的环境的情况下。在公司的时间长了，渐渐的明白，公司的文化如同一个漏斗，会筛选出一批相似的人。 ","date":"2016-09-24","objectID":"/posts/2016-thoughts/:3:0","series":null,"tags":["感悟"],"title":"北京的这一年，写在离开的这一天","uri":"/posts/2016-thoughts/"},{"categories":["感悟"],"content":"写在最后  虽然我离开了，但是我一直都觉得公司很有前途，在我走的时候，公司已经从我当初刚去的20多人发展成70多人了，我感到很欣慰。同时，希望公司可以招到更好的前端，可以在未来发展的更好。 ","date":"2016-09-24","objectID":"/posts/2016-thoughts/:4:0","series":null,"tags":["感悟"],"title":"北京的这一年，写在离开的这一天","uri":"/posts/2016-thoughts/"},{"categories":["前端工具"],"content":" 上个月月底在公司提出关于前后端分离的想法，并且开始研究关于前后端分离，前端工程化，模块化的一些东西，上周开始我准备自己开始写基于Gulp流的前端工程文件，这两天有时间，着手开始实现这个想法，但是写的过程中，遇到了一些问题，正是因为这些问题的解决让我对Gulp的流式处理有了更深的理解，写下这篇文章，分享一下这俩天我在写Gulp的时候学到的一些东西。 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:0:0","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"准备工作 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:1:0","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"安装Node 首先Gulp是基于Nodejs的，所以安装Nodejs是前提，Node可以说是前端神器，基于Node有各种各样的工具，正是因为这些工具让我们非常方便的构建前端工程。 更改Node插件默认安装位置（非必需） 我自己一般不喜欢在C盘状太多与系统无关的东西，而通过Node自带的npm安装的插件默认在C盘，但是我将Node安装到D盘后，想让插件就安装在Nodejs的主目录下，怎么办呢？ 在Node主目录下新建\"node_global\"及\"node_cache\"两个文件夹 启动cmd，输入 //后面的设置目录根据你的目录结构自行更改 npm config set prefix \"D:\\Program\\nodejs\\node_global\" npm config set cache \"D:\\Program\\nodejs\\node_cache\" 关闭cmd，打开系统对话框，“我的电脑”右键“属性”-“高级系统设置”-“高级”-“环境变量”。 进入环境变量对话框，在系统变量下新建\"NODE_PATH\"，输入\"D:\\Program\\nodejs\\node_global\\node_module\"。 由于改变了module的默认地址，所以上面的用户变量都要跟着改变一下（用户变量\"PATH\"修改为\"D:\\Program\\nodejs\\node_global\"），要不使用module的时候会导致输入命令出现“xxx不是内部或外部命令，也不是可运行的程序或批处理文件”这个错误。 经过这四步的设置就可以让安装的Node插件放在Nodejs的主目录了。 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:1:1","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"安装Gulp //全局安装Gulp npm install -g gulp //在项目中安装Gulp npm install --save-dev gulp 运行gulp -v,如果不报错，表示安装成功 然后在命令行运行 npm init 让项目生产package.json文件 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:1:2","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"搭建工程 众所周知，在开发工程中有开发和上线两个过程，在开发中，我们一般需要自动刷新以及实时编译，但是如果上线，我们就需要考虑很多优化的东西，比如文件编译压缩，静态资源放缓存处理等等问题，我自己搭的这个工程只涉及到文件编译压缩，实时刷新，静态资源放缓存这三个基本的流程。 在项目的目录结构如下 -------------------project | |--------------dist (该文件夹为打包生成的) | | | |----------css | | | | | |------index-9dcc24fe2e.css | | | |----------js | | | | | |------index-9dcc24fe2e.js | |----------index.html | |--------------src | | | |----------scss | | | | | |------index.scss | | | |----------js | | | | | |------index.js | | | |----------index.html |--------------gulpfile.js |--------------package.json ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:2:0","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"开发所用流程 文件编译 在工程中准备使用scss作为css的预编译，所以需要利用gulp对scss进行编译，所以首先安装gulp-sass。 npm install --save-dev gulp-sass 安装完成之后，直接在gulpfile.js引用配置 const sass = require('gulp-sass'); //scss编译 gulp.task('scss:dev',()=\u003e{ gulp.src('src/scss/*.scss') .pipe(sass()) .pipe(gulp.dest('dist/css')); //将生成好的css文件放到dist/css文件夹下 }); 这里简单介绍下gulp的两个api： gulp.src()输入符合所提供的匹配模式或者匹配模式的数组的文件。将返回一个stream或者可以被piped到别的插件中。读文件 gulp.dest()能被pipe进来，并且将会写文件。并重新输出（emits）所有数据，因此可以将它pipe到多个文件夹，如果文件夹不存在则将会自动创建。写文件 实时刷新 实现实时刷新的工具有很多，我自己使用browser-sync，这个工具的功能非常强大，想了解它更多的用法可以查看官网：http://www.browsersync.cn/。 首先我们在项目中安装该模块 npm install --save-dev browser-sync 根据官网的browser-sync与gulp的配置，得到如下配置： const browserSync = require('browser-sync').create(); //实时刷新 const reload = browserSync.reload; gulp.task('dev',['scss:dev'],function () { browserSync.init({ server:{ baseDir:'./' //设置服务器的根目录 }, logLevel: \"debug\", logPrefix:\"dev\", browser:'chrome', notify:false //开启静默模式 }); //使用gulp的监听功能，实现编译修改过后的文件 gulp.watch('src/scss/*.scss',['scss:dev']); gulp.watch(('*.html')).on('change',reload); }); 这样，一个简单的gulp开发流程就出来了，仅仅只是一个编译scss和一个实时刷新。 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:2:1","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"打包上线所有流程 打包上线，我们更多的是考虑，静态资源防缓存，优化。对css，js的压缩，对图片的处理，我写的这个简单的流程中并没有涉及对图片的处理，所以这里仅针对css，js，html处理。 压缩css我们使用gulp-sass就可以，因为它在编译scss的时候有一个配置选项可以直接输出被压缩的css。压缩js我使用了gulp-uglify，静态资源防缓存使用gulp-rev和gulp-rev-collector。 对css，js的处理 //scss编译 gulp.task('css',()=\u003e { gulp.src('src/scss/*.scss') .pipe(sass({ outputStyle: 'compressed' //编译并输出压缩过的文件 })) .pipe(rev()) //给css添加哈希值 .pipe(gulp.dest('dist/css')) .pipe(rev.manifest()) //给添加哈希值的文件添加到清单中 .pipe(gulp.dest('rev/css')); }); //压缩js gulp.task('js', ()=\u003e { gulp.src('src/js/*js') .pipe(uglify()) .pipe(rev()) //给js添加哈希值 .pipe(gulp.dest('dist/js')) .pipe(rev.manifest()) //给添加哈希值的文件添加到清单中 .pipe(gulp.dest('rev/js')); }); 其中gulp-rev是为css文件名添加哈希值，而rev.manifest()会生成一个json文件，这个json文件中记录了原文件名和添加哈希值后的文件名的一个对应关系，这个对应关系在最后对应替换html的引用的时候会用到。 生成的json文件如下： { \"index.css\": \"index-9dcc24fe2e.css\" } 由于给文件添加了哈希值，所以每次编译出来的css和js都是不一样的，这会导致有很多冗余文件，所以我们可以每次在生成文件之前，先将原来的文件全部清空。 gulp中也有做这个工作的插件—gulp-clean，因此我们可以在编译压缩添加哈希值之前先将原文将清空。 清空生成的项目文件 const clean = require('gulp-clean'); //清空文件夹里所有的文件 //每次打包时先清空原有的文件夹 gulp.task('clean', ()=\u003e { gulp.src(['dist', 'rev'], {read: false}) //这里设置的dist表示删除dist文件夹及其下所有文件 .pipe(clean()); }); 让添加哈希编码的文件自动添加到html中 前面提到的gulp-rev实现了给文件名添加哈希编码，但是在打包完成后如何让原来未添加哈希值的引用自动变为已经添加哈希值的引用，这里用到gulp-rev的一个插件gulp-rev-collector，配置如下： //将处理过的css，js引入html gulp.task('reCollector',()=\u003e{ gulp.src(['rev/**/*.json','src/*.html']) .pipe(reCollector({ replaceReved: true, //模板中已经被替换的文件是否还能再被替换,默认是false dirReplacements: { //标识目录替换的集合, 因为gulp-rev创建的manifest文件不包含任何目录信息, 'css/': '/dist/css/', 'js/': '/dist/js/' } })) .pipe(gulp.dest('dist')) }); 并没有正常替换？ 在我自己写的时候，出现这个问题，运行完成该任务后，html中的css和js引用并没有发生变化，网上搜了半天，才知道是由于自己用了gulp-rename插件，然后将文件名都添加了.min（至于为什么添加，仅仅是因为是压缩过的，应该写个）而在自己写的html里面引用的文件并没有.min，由于gulp-rev-collector在替换的时候根据生成的json文件替换，在json中，文件都有了.min而在html中没有，所以无法匹配，自然也就不能实现替换了，所以在替换的时候一定要注意gulp-rev生成的json文件中的css，js与html中的引用的一样，否则无法实现替换。 在gulp-rev-collector的api中有一个revSuffix，这个看起来可以实现类似于gulp-rename的功能，但是不知道该怎么用，大家如果知道的话请告诉我… 执行所有任务 完成上面几个步骤后我们将所有任务串起来，让其可以一条命令然后全部执行 gulp.task('build',['clean', 'css', 'js', 'reCollector']); 再次理解gulp gulp—它的task是顺序执行吗？ 本以为到这里，就算是写完了，运行，完美，打包生成文件，再运行一次，报错了！！！！ [19:04:57] Finished 'default' after 7.38 μs stream.js:74 throw er; // Unhandled stream error in pipe. ^ Error: ENOENT: no such file or directory, stat 'D:\\project\\dist\\js\\index-6045b384e6.min.js' at Error (native) 提示我找不到这个文件，这让我很郁闷啊，然后我分开执行，很ok，可以确定是执行顺序有问题，很可能在没有清理完成就执行后面了，查了gulp的官网文档才知道本身gulp的pipe是一个一个任务进行的，是同步的，但是每个task之间是不同步的，是一起进行的，这也验证了我的猜想，所以在网上找如何解决这个问题，找到一个叫run-sequence的npm插件，配置文件如下： //进行打包上线 gulp.task('build', ()=\u003e { runSequence('clean', ['css', 'js'], 'reCollector'); }); 本以为运行就ok，结果，还是报错，这里就涉及到对gulp的另一个理解 run-sequence插件对异步任务的处理 在用这个插件让任务有序进行后，我想进一步直观的看到它对任务的序列化，自己写了一个demo，如下： gulp.task('a',function(){ setTimeout(function () { console.log(1); },30); }); gulp.task('b',function() { console.log(2); }); gulp.task('ab',function(){ runSequence('a','b'); }); 但是这里就出现问题了，runSequence不管用了，找插件的说明和gulp官方文档，原来异步任务，像setTimeout，readFile等，需要添加一个callback的执行，这里的callback()就会返回一个promise的resolve()，告诉后面的任务，当前任务已经完成，后面可以继续执行了，所以在task a里面执行callback。 gulp.task('a',function(cb){ setTimeout(function () { console.log(1); cb(); },30); }); 那为什么前面写的那些任务不需要添加一个callback呢？由于gulp的pipe流让每一个task中的小任务（每一个pipe）顺序执行，从而整个pipe流是同步的，并不是异步任务，所以并不需要手动让其返回promise，run-sequence会自动帮我们管理。 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:2:2","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"gulpfile的分离 在前面我们将dev和build写在了一个叫gulpfile的文件中，虽然可以执行，但是当我们的工程越来越大的时候，会导致gulpfile可维护性降低，那能否让dev和build分别写在两个文件中呢？答案是可以的，我们可以新建两个文件，分别为gulpfile-dev.js和gulpfile-build.js，其实我们在运行gulp build的时候，其实是运行了gulp –gulpfile gulpfile.js build，前者相当于后者的缩写，所以在运行gulp的时候在命令中输入如下： gulp --gulpfile gulpfile-dev.js gulp --gulpfile gulpfile-build.js 就可以在gulp运行时候指定gulpfile。这样我们再原来的task中的buil和dev改成default就可以直接运行以上命令达到预期效果。 但是每次敲这么长的命令很烦，怎么办呢？我们可以在package.json的scripts中添加如下json： \"dev\": \"gulp --gulpfile gulpfile-dev.js\" \"build\": \"gulp --gulpfile gulpfile-build.js\" 这样，我们在运行的时候，直接在命令行输入： npm run dev npm run build 就可以实现打包了，是不是很酸爽，哈哈！ ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:3:0","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["前端工具"],"content":"总结 至此，我们就完成了一个简易的基于gulp的前端工程的搭建，很多东西确实，想着并不难，做起来会出现各种各样意想不到的问题，gulp很早就知道，都是单个任务在写，然后用哪个执行哪个命令，直到自己写完这个这个简单的工程，才对gulp有了更深入的理解。 ","date":"2016-09-07","objectID":"/posts/2016-gulpuse/:4:0","series":null,"tags":["gulp"],"title":"基于Gulp的前端自动化工程搭建","uri":"/posts/2016-gulpuse/"},{"categories":["CSS"],"content":" 今天在工作中遇到需求，需要用CSS3写一个卡片翻转效果，这个效果看起来简单，但是还是涉及到一些不常用的CSS3中的3D转换的属性以及实现该效果的思路，所以这里总结一下。 项目地址：https://github.com/MrZhang123/Practice/tree/master/FlipCards ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:0:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"需要的CSS3属性 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:1:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"perspective 目前浏览器都不支持perspective属性 在chrome和Safari中需要使用-webkit-perspective，而在Firefox中需要使用-moz-perspective来定义。 定义和用法 perspective属性定义3D元素距视图的距离，以像素计。该属性允许改变查看3D元素的视图。当为元素定义 perspective属时，其子元素会获得透视效果，而不是元素本身。换句话说，设置这个元素是为了给该元素的子元素用。 值 number：元素距离视图的距离，以像素计 none：默认值，与0相同。不设置透视 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:1:1","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"transform-style Firefox支持transfrom-style属性。 Chrome、Safari和Opera支持代替的-webkit-transform-style属性。 定义和用法 transform-style属性固定如何在3D空间中呈现被嵌套的元素。一般给父元素设置让其所有子元素跟着父元素一起位置移动，一般会设置。 值 flat：子元素将不保留其3D位置（默认值） perserve-3d：子元素将保留其3D位置 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:1:2","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"transition IE10+、Firefox、Opera、Chrome均支持transition属性。Safari支持替代的-webkit-transition属性。但是IE9-不支持该属性。 定义和用法 transition属性是一个简写属性，用于设置四个过渡属性： transiton-property：规定设置过渡效果的CSS属性的名称 transiton-duration：规定完成过渡效果需要多少秒或毫秒 transiton-timing-funciton：规定速度效果的速度曲线 transition-delay：规定过渡效果何时开始 transiton-duration必须设置，否则时长为0 ，不会有过渡效果 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:1:3","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"backface-visibility 只有IE10+和Firefox支持backface-visibility，Opera15+、Safari和Chrome支持替代的-webkit-backface-visibility 定义和用法 backface-visibility属性定义当前元素不面向屏幕时是否可见，如果元素在旋转后不希望看到背面，则可以使用。 visible：背面是可见的（默认值） hidden：背面是不可见的 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:1:4","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"实现的思路 要实现类似的翻牌效果，首先我们需要有一张可以翻的牌，这张牌由两个元素重叠组成，位于上层正面我们看到，而位于下层的背面我们看不到并且本身是绕Y轴旋转过的，这样，当鼠标移动上去后，同时让正面和背面执行旋转就可以实现翻牌效果。 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:2:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"实现 基本结构代码如下： \u003cdiv id=\"content\"\u003e \u003cul\u003e \u003cli\u003e \u003ca href=\"#\" \u003e \u003cdiv\u003e \u003ch3\u003e测试正面1\u003c/h3\u003e \u003cp\u003e文字文字文字文字文字文字文字文字文字文字文字\u003c/p\u003e \u003c/div\u003e \u003cdiv\u003e \u003ch3\u003e测试背面1\u003c/h3\u003e \u003cp\u003e文字文字文字文字文字文字文字文字文字文字文字\u003c/p\u003e \u003c/div\u003e \u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ul,li { margin:0; padding:0; list-style:none; } #content ul li{ width: 225px; height: 180px; } #content ul li a{ position: relative; display: block; width: 100%; height: 100%; } #content ul li a \u003e div{ position: absolute; left: 0; height: 0; width: 100%; height: 100%; color: #fff; } #content ul li a div:first-child{ background-color: rgb(255, 64, 129); z-index:2; } #content ul li a div:last-child{ background:rgb(0, 188, 212); z-index:1; } #content ul li a div h3{ margin: 0 auto 15px; padding: 15px 0; width: 200px; height: 16px; line-height: 16px; font-size: 14px; text-align: center; border-bottom: 1px #fff dashed; } #content ul li a div p{ padding: 0 10px; font-size: 12px; text-indent: 2em; line-height: 18px; } 这样就让两个div叠在一起了，但是如果要进行翻转的话，首先是需要将背面本身就翻过去，当鼠标放上去之后翻转过来，让我们看到，所以我们需要给背面添加翻转180°的属性，鼠标放上去之后让它翻转到0°，同时为保证每个浏览器渲染统一，给正面加一个翻转0°，鼠标移动上去之后翻转-180°，并且是一个动画，所以要添加过渡。所以给正面背面添加CSS如下： #content ul li a \u003e div{ -webkit-transition:.8s ease-in-out; -moz-transition:.8s ease-in-out; } #content ul li a div:first-child{ -webkit-transform:rotateY(0); -moz-transform:rotateY(0); } #content ul li a div:last-child{ -webkit-transform:rotateY(180deg); -moz-transform:rotateY(180deg); } #content ul li a:hover div:first-child{ -webkit-transform:rotateY(-180deg); -moz-transform:rotateY(-180deg); } #content ul li a:hover div:last-child{ -webkit-transform:rotateY(0); -moz-transform:rotateY(0); } 在添加这些CSS3属性后，可以实现翻转，但是发现只看到正面，没有看到背面，这又是为什么呢，前面提到有一个属性backface-visibility，这个属性用于控制在翻转后，元素的背面是否可见，默认是可见的，所以就会挡着背面那个元素，我们需要手动设置元素翻转后背面不可见，所以需要设置： #content ul li a \u003e div{ -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden; } 这样设置之后，由于正面的元素在翻转后背面不可见，我们就可以看到背面的元素了。 但是，仔细观察会发现这个翻转似乎并不是那么立体，似乎在两条平行线之间实现了翻转，所以我们需要设置一个观察点距离视图的距离，这时候就需要给父元素添加perspective属性，这个属性的值一般为800px ~ 1000px，这个范围内的值会看上去合理。所以给父元素添加： #content ul li a{ -webkit-perspective: 800px; -moz-perspective: 800px; } 至此，就实现了一个翻转卡牌的效果，但是这里需要解决一个问题，因为perspective属性不被IE支持（Microsoft Edge支持），所以需要进行降级，我的做法是直接显示隐藏。那么如何识别IE9+浏览器呢？在stackoverflow中我找到了答案： ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:3:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"附：CSS中识别各类IE的方法 ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:4:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE6 * html .ie6{ property:value; } or html .ie6{ _property:value; } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:5:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE7 *+html .ie7{ property:value; } or *:first-child+html ie7{ property:value; } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:6:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE6 and IE7 @media screen\\9{ ie67{property:value;} } or .ie67{ *property:value;} or .ie67{ #property:value;} ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:7:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE6,7 and 8 @media \\0screen\\,screen\\9{ ie678{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:8:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE8 html\u003e/**/body .ie8{property:value;} or @media \\0screen{ ie8{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:9:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"只在IE8标准模式 .ie8{property/*\\**/:value\\9;} ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:10:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE8,9 and 10 @media screen\\0{ ie8910{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:11:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE9 only @media screen and (min-width:0\\0) and (min-resolution: .001dpcm){ /*IE9 CSS*/ .ie9{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:12:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE9+ @media screen and (min-width:0\\0) and (min-resolution: +72dpi){ /*IE9+ CSS*/ .ie9up{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:13:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE9 and 10 @media screen and (min-width:0){ .ie910{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:14:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE10 only _:-ms-lang(x), ie10 {property:value;} ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:15:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE10+ _:-ms-lang(x), ie10up{property:value;} or @media all and (-ms-high-contrast:none),(-ms-high-contrast:active){ .ie10up{property:value;} } ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:16:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["CSS"],"content":"IE11+ _:-ms-fullscreen, :root .ie11up{property:value;} ","date":"2016-08-17","objectID":"/posts/2016-flipcards/:17:0","series":null,"tags":["CSS"],"title":"CSS3实现翻转卡牌效果","uri":"/posts/2016-flipcards/"},{"categories":["Javascript"],"content":"字符方法 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:1:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"chartAt()与charCodeAt() 参数：基于0的字符位置 **chartAt()以单字符字符串的形式返回给定位置的那个字符。而charCodeAt()**返回的是字符编码。 var stringValue = 'hello world'; /*chartAt()*/ console.log(stringValue.chartAt(1)); // 'e' ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:1:1","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"字符串操作方法 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:2:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"concat()(数组中也有该方法) 参数：一个或多个字符串 将一个会多个字符串拼接起来，当然更常用的是使用 “+” 进行拼接 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:2:1","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"substring()与slice()(数组中也有此方法) 参数：指定子字符串的开始位置，子字符串到哪里结束 作用：创建新的子字符串（可以理解为字符串截取） ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:2:2","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"substr() 参数：指定子字符串的开始位置，返回的子字符串的字符个数 作用：创建新的子字符串（可以理解为字符串截取） ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:2:3","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"repeat()（ES6新增） 参数：数字（表示重复的次数） 作用：将原字符串重复n次 如果传入负数，则报错，传入小数和NaN等同于传入0 substring，slice，substr，repeat均返回子字符串，不会修改原来的字符串 var stringValue = \"hello world\"; alert(stringValue.slice(3)); //\"lo world\" alert(stringValue.substring(3)); //\"lo world\" alert(stringValue.substr(3)); //\"lo world\" alert(stringValue.slice(3, 7)); //\"lo w\" alert(stringValue.substring(3,7)); //\"lo w\" alert(stringValue.substr(3, 7)); //\"lo worl\" /*repeat()*/ var a = 'he'; var b = a.repeat(3); console.log(`${a}---${b}`); / //\"he---hehehe\" 当给这三个方法传入负值的时候，三个的表现不同： slice()会将传入的负值与字符串的长度相加 substr()会将第一个位置的负值参数加上字符串长度后转为正数，而第二个位置的负值将转化为0 substring()会把所有的负参数转化为0 repeat()会报错 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:2:4","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"字符串位置方法 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:3:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"indexOf()和lastIndexOf()(数组中也有该方法) 参数：要搜索的子字符串，开始搜索的位置（可选） 搜索给定的子字符串，如果找到则返回位置，否则返回-1 var stringValue = \"hello world\"; alert(stringValue.indexOf(\"o\")); //4 alert(stringValue.lastIndexOf(\"o\")); //7 这两个方法在搜索到第一个匹配的子字符串后就停止运行，所以如果想找到字符串中所有的 子字符串出现的位置，可以循环调用indexOf或lastIndexOf。 var stringValue = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"; var positions = new Array(); var pos = stringValue.indexOf(\"e\"); while(pos \u003e -1){ positions.push(pos); pos = stringValue.indexOf(\"e\", pos + 1); } alert(positions); //\"3,24,32,35,52\" ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:3:1","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"ES6新增includes()、startsWith()、endsWith() includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部 这三个方法的参数与indexOf()，lastIndexOf()一样 var s = 'Hello world'; s.startsWith('world',6); // true s.endsWith('Hello',5); // true s.includes('Hello',6); //false 注意： 使用第2个参数n时，endsWith的行为与其他两个方法有所不同。它针对前面n个字符，而其他两个方法针对从第n个位置开始直到字符串结束的字符。 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:3:2","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"去空格–trim() ES5中新增trim()方法用于去除字符串的左右空格，该方法会创建一个字符串的副本，不会改变原有的字符串，此外，Firefox 3.5+、Safari 5+ 和 Chrome 8+还支持非标准的 trimLeft()和 trimRight()方法，分别用于删除字符串开头和末尾的 空格。 其实去空格可以使用正则去匹配的去掉，这里写一个去空格函数 /*trim 去掉空白 str要处理的字符串 [type] 类型：l 去除左边的空白 r去除右边空白 b去掉两边的空白 a去除所有空白*/ function trim (str,type) { var type=type||\"b\"; if(type==\"b\"){ return str.replace(/^\\s*|\\s*$/g,\"\"); }else if(type==\"l\"){ return str.replace(/^\\s*/g,\"\"); }else if(type==\"r\"){ return str.replace(/\\s*$/g,\"\"); }else if(type==\"a\"){ return str.replace(/\\s*/g,\"\"); } } ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:4:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"字符串大小写转换 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:5:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase() ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:5:1","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"字符串的模式匹配方法 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:6:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"match() 参数：一个正则表达式或RegExp对象 返回一个数组。在字符串上调用这个方法本质上与调用RegExp的exec()方法相同。 var text = \"cat, bat, sat, fat\"; var pattern = /.at/; //与 pattern.exec(text)相同 var matches = text.match(pattern); alert(matches.index); //0 alert(matches[0]); //\"cat\" alert(pattern.lastIndex); //0 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:6:1","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"search() 参数：一个正则表达式或RegExp对象 返回字符串中第一个匹配项的索引，如果没有找到，则返回-1 var text = \"cat, bat, sat, fat\"; var pos = text.search(/at/); alert(pos); //1 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:6:2","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"replace() 参数：一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），一个字符串或一个函数 利用replace()进行替换的时候，如果传入的是字符串，则只会替换第一个子字符串，要想替换所有的子字符串，则需要传入一个正则表达式，而且要指定全局（g）标志 var text = 'cat , bat , sat , fat'; var result = text.replace('at','ond'); console.log(result); // =\u003e'cont , bat , sat , fat' result = text.replace(/at/g,'ond'); console.log(result); //=\u003e'cont , bont , sont , font' 该方法并不改变调用它的字符串本身，只是返回一个新的替换后的字符串。 当第二个参数为函数时函数的返回值作为替换字符串。与第二个参数是字符串一样，如果第一个参数是正则表达式，并且全局匹配，则这个函数的方法将被多次调用，每次匹配都会被调用。 该函数的参数： match：匹配的子串 p1,p2…：假如replace()方法的第一个参数是RegExp对象，则代表第n个括号匹配的字符串。 offset：匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串时“bc”，那么这个参数是1） 被匹配的原字符串 function replacer(match , p1 , p2 , p3 , offset , string){ // p1 is nondigits, p2 digits, and p3 non-alphanumerics console.log(`${match}${p1}${p2}${p3}${offset}${string}`); /* =\u003e abc12345#$*% abc 12345 #$*% 0 abc12345#$*%\" */ console.log([p1, p2, p3].join(' - ')); // =\u003e \"abc - 12345 - #$*%\" return [p1, p2, p3].join(' - '); } var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); // =\u003e\"abc - 12345 - #$*%\" ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:6:3","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"split() 参数：用于分隔字符串的分隔符，数字（可选，用于指定数组的大小） 作用：基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中，分隔符可以是字符串，也可以是RegExp对象 var color = 'red,blue,yellow,black'; var color1 = color.split(','); // =\u003e['red','blue','yellow','black'] var color2 = color.split(',',2); // =\u003e['red','blue'] var color3 = color.split(/[^\\,]+/); // =\u003e[\"\", \",\", \",\", \",\", \"\"] 最后一个调用split的时候，出现了前后的两个空白，是因为通过正则表达式指定的分隔符出现在了字符串的开头和结尾。 ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:6:4","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"localeCompare() 这个方法用于比较两个字符串，并返回下列值中的一个： 如果字符串在字母表中应该排在字符串参数之前，则返回负数（大多情况下为-1） 如果相等，则返回0 如果排在字符串参数之前，则返回正数（大多数情况下为1） ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:7:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"fromCharCode() String构造函数的一个静态方法 参数：一个或多个字符串编码 作用：将接收到的一个或多个字符串编码转换成一个字符串，这个方法与实例方法charCodeAt()执行相反的操作。 /*fromCharCode*/ String.fromCharCode(104,101,108,108,111); // =\u003ehello /*charCodeAt*/ let s = 'hello'; for(let i=0;i\u003cs.length;i++){ console.log(`${s[i]}----${s[i].charCodeAt()}`); } /* \"h----104\" \"e----101\" \"l----108\" \"l----108\" \"o----111\" */ 最后写一个字符串与数组方法应用的一个例子，熟悉它们方法的话很简单，不熟悉就会觉得有点儿乱。 let s = 'hello'; let news = s.split('').reverse().join(''); console.log(news); // =\u003e \"olleh\" ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:8:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":"另附js中String和Array方法的总结图： ","date":"2016-08-14","objectID":"/posts/2016-jsstring/:9:0","series":null,"tags":["Javascript"],"title":"Javascript中字符串方法总结","uri":"/posts/2016-jsstring/"},{"categories":["Javascript"],"content":" 最近事儿比较多，一直没时间写东西，前几天又遇到关于获取元素大小的问题，每次遇到这类问题就翻书，比较费时间，所以总结一下。 ","date":"2016-08-03","objectID":"/posts/2016-jsposition/:0:0","series":null,"tags":["Javascript"],"title":"JS中的位置与大小","uri":"/posts/2016-jsposition/"},{"categories":["Javascript"],"content":"1.元素的偏移量 元素的偏移量包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：这里并不包括外边距）。 ","date":"2016-08-03","objectID":"/posts/2016-jsposition/:0:1","series":null,"tags":["Javascript"],"title":"JS中的位置与大小","uri":"/posts/2016-jsposition/"},{"categories":["Javascript"],"content":"2.客户区大小 元素的客户区大小指的是元素内容机器内边距占据空间的大小。 要确定浏览器可见窗口的大小，可以使用document.documentElement或document.body（IE7之前的版本中）。 从以上两个我们可以看出元素偏移量（offset）与客户区大小（client）的区别在于有没有包含边框，客户区大小不包含边框。 ","date":"2016-08-03","objectID":"/posts/2016-jsposition/:0:2","series":null,"tags":["Javascript"],"title":"JS中的位置与大小","uri":"/posts/2016-jsposition/"},{"categories":["Javascript"],"content":"3.滚动大小 scrollWidth和scrollHeight主要用于确定元素内容的实际大小。所以带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight。 ","date":"2016-08-03","objectID":"/posts/2016-jsposition/:0:3","series":null,"tags":["Javascript"],"title":"JS中的位置与大小","uri":"/posts/2016-jsposition/"},{"categories":["Javascript"],"content":"4.窗口大小 在现代主流浏览器中提供了四个属性确定窗口的大小，分别为：innerWidth、innerHeight、outerWidth和outerHeight。 4.1. outerWidth和outerHeight 返回浏览器窗口本身的尺寸（无论是从外层的window对象还是从某个框架访问） 4.2. innerWidth和innerHeight 返回该容器中页面试图去的大小（减去边框宽度） 注意： 这里在《javascript高级程序设计》（第三版）中写道在chrome中outer与inner返回的值是一样的，这算是chrome的一个bug，我在chrome 53中已经修复，但是在QQ浏览器中（内核为chromium47）依旧是相等的，这需要注意！ clientWidth和clientHeight。 在主流浏览器中，document.docuementElement.clientWidth和document.documentElement.clientHeight中保存的是页面视口信息。返回的值与window.innerHeight，window.innerWidth一样。 但是window.innerHeight在IE8及以下浏览器中结果是undefined，而document.documentElement.clientHeight还有值。所以在各个浏览器下取得页面视口大小的代码如下： var pageWidth=window.innerWidth, pageHeight=window.innerHeight; if(typeof pageWidth !== 'number'){ if(document.compatMode === 'CSS1Compat'){ pageWidth=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; }else{ pageWidth=document.body.clientWidth; pageHeight=document.body.clientHeight; } } 代码中document.compatMode用于判断浏览器处于什么模式，它有两个值： BackCompat:浏览器处于怪异模式 CSS1Compat:浏览器处于标准模式 不同模式下，获取浏览器的宽度的方法不同，在代码中已经做了判断。 ","date":"2016-08-03","objectID":"/posts/2016-jsposition/:0:4","series":null,"tags":["Javascript"],"title":"JS中的位置与大小","uri":"/posts/2016-jsposition/"},{"categories":["Javascript"],"content":" 在ECMAScript中最常用的类型之一就是Array类型，Array类型的方法也有很多，所以在这篇文章中，梳理一下Array类型的方法。 ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:0:0","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Javascript"],"content":"新建数组 新建数组的方法有三种： /*方法一*/ var a = new Array(1,2,3); /*方法二*/ var b = [1,2,3]; /*方法三（ES6新增）*/ var c = Array.of(1,2,3); Array.of()是ES6中新增的将一组值转换为数组的方法，该方法的出现时为了弥补构造函数Array()因为参数不同导致的不同行为。 Array() //[] Array(3) //[ , , ] Array(1,2,3) //[1,2,3] 从上面可以看出，只有在参数个数不少于2时候，才会返回新的数组。 ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:1:0","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Javascript"],"content":"数组的检测 对于一个网页或者一个全局作用域而言，使用instanceof操作符检测，通过返回的boolean值可以得出是否为数组，但是这样检测的问题在如果网页中包含两个以上不同的全局作用域，就会从在两个以上不同版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原声创建的数组分别有不同的构造函数。 在ES5中引入的Array.isArray()解决了这个问题，但如果在不支持ES5的浏览器中检测数组，则需要些兼容性方法，所以检测数组的方法如下： function checkArray(arr) { if(typeof Array.isArray){ return Array.isArray(arr); }else{ return Object.prototype.toString.call(arr)==='[object Array]'; } } ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:2:0","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Javascript"],"content":"数组中的方法： ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:3:0","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Javascript"],"content":"更改原数组 添加项 push():接收任意数量的参数，逐个将其添加至数组末尾，返回修改后的数组的长度 unshift():在数组的前端添加任意个项并返回新数组的长度 移除项 pop():从数组末尾移除最后一项，返回移除的项 shift():移除数组中的第一项并返回该项 排序 reverse():反转数组项的顺序 var values = [1,2,3,4,5]; values.reverse(); console.log(values); // =\u003e5,4,3,2,1 sort():按照升序排列数组项，但是它在实现排序时会调用每个数组项的toString()放法，去比较字符串，所以会出现如下情况 var values = [0,1,5,10,15]; values.sort(); console.log(values); // =\u003e 0,1,10,15,5 为了在使用sort()方法时返回正确的排序，我们需要给sort()传入一个比较函数，该比较函数传入两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。 /*升序 降序则更改返回值即可*/ function compare(value1,value2){ if(value1 \u003c value2){ return -1; }else if(value1 \u003e value2){ return 1; }else { return 0; } } var values = [0,1,5,10,15]; values.sort(compare); console.log(values); 对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个简单的比较函数 function compare(value1,value2){ return value2 - value1; } 截取 slice():接受一个或两个参数，要返回的起始位置到结束位置但不包括结束位置项，如果只写一个参数则截取数组到最后。可以接收负数作为参数 splice():做多可以接收三个参数，分别为起始位置，要删除的项目数，要插入的任意数量的项，同个这三个参数是否传入可以实现删除，插入，替换 var colors =['red','green','blue']; var removed =colors.splice(0,1); //删除第一项 console.log(colors); //green,blue console.log(removed); //redm,返回的数组中只包含一项 removed = colors.splice(1,0,'yellow','orange'); //从位置1开始插入两项 console.log(colors); //green,yellow,orange,blue console.log(removed); //返回的是一个空数组 removed = color.splice(1,1,'red','purple'); //插入两项，删除一项 console.log(colors); //green,yellow,purple,orange,blue console.log(removed); //返回yellow copyWithin() 参数： target(必需)：从该位置开始替换数据 start (可选)：从该位置开始读取数据，默认为0。如果为负值，表示倒数 end (可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值表示倒数 在当前数组内部将指定位置的成员复制到其他位置，会覆盖原来的成员。修改原来的数组形成新的数组 var a = [1,2,3]; var b = a.copyWithin(0); // =\u003e[1,2,3] var c = a.copyWithin(0,1); // =\u003e[2,3,3] var d = a.copyWithin(0,1,2);// =\u003e[2,2,3] 上面例子可以看出，虽然copyWithin的后两个参数是可选的，但是需要写第二个参数，否则返回的只是原数组本身。 ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:3:1","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Javascript"],"content":"不更改原素组，生成新数组 操作方法 concat():这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾并返回副本。 var a = [1,2,3]; var b = a.concat('a','b',['c','d','e']); console.log(a); // =\u003e1,2,3 console.log(b); 寻找 1.indexOf()、lastIndexOf()与includes() indexOf()与lastIndexOf()用于查找数组中是否有该方法，如果有则返回该元素的位置，否则返回-1。 但是这个方法有两个缺点： 不够语义化 它内部使用严格等于运算符===，导致了对NaN的误判。所以ES7新增includes()去克服这些缺点。 ES7新增 ES7中新增includes()方法，用于查找数组总是否包含某个元素，返回布尔值，接受两个参数要查找的元素和查找的起始位置。 2.find()和findIndex() 参数：一个回掉函数 回调的参数：当前值、当前位置、原数组 find()方法用于找出第一个符合条件的数组成员。 findIndex()方法返回第一个符合条件的数组成员的位置，如果所有成员都不符合，则返回-1。 var a = [1,4,-5,10]; a.find((n)=\u003e n\u003c0); // -5 var b = [1,5,10,15]; b.findIndex(function(value,index,arr){ return value \u003e 9; });//=\u003e2 迭代方法 ES5为数组定义了五个迭代方法 每个方法都接收两个参数：要在每一项上运行的函数和*（可选的）运行该函数的作用域对象*—-影响this的值。 传入这些方法中的函数会接收三个参数：*数组项的值*、*该项在数组中的位置*和*数组对象本身*。 every():对数组中的每一项运行给定的函数，如果该函数对每一项都返回true,则返回true some():对数组中每一项运行给定的函数，如果该函数对任一项返回true，则返回true filter():对数组中每一项运行给定的函数，返回该函数会返回true的项组成的数组 forEach():对数组中的每一项运行给定的函数。没有返回值 map():对数组中的每一项运行给定的函数，返回每次调用的结果组成的数组 归并方法 reduce() 该方法可以传递两个参数：化简函数，传递给函数的初始值（可选）。 化简函数的参数：到目前为止的化简操作累积的结果，数组元素，元素的索引，数组本身。 这个方法，可以用于求数组元素的和、积、最大值。 var a = [1,2,3,4,5] /*求和*/ var sum = a.reduce((x,y)=\u003ex+y,0); /*求积*/ var product = a.reduce((x,y)=\u003ex*y,1); /*求最大值*/ var max = a.reduce((x,y)=\u003e(x\u003ey)?x:y); 这个方法的简单用法就是这样，在《javascript高级程序设计》（第三版）中只是介绍了这个用法，但是在《javascript权威指南》（第六版）中提到了reduce的高级用法。 例1：求任意数目对象的“并集” /* 返回一个新对象，这个对象同时拥有o和p的属性 如果o和p中有重名属性，使用p中属性 */ function union(o,p){ return extend(extend({},o),p); } var objects = [{x:1},{y:2},{z:3}]; var merged = objects.reduce(union); // =\u003e{x:1,y:2,z:3} 例2：统计字符串中每个字符出现的重复次数 var arr = 'abcdabcdadbc'; var info = arr.split('').reduce((p,k) =\u003e (p[k]++ || (p[k] = 1), p), {}); console.log(info); //=\u003e Object {a: 3, b: 3, c: 3, d: 3} 这两个例子，尤其是第二个例子可以看出，reduce()并不单单只是用于数学计算，在第二个例子中可以明显看出在reduce()第二个参数传入一个空对象，此时它最终返回的就是一个对象。由于本身传入的初始值是对象，所以返回对象。如果传入一个空数组，则返回数组。所以可以看出，最终reduce()函数返回什么，取决于第二个参数的形式。 join() Array.join()方法将数组中的所有元素都转化为字符串并连接起来，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中分隔数组的各个元素，如不指定，默认用逗号隔开。 fill() 参数：填充项、填充的起始位置、填充的结束位置 fill()方法用于使用给定的值填充数组。 new Array(3).fill(7); //=\u003e[7,7,7] ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:3:2","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Javascript"],"content":"转换为数组的方法(ES6新增) Array.from(); 该方法接收两个参数要转换的非数组对象,对每个元素进行处理的方法（可选） 在js中，有很多类数组对象（array-like object）和可遍历（iterable）对象（包括ES6新增的数据结构Set和Map），常见的类数组对象包括document.querySelectorAll()取到的NodeList，以及函数内部的arguments对象。它们都可以通过Array.from()转换为真正的数组，从而使用数组的方法。事实上只要对象具有length属性，就可以通过Array.from()转换为真正的数组。 var a = { 0:'li', 1:'li', 2:'li', length:3 }; console.log(Array.from(a)); // =\u003e ['li','li','li']; Array.from([1,2,3],(x)=\u003ex*x); // =\u003e1,4,9 扩展运算符（…） //arguments对象 function foo(){ var args = [...arguments]; } //nodelist [...document.querySelectorAll('div')]; ","date":"2016-08-03","objectID":"/posts/2016-jsarray/:4:0","series":null,"tags":["Javascript"],"title":"Javascript中Array方法的总结","uri":"/posts/2016-jsarray/"},{"categories":["Vue"],"content":" 最近一段时间忙着工作的一些事情，同时自己也在试着把项目中的一些移动端页面试着用vuejs重写，所以没时间写文章，今天终于有空可以写一下，由于页面并没有写完，所以就将自己这几天做页面的时候遇到的一些问题总结了一下。其实很多在官网都能找到，但是我们只看官网教程不去写，很难理解到底是什么意思，这里我把我用到的列出来。 文章中提到的很多东西都在我的demo中用到，demo地址 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:0:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"1.Vuejs组件 vuejs构建组件使用 Vue.component('componentName',{ /*component*/ })； 这里注意一点，组件要先注册再使用，也就是说： Vue.component('mine',{ template:'#mineTpl', props:['name','title','city','content'] }); var v=new Vue({ el:'#vueInstance', data:{ name:'zhang', title:'this is title', city:'Beijing', content:'these are some desc about Blog' } }); 如果反过来会报错，因为反过来代表先使用了组件的，但是组件却没注册。 webpack报错后，使用webpack --display-error-details可以排错 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:1:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"2.指令keep-alive 在看demo的时候看到在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令 \u003ccomponent :is='curremtView' keep-alive\u003e\u003c/component\u003e ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:2:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"3.如何让css只在当前组件中起作用 在每一个vue组件中都可以定义各自的css，js，如果希望组件内写的css只对当前组件起作用，只需要在style中写入scoped，即： \u003cstyle scoped\u003e\u003c/style\u003e ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:3:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"4.vuejs循环插入图片 在写循环的时候，写入如下代码： \u003cdiv class=\"bio-slide\" v-for=\"item in items\"\u003e \u003cimg src=\"{{item.image}}\"\u003e \u003c/div\u003e 此时在控制台会出现警告 [Vue Warn]: src=\"{{item.image}}\": interpolation in \"src\" attribute will cause a 404 request. Use v-bind:src instead.这里意思是在“src”属性插值将导致404请求。使用v-bind：src代替。 所以替换成如下： \u003cdiv class=\"bio-slide\" v-for=\"item in items\"\u003e \u003cimg v-bind:src=\"item.image\"\u003e \u003c/div\u003e 这里需要主要，v-bind在写的时候不能再用双花括号，根据官方的说法： \u003ca v-bind:href=\"url\"\u003e\u003c/a\u003e 这里href是参数，它告诉 v-bind 指令将元素的 href 特性跟表达式 url 的值绑定。可能你已注意到可以用特性插值 href=\"{{url}}\" 获得同样的结果：这样没错，并且实际上在内部特性插值会转为 v-bind 绑定。 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:4:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"5.绑定value到Vue实例的一个动态属性上 对于单选按钮，勾选框及选择框选项，v-model绑定的value通常是静态字符串（对于勾选框是逻辑值）： \u003c!-- `toggle` 为 true 或 false --\u003e \u003cinput type=\"checkbox\" v-model=\"toggle\"\u003e 但是有时候想绑定value到vue实例的一个动态属性上，这时可以用v-bind实现，并且这个属性的值可以不是字符串。例如绑定Checkbox的value到vue实例的一个动态属性： \u003cinput type=\"checkbox\" v-model=\"toggle\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"\u003e \u003cp\u003e{{toggle}}\u003c/p\u003e 这里绑定后，并不是说就可以点击后由true,false的切换变为a,b的切换，因为这里定义的动态a，b是scope上的a,b，并不能直接显示出来，此时 //当选中时 vm.toggle === vm.a //当没选中时 vm.toggle === vm.b 所以此时需要在data中定义a,b，即： new Vue({ el:'...', data:{ a:'a', b:'b' } }); ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:5:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"6.片段实例 下面几种情况会让实例变成一个片断实例： 模板包含多个顶级元素。 模板只包含普通文本。 模板只包含其它组件（其它组件可能是一个片段实例）。 模板只包含一个元素指令，如\u003cpartial\u003e 或 vue-router 的 \u003crouter-view\u003e。 模板根节点有一个流程控制指令，如v-if或 v-for。 这些情况让实例有未知数量的顶级元素，它将把它的 DOM 内容当作片断。片断实例仍然会正确地渲染内容。不过，它没有一个根节点，它的$el 指向一个锚节点，即一个空的文本节点（在开发模式下是一个注释节点）。 但是更重要的是，组件元素上的非流程控制指令，非 prop 特性和过渡将被忽略，因为没有根元素供绑定： \u003c!-- 不可以，因为没有根元素 --\u003e \u003cexample v-show=\"ok\" transition=\"fade\"\u003e\u003c/example\u003e \u003c!-- props 可以 --\u003e \u003cexample :prop=\"someData\"\u003e\u003c/example\u003e \u003c!-- 流程控制可以，但是不能有过渡 --\u003e \u003cexample v-if=\"ok\"\u003e\u003c/example\u003e 片段实例也有用处，但是通常情况下组件有一个根节点比较好，它会保证组件元素上的指令和特性能正确的转换，同时性能也稍微好些。 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:6:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"7.路由嵌套 路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转router-view本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写到： var App = Vue.extend({ root }); router.start(App,'#app'); 这里首先将根组件注册进来，用于将路由中配置好的各个页面渲染出来，然后将根组件挂载到与#app匹配的元素上。 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:7:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"8.实现多个根据不同条件显示不同文字的方法 v-if,v-else可以实现条件选择，但是如果是多个连续的条件选择，则需要用到计算属性computed。例如实现当输入框中什么都没写的时候显示字符串‘empty’,否则显示输入框中的内容，代码如下： \u003cdiv id=\"test\"\u003e \u003cinput type=\"text\" v-model=\"inputValue\"\u003e \u003ch1\u003e{{changeVaule}}\u003c/h1\u003e \u003c/div\u003e new Vue({ el:'#test', data:{ changeVaule:'123' }, computed :{ changeVaule:function(){ if(this.inputValue!==''){ return this.inputValue; }else{ return 'empty'; } } } }); ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:8:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"9.Vuejs在变化检测问题 1.检测数组 由于javascript的限制，vuejs不能检测到下面数组的变化： 直接索引设置元素，如vm.item[0]={}; 修改数据的长度，如vm.item.length。 为了解决问题1，Vuejs扩展了观察数组，为它添加一个$set()方法： // 与 `example1.items[0] = ...` 相同，但是能触发视图更新 example1.items.$set(0, { childMsg: 'Changed!'}) 问题2，需要一个空数组替换items。 除了$set()，vuejs也为观察数组添加了$remove()方法，用于从目标数组中查找并删除元素，在内部调用了splice()。因此，不必： var index = this.items.indexOf(item) if (index !== -1) { this.items.splice(index, 1) } 只需： this.items.$remove(item); 2.检测对象 受ES5的显示，Vuejs不能检测到对象属性的添加或删除。因为Vuejs在初始化时候将属性转化为getter/setter，所以属性必须在data对象才能让Vuejs转换它，才能让它是响应的，例如： var data = { a: 1 } var vm = new Vue({ data: data }) // `vm.a` 和 `data.a` 现在是响应的 vm.b = 2 // `vm.b` 不是响应的 data.b = 2 // `data.b` 不是响应的 不过，有办法在实例创建之后添加属性并且让它是响应的。对于Vue实例，可以使用$set(key,value)实例方法： vm.$set('b', 2) // `vm.b` 和 `data.b` 现在是响应的 对于普通数据对象，可以使用全局方法Vue.set(object, key, value): Vue.set(data, 'c', 3) // `vm.c` 和 `data.c` 现在是响应的 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 添加属性。但是，添加到对象上的新属性不会触发更新。这时可以创建一个新的对象，包含原对象的属性和新的属性： // 不使用 `Object.assign(this.someObject, { a: 1, b: 2 })` this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:9:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"10.关于vuejs页面闪烁{{message}} 在vuejs指令中有v-cloak，这个指令保持在元素上直到关联实例结束编译。和CSS规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。用法如下： [v-cloak]{ display:none; } \u003cdiv v-cloak\u003e{{message}}\u003c/div\u003e 这样\u003cdiv\u003e不会显示，直到编译结束 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:10:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"11.关于在v-for循环时候v-model的使用 有时候需要循环生成input，用v-model绑定后，利用vuejs操作它，此时我们可以在v-model中写一个数组selected[$index]，这样就可以给不同的input绑定不同的v-model，从而分别操作他们。这个我在demo中的dataBind.vue中用到。 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:11:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["Vue"],"content":"12.vuejs中过渡动画 在vuejs中，css定义动画： .zoom-transition{ width:60%; height:auto; position: absolute; left:50%; top:50%; transform: translate(-50%,-50%); -webkit-transition: all .3s ease; transition: all .3s ease; } .zoom-enter, .zoom-leave{ width:150px; height:auto; position: absolute; left:20px; top:20px; transform: translate(0,0); } 其中动画在定的时候要注意上下对应，上面有什么，下面有什么，都要变化的，如果有不变化的，应该抽离出去，作为公共css样式，在上面的css中，如果我只写 transform: translate(-50%,-50%);而不写下面的transform: translate(0,0);则会导致上面的transform: translate(-50%,-50%);被添加到下面，认为这个是不变的。 ","date":"2016-07-14","objectID":"/posts/2016-summarizevue/:12:0","series":null,"tags":["Vue"],"title":"Vuejs的一些总结","uri":"/posts/2016-summarizevue/"},{"categories":["感悟"],"content":" 不知不觉中，六月已经过去，七月悄悄到来，写这篇文章，总结六月，并给七月做一些计划。在未来，每个月都会做一次总结，无论得失，都记录下来，记录自己的成长。 六月结束，2016年也已过去一半。六月收获很多，无论是工作还是生活。在2015年年底的时候我曾经计划，在2016年要学习新的编程上的技术，每天跑步，学吉他，多读书。在六月，我终于全部开始做了。 ","date":"2016-06-30","objectID":"/posts/2016-summarizejune/:0:0","series":null,"tags":["感悟"],"title":"六月总结","uri":"/posts/2016-summarizejune/"},{"categories":["感悟"],"content":"技能 六月上旬的时候，因为公司没什么事儿，我又开始研究vuejs，其实关于vuejs，我很早的时候就知道了，记得去年的时候我关注勾三股四大神的微博，第一次知道vue，后来有看过vuejs的官方文档，但是由于自己在之前没有接触过MVVM框架，所以看起来非常吃力，根本看不懂官方的教程在说什么。前前后后看过也有那么两三次了，期间我也有意无意的关注过关于MVVM的一些概念什么的，并在掘金和segmentfault上面关注关于vue的文章，现在vue很火，所以文章也比较好找很多了，另外这两个网站不错，推荐给大家。 这个月开始研究vue的时候，在segmentfault上面看到两篇关于vue的非常基础的文章，分别是从零开始学Vue和组件改变生活_揭开Vue组件的神秘面纱。正是这两篇文章让我开始真正的走进vue，而vue + webpack 起手式，让我开始了解webpack与vue是怎么配合从而实现利用vue写组件。正是这三篇文章，开始让我对vue和webpack有了了解并开始写一些demo，我把demo上传到了github，我的demo地址。 其实我公司的业务没有用到vue，那为什么我去学呢，其实我觉得我自己学一些东西，就是好奇，现在的前端，模块儿化，MVVM，双向数据绑定等等一些东西的出现，让我感觉很好奇，我想知道为什么这些东西很受欢迎，为什么会火，所以才去慢慢的了解它，选择一个代表去学习它，当然了，如果将来有机会，我会把vue用到公司的项目中，给公司的前端技术带来新的东西（说实话现在我们公司依然用传统的前端开发模式让我觉得有点儿low了，哈哈）。正是这种好奇心驱使着我不断去探索一些对我来说的新东西，而前端变化太快，总有一些新东西可以让我去探索，这也是我选择前端，喜欢前端的重要原因。貌似扯的有点儿远了，哈哈。对了，就在上午，CTO让我下周分享vuejs的一些用法和心得，我很荣幸可以去给公司分享这些东西，只是我得认真准备一下啦，这个比较麻烦一点儿，嘿嘿。 六月中旬的时候，我决定买把吉他玩，因为那时候我迷上了民谣，听赵雷的歌，像南方姑娘，未给姐姐寄出的信等等，决定买一个，其实我以前也听一些纯音乐，像钢琴，小提琴，吉他等等，但是为什么我选择吉他呢，因为吉他便宜，哈哈哈。我自己是程序员，我认为码代码是我的工作，但不能是我生活的全部，我不能一天到晚码代码，所以我搞了把吉他玩儿，在此之前从未对音乐这么认真过，小时候上过音乐课，但是和没上过一样，原因大家应该都懂的，哈哈。说实话，学吉他可不简单，自己本身有点儿胖，指头上的肉也不少，刚开始按的时候真的是，非常疼啊，不过我既然决定要学了，就要学会它，这半个月来，几乎每天都会抽出点儿时间来去练习，我的第一个目标就是能弹唱《南方姑娘》，为了这个目标，我得努力了。 ","date":"2016-06-30","objectID":"/posts/2016-summarizejune/:0:1","series":null,"tags":["感悟"],"title":"六月总结","uri":"/posts/2016-summarizejune/"},{"categories":["感悟"],"content":"成长 六月开始我每天看会儿书，这个书不是编程的书，而是一些其他的书。其实我本身并不爱看书，小时候觉得看不看无所谓，我想看就看看，不想看就不看，没什么，但是越长大越觉得确实应该多读书，读书可以让我看到不一样的世界，不是有人说过么“现代人的问题在于读书太少而想的太多”，我想这也是烦恼的最大的来源，有时候我也很烦，所以我要努力做一个读书多的人。读的书越多，接触到的就越多，懂的也就越多。努力多读书，学会做人做事，这是我的目标。 六月月底的时候，因为粗心在合并代码的时候把别人的给覆盖了，这让我们测试很生气，虽然并没有骂，但是看的出来，很生气，我也知道确实是自己的问题，所以不知道该说什么，只能默默的把原来的代码拷贝出来，然后把自己的功能加进去。事后在回家的路上我给我们测试发了QQ信息，给他道歉，我们测试也接受了我的道歉。六月底的时候我开始读卡耐基的《人性的弱点》，虽热在写本文的时候还没读完，但是我从前面的几个章节看得出来，它其实想告诉人们，做人最重要的是真诚，真心，错了就是错了，不需要辩解，给别人造成麻烦了，就要道歉，这是我悟到的一个道理，也算是一次成长吧。 ","date":"2016-06-30","objectID":"/posts/2016-summarizejune/:0:2","series":null,"tags":["感悟"],"title":"六月总结","uri":"/posts/2016-summarizejune/"},{"categories":["感悟"],"content":"新计划 七月开始了，计划在这个月依旧学习vue，并改造公司移动端的项目，同时继续学习ES6，之前虽然学过，但是并没学完，七月继续。同时要每天跑步，说是跑步，不如说是对自己的一种在意志上的一种锻炼，一种坚持做一件事的态度。吉他练得虽然手疼吧，但是既然想学，就学好。从六月开始每个月都总结一下，记录自己一步步的成长，记录得与失，活出精彩，做最好的自己。 ","date":"2016-06-30","objectID":"/posts/2016-summarizejune/:0:3","series":null,"tags":["感悟"],"title":"六月总结","uri":"/posts/2016-summarizejune/"},{"categories":["Vue"],"content":"基于Vue的简单的单页面应用 在对Vue和webpack有了一定了解后，我们就可以开始利用所了解的东西做一个简单的webapp了，不了解的同学可以看下我的前两篇关于vue和webpack的基本应用： webpack+vue起步 利用webpack和vue实现组件化 ","date":"2016-06-08","objectID":"/posts/2016-vue1/:1:0","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"构建项目 首先创建各个组件，我的目录结构如下： //没有后缀名的都是文件夹 |-wechat |-dist |-src | |-components //存放vue组件 | | |-tab //存放home.vue中的tab，动态切换的模板 | | | |-tab_1.vue | | | |-tab_2.vue | | |-home.vue //app的首页 | | |-list.vue //点击home中的链接跳转到 | | |-detail.vue //点击list中的链接跳转到 | |-app.vue //主要的vue文件(用于将各个组件的挂载) | |-main.js //主要的js(用于配置路由) |-static //存放静态资源 |-index.html ","date":"2016-06-08","objectID":"/posts/2016-vue1/:2:0","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"配置路由 首先在我们的项目中安装vue-router npm install vue-router 引入各个组件并配置路由： //main.js import Vue from 'vue'; import VueRouter from 'vue-router'; //引入组件 import App from './app.vue'; import home from './components/home.vue'; import list from './components/list.vue'; import detail from './components/detail.vue'; Vue.use(VueRouter); var app=Vue.extend(App); var router=new VueRouter(); //配置路由 router.map({ '/home': { component: home }, '/list': { component: list }, '/detail': { component: detail } }); //设置默认情况下打开的页面 router.redirect({ '/':'home' }); router.start(app,'#app'); //暴露路由接口调试 window.router = router; 关于vue-router的介绍，官方文档介绍很清楚，地址：http://router.vuejs.org/zh-cn/index.html。 配置好路由后，需要将匹配好的组件正确的渲染到页面中，此时用到\u003crouter-view\u003e\u003c/router-view\u003e，它基于Vue的动态组件系统，所以它会继承一个正常动态组件的很多特性。在这里我们用到两个： v-transition和transition-mode的完整支持，为了切换效果能正常工作，路由组件必须不是一个片段实例。 在路由的0.7.2+中支持keep-alive（关于keep-alive） 所以在app.vue写入： \u003ctemplate\u003e \u003cdiv class=\"main\"\u003e \u003crouter-view keep-alive transition=\"fade\" transition-mode='out-in'\u003e\u003c/router-view\u003e \u003c/div\u003e \u003c/template\u003e 打开命令行启动webpack-dev-server： $ webpack-dev-server --inline --hot 此时我们在页面中看到的页面就是home.vue ","date":"2016-06-08","objectID":"/posts/2016-vue1/:3:0","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"在home.vue中实现tab切换 tab切换作为一个常见的效果，出现的频率很高，那么如何用vuejs写一个tab切换效果呢？ 利用当前被点击的tab是第几个，从而动态的切换相应的动态组件是vuejs实现切换的一种方式。动态组件的介绍如下：https://vuejs.org.cn/guide/components.html#动态组件。所以实现代码如下： \u003ctemplate\u003e \u003cdiv class=\"home\"\u003e \u003cdiv class=\"bd\" style=\"height: 100%;\"\u003e \u003cdiv class=\"weui_tab\"\u003e \u003cul class=\"weui_navbar\"\u003e \u003cli class=\"weui_navbar_item\" v-for=\"tab in tabs\" :class=\"{'weui_bar_item_on':$index===selected}\" @click=\"choose($index)\"\u003e{{tab.tabName}}\u003c/li\u003e \u003c/ul\u003e \u003cdiv class=\"weui_tab_bd\"\u003e \u003ccomponent :is=\"currentView\" transition=\"fade\" transition-mode=\"out-in\"\u003e\u003c/component\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import tab_1 from './tab/tab_1.vue'; import tab_2 from './tab/tab_2.vue'; export default{ data(){ return{ tabs:[ {tabName:'Vuejs'}, {tabName:'VueTab'} ], selected:0, currentView:'view_0' } }, components:{ 'view_0':tab_1, 'view_1':tab_2 }, methods:{ choose(index) { this.selected=index; this.currentView='view_'+index; } } } \u003c/script\u003e 两个动态组件为tab_1.vue和tab_2.vue。引入这两个模块，对外输出对组件的操作export default{}，在template模板中将动态组件加载进去，使用保留的\u003ccomponent\u003e元素，动态地绑定它的is特性，从而根据不同的值动态的切换组件，在需要点击的tab导航上，需要v-for循环出两个导航，然后动态绑定class，根据当前点击的tab导航$index动态的切换class名:class=\"{'weui_bar_item_on':$index===selected}\"，然后给li绑定click事件，从而让其在被点击时执行事件@click=\"choose($index)\"。 由于默认情况下显示第一个组件且第一个tab变灰，所以在data设置默认值。为了切换有过渡，添加了transition=\"fade\" transition-mode=\"out-in\"并在css中设置动画的执行过程： /*切换动画*/ .fade-transition { transition: opacity 0.3s ease; } .fade-enter, .fade-leave { opacity: 0; } ","date":"2016-06-08","objectID":"/posts/2016-vue1/:4:0","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"利用v-link实现路由链接 在组件中，用到了路由，在给a写路由链接时候要使用v-link而不是href。在带有v-link指令的元素，如果v-link对应的URL匹配当前路径，则该元素会被添加一个特定的class，默认为.v-link-active，这个默认值，我们可以通过在创建路由时指定linkActiveClass全局选项来自定义，也可以通过activeClass内联选项来单独制定： \u003ca v-link=\"{path:'/a',activeClass:'active'}\"\u003etest\u003c/a\u003e ","date":"2016-06-08","objectID":"/posts/2016-vue1/:5:0","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"遇到的一些问题 ","date":"2016-06-08","objectID":"/posts/2016-vue1/:6:0","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"1.v-for循环插入图片 在写循环插入图片的时候，写的代码如下： \u003cdiv class=\"bio-slide\" v-for=\"item in items\"\u003e \u003cimg src=\"{{item.image}}\"\u003e \u003c/div\u003e 此时在控制台会出现警告 [Vue Warn]: src=\"{{item.image}}\": interpolation in \"src\" attribute will cause a 404 request. Use v-bind:src instead. 这里意思是在src属性插值将导致404请求。使用v-绑定：src代替。 所以替换成如下： \u003cdiv class=\"bio-slide\" v-for=\"item in items\"\u003e \u003cimg v-bind:src=\"item.image\"\u003e \u003c/div\u003e 这里需要主要，v-bind在写的时候不建议再用双花括号，根据官方的说法： \u003ca v-bind:href=\"url\"\u003e\u003c/a\u003e 这里href是参数，它告诉 v-bind 指令将元素的 href 特性跟表达式 url 的值绑定。可能你已注意到可以用特性插值 href=\"{{url}}\" 获得同样的结果：这样没错，并且实际上在内部特性插值会转为 v-bind 绑定。 ","date":"2016-06-08","objectID":"/posts/2016-vue1/:6:1","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"2.v-model的使用 v-model用于在表单上创建双向绑定，只能用于\u003cinput\u003e、\u003cselect\u003e、\u003ctextarea\u003e，如果用在其他元素中，则会在产生警告。 ","date":"2016-06-08","objectID":"/posts/2016-vue1/:6:2","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":"3.如何让组件的CSS样式只在组件中起作用 在每一个vue组件中都可以定义各自的css，js，如果想写的css只对当前组件起作用，则在style中写入scoped，即： \u003cstyle scoped\u003e\u003c/style\u003e 这样就完成了一个简单的基于Vue+webpack+vue-router的单页面应用，具体实现代码见github:vue_spa_demo。 ","date":"2016-06-08","objectID":"/posts/2016-vue1/:6:3","series":null,"tags":["Vue"],"title":"基于Vue的简单的单页面应用","uri":"/posts/2016-vue1/"},{"categories":["Vue"],"content":" 上一篇webpack+vue起步我们实现了用webpack打包vue的最基本用法，这篇我们将利用webpack+vue实现组件化 在vue中实现组件化用到了vue特有的文件格式.vue，在每一个.vue文件就是一个组件，在组件中我们将html，css，js全部写入，然后在webpack中配置vue-loader就可以了。 ","date":"2016-06-02","objectID":"/posts/2016-webpackvue2/:0:0","series":null,"tags":["Vue"],"title":"利用webpack和vue实现组件化","uri":"/posts/2016-webpackvue2/"},{"categories":["Vue"],"content":"建立vue组件 在src目录下建立components文件夹，并在其中建立app.vue文件，这样我们项目的目录结构如下： |--dist //webpack打包后生成的文件夹 | |--build.js |--node_modules //项目的依赖所在的文件夹 |--src //文件入口 | |--components //组件存放文件夹 | |--app.vue //组件 | |--main.js //主js文件 |--index.html //主html文件 |--package.json |--webpack.config.js //webpack配置文件 首先在index.hmtl中写入代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eVue example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003capp\u003e\u003c/app\u003e \u003cscript src=\"dist/build.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 在编辑器中打开app.vue文件，写入如下代码： \u003ctemplate\u003e \u003cdiv class=\"message\"\u003e{{msg}}\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data () { return { msg: 'Hello from vue-loader' } } } \u003c/script\u003e \u003cstyle\u003e .message{ color:red; font-size:36px; font-weight:blod; } \u003c/style\u003e 在main.js中写入： import Vue from 'vue' import App from './components/app.vue' new Vue({ el: 'body', components:{App} }); 这样运行命令webpack就可以看到效果了 这里用到了ES6的模块儿—import，export export命令 export命令用于规定模块的对外接口。一个模块就是一个独立文件。该文件内的所有变量外部都无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字对外暴露出该变量。例如： //export.js export var firstName = 'Michael'; export var lastName = 'Jackson'; export var year = 1958; 这样就可以对外输出三个变量。 import命令 使用export对外暴露了接口后，其他js文件通过import命令加载这个模块文件。上面暴露的三个变量在另一个js文件中引入如下： //import.js import {firstName,lastName,year} from './export'; function setName(element){ element.textContent = firstName + ' ' + lastName; } ","date":"2016-06-02","objectID":"/posts/2016-webpackvue2/:1:0","series":null,"tags":["Vue"],"title":"利用webpack和vue实现组件化","uri":"/posts/2016-webpackvue2/"},{"categories":["Vue"],"content":"webpack的hot-reload 前端自动刷新现在已经很常见了，即改变页面后，浏览器自动刷新，但是这个功能在我们做单页面应用时候会很不好用，所以，webpack支持hot-reload(热替换)，当我们修改模块时候不会页面不会刷新，会直接在页面中生效。 ","date":"2016-06-02","objectID":"/posts/2016-webpackvue2/:2:0","series":null,"tags":["Vue"],"title":"利用webpack和vue实现组件化","uri":"/posts/2016-webpackvue2/"},{"categories":["Vue"],"content":"hot-reload的基础—webpack-dev-server webpack-dev-server支持两种模式的自动刷新页面： iframe模式（页面嵌入一个iframe并在其中呈现页面的变化） inline模式（一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面） iframe模式 使用iframe模式无需额外的配置，在dos下输入命令 $ webpack-dev-server 在浏览器中输入 http://loacalhost:8080/webpack-dev-server/index.html inline模式 在dos下输入命令 $ webpack-dev-server --inline --hot 启动服务器，在浏览器中打开 http://loacalhost:8080 就可以看到我们的页面，此时修改app.vue中的css，以及html中的文字，都可以看到在浏览器中立马呈现。 关于webpack-dev-server的详细说明，可以参考官方文档或者博客WEBPACK DEV SERVER。 ","date":"2016-06-02","objectID":"/posts/2016-webpackvue2/:2:1","series":null,"tags":["Vue"],"title":"利用webpack和vue实现组件化","uri":"/posts/2016-webpackvue2/"},{"categories":["Vue"],"content":"这里有一个问题需要说明下 在很多文章中都说，修改app.vue文件中script标签中的msg文字，会在浏览器中立即呈现效果，但是事实上我在做demo的时候并没有出现这个效果，Google了很多，找到了答案，尤大说：“data是初始值，但热更新的时候会保留当前状态”，原问题及答案链接。 至此，关于webpack+vue的基本结束，虽然简单，但是由于在这个过程中也遇到一些坑，所以总结下，关于对vue的研究，这才只是个开始… ","date":"2016-06-02","objectID":"/posts/2016-webpackvue2/:2:2","series":null,"tags":["Vue"],"title":"利用webpack和vue实现组件化","uri":"/posts/2016-webpackvue2/"},{"categories":["Vue"],"content":"附： 我的webpack配置文件： var path = require('path'); module.exports = { entry: './src/main.js', output: { path: './dist', publicPath:'dist/', filename: 'build.js' }, //配置自动刷新,如果打开会使浏览器刷新而不是热替换 /*devServer: { historyApiFallback: true, hot: false, inline: true, grogress: true },*/ module: { loaders: [ //转化ES6语法 { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, //解析.vue文件 { test:/\\.vue$/, loader:'vue' }, //图片转化，小于8K自动转化为base64的编码 { test: /\\.(png|jpg|gif)$/, loader:'url-loader?limit=8192' } ] }, vue:{ loaders:{ js:'babel' } }, resolve: { // require时省略的扩展名，如：require('app') 不需要app.js extensions: ['', '.js', '.vue'], // 别名，可以直接使用别名来代表设定的路径以及其他 alias: { filter: path.join(__dirname, './src/filters'), components: path.join(__dirname, './src/components') } } } package.json文件： { \"name\": \"webpackvue\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"vue.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.9.1\", \"babel-loader\": \"^6.2.4\", \"babel-plugin-transform-runtime\": \"^6.9.0\", \"babel-preset-es2015\": \"^6.9.0\", \"babel-preset-stage-0\": \"^6.5.0\", \"babel-runtime\": \"^6.9.2\", \"css-loader\": \"^0.23.1\", \"file-loader\": \"^0.8.5\", \"style-loader\": \"^0.13.1\", \"url-loader\": \"^0.5.7\", \"vue\":\"^1.0.24\", \"vue-router\":\"^0.7.13\", \"vue-hot-reload-api\": \"^1.3.2\", \"vue-html-loader\": \"^1.2.2\", \"vue-loader\": \"^8.5.2\", \"vue-style-loader\": \"^1.0.0\", \"webpack\": \"^1.13.1\", \"webpack-dev-server\": \"^1.14.1\", \"webpack-merge\": \"^0.13.0\" } } ","date":"2016-06-02","objectID":"/posts/2016-webpackvue2/:3:0","series":null,"tags":["Vue"],"title":"利用webpack和vue实现组件化","uri":"/posts/2016-webpackvue2/"},{"categories":["Vue"],"content":" 记得第一次知道Vue.js是在勾三股四大大的微博，那时候他开始翻译vue的文档，从那时候开始到现在，看了几次vue的教程，每次都有更深的理解，因为之前并没有研究过angular等框架，所以对MVVM并不是很了解，但是经过这段时间对vuejs的一些研究，越来越懂了，这篇文章，只是对vuejs和webpack配合的非常基础的文章，我想随着我对vue的深入理解，会对组件化，模块化，MVVM有更深入的理解。 ","date":"2016-05-31","objectID":"/posts/2016-webpackvue1/:0:0","series":null,"tags":["Vue"],"title":"webpack与vue起步","uri":"/posts/2016-webpackvue1/"},{"categories":["Vue"],"content":"项目的创建 1.新建项目文件夹，并在其中建立package.json $ mkdir [project name] $ cd [project name] $ npm init 2.在项目目录下新建index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eVue example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e{{message}}\u003c/div\u003e \u003cscript src=\"dist/build.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e src文件夹，并在该文件夹下建立main.js import Vue from 'vue' new Vue({ el:'body', data:{ message:'test success!' } }); ","date":"2016-05-31","objectID":"/posts/2016-webpackvue1/:1:0","series":null,"tags":["Vue"],"title":"webpack与vue起步","uri":"/posts/2016-webpackvue1/"},{"categories":["Vue"],"content":"设置webpack ","date":"2016-05-31","objectID":"/posts/2016-webpackvue1/:2:0","series":null,"tags":["Vue"],"title":"webpack与vue起步","uri":"/posts/2016-webpackvue1/"},{"categories":["Vue"],"content":"1.安装webpack，webpack-dev-server以及相关的loaders # 全局安装webpack，webpack-dev-server $ npm install -g webpack $ npm install -g webpack-dev-server # 为项目安装其他依赖 $ npm i webpack-merge css-loader style-loader file-loader url-loader babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-preset-stage-0 babel-runtime vue vue-loader vue-html-loader vue-style-loader vue-hot-reload-api -D webpack-merge：开发环境和生产环节的webpaak配置文件的配置合并 css-loader：编译写入css style-loader：把编译后的css整合进html file-loader：编译写入文件，默认情况下生成文件的文件名是文件名与MD5哈希值的组合 vue：vue主程序 vue-laoder：编译写入.vue文件 vue-html-loader：编译vue的template部分 vue-style-loader：编译vue的样式部分 vue-hot-reload-api：webpack对vue实现热替换 babel-core：ES2015编译核心 babel-loader：编译写入ES2015文档 babel-preset-es2015：ES2015语法 babel-preset-stage-0：开启测试功能 babel-runtime：babel执行环境 url-loader 这里介绍下url-loader，这个loader实际上是对file-loader的封装https://github.com/webpack/url-loader 比如CSS文件中有时候会这么写： .demo{ background-image: url('a.png'); } module:{ loaders:[ {test:/\\.(png|jpg)$/,loader:'url-loader?limit=8192'} ] } 经过以上配置，当a.png小于8K就会自动将图片转换成base64编码，如果不小于，则不会转换。 这里顺便提一句，在module配置的时候，loader的写法： module:{ loaders:[ {test:/\\.jade$/,loader:'jade'} //这里配置了让webpack识别jade的loader，其他类似，比如.vue //用于css文件的loader有两种写法 {test:/\\.css$/,loader:'style!css'} {test:/\\.css$/,loaders:['style','css']} ] } ","date":"2016-05-31","objectID":"/posts/2016-webpackvue1/:2:1","series":null,"tags":["Vue"],"title":"webpack与vue起步","uri":"/posts/2016-webpackvue1/"},{"categories":["Vue"],"content":"2.配置webpack.config.js 在根目录下建立webpack.config.js，配置如下： var path = require('path'); module.exports = { entry: './src/main.js', //定义webpack输出的文件，我们在这里设置了 让打包后生成的文件放在dist文件夹下的build.js文件中 output: { path: './dist', publicPath:'dist/', filename: 'build.js' }, module: { loaders: [ //转化ES6语法 { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, //图片转化，小于8K自动转化为base64的编码 { test: /\\.(png|jpg|gif)$/, loader:'url-loader?limit=8192' } ] }, //这里用于安装babel，如果在根目录下的.babelrc配置了，这里就不写了 babel: { presets: ['es2015','stage-0'], plugins: ['transform-runtime'] } } 特别说明 如果要在.babelrc下配置babel，则需要在根目录下新建该文件，windows环境下，不能新建该txt文件然后改后缀，需要通过dos命令建立： echo\u003e.babelrc 通过该命令就可以建立babelde配置文件，用编辑器打开，修改里面的内容为： { \"presets\": [\"es2015\", \"stage-0\"], \"plugins\": [\"transform-runtime\"] } 完成该配置我们在命令中运行 $ webpack 打开index.html就可以看到浏览器中看到我们刚刚写的文字 至此我们实现了最基本的利用webpack打包vue，下一篇将讲解如何利用webpack+vue真正实现组件化。 ","date":"2016-05-31","objectID":"/posts/2016-webpackvue1/:2:2","series":null,"tags":["Vue"],"title":"webpack与vue起步","uri":"/posts/2016-webpackvue1/"},{"categories":["Webpack"],"content":" 很早就听说webpack包管理工具，但是一直没有机会学习，这次又看到掘金上面有关于vue+webpack的初级文章，而且最近公司没什么事儿做，决定搞一下。在搞的过程中，虽然按照文章中写的去做，但是还是有很多问题，所以写下本文，总结下我遇到的问题以及解决办法。 ","date":"2016-05-31","objectID":"/posts/2016-webpack1/:0:0","series":null,"tags":["Webpack"],"title":"Webpack初探","uri":"/posts/2016-webpack1/"},{"categories":["Webpack"],"content":"包管理工具—webpack Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 官网：http://webpack.github.io/ 对应各种不同文件类型的资源, Webpack 有对应的模块 loader比如 CoffeeScript 用的是coffee-loader, 其他还有很多:http://webpack.github.io/docs/list-of-loaders.html ","date":"2016-05-31","objectID":"/posts/2016-webpack1/:0:1","series":null,"tags":["Webpack"],"title":"Webpack初探","uri":"/posts/2016-webpack1/"},{"categories":["Webpack"],"content":"安装 webpack的安装其实其实Google一搜一大把，但是为了完整性，还是写写吧。 webpack同样基于nodejs，所以我们需要先安装nodejs，然后再利用npm安装，webpack需要nodejs v0.6以上支持，建议使用最新的nodejs。 首先全局安装webpack： $ npm install webpack -g 或者将webpack安装到项目依赖中: # 进入项目目录 # 确定已有package.json，没有就通过npm init创建 # 安装webpack依赖 $ npm install webpack --save-dev ","date":"2016-05-31","objectID":"/posts/2016-webpack1/:1:0","series":null,"tags":["Webpack"],"title":"Webpack初探","uri":"/posts/2016-webpack1/"},{"categories":["Webpack"],"content":"使用 首先创建一个静态页面index.html和一个JS入口文件entry.js： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\" src=\"bundle.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e //entry.js document.write('It works.'); 然后编译entry.js并打包到bundle.js： $ webpack entry.js bundle.js 然后用浏览器打开index.html就可以看到It works. 接下来添加一个模块module.js并修改入口entry.js： //module.js module.exports='It work from module.js.'; //entry.js document.write('It works.'); document.write(require('./module.js'));//添加模块 重新运行打包命令后就可以看到It work from module.js. 这里我们用到了commonjs的模块写法：exports，require；前面已经说过，webpack作为打包工具，可以为commonjs，AMD，ES6模块打包。 Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到bundle.js 。Webpack会给每个模块分配一个唯一的id并通过这个id索引和访问模块。在页面启动时，会先执行entry.js中的代码，其它模块会在运行require的时候再执行。 这就是最基本的webpack的用法，当我第一次看到这个功能的时候，终于解决了曾经我对在页面中引用JS的一个困惑，即js文件a如何引用js文件b中的东西，webpack非常方便让我们做到了这一点。下一节，会结合Vuejs进行模块化开发，那时会用到更多的webpack的东西，并且会讲到关于ES6模块儿化的一些东西，加油！ ","date":"2016-05-31","objectID":"/posts/2016-webpack1/:2:0","series":null,"tags":["Webpack"],"title":"Webpack初探","uri":"/posts/2016-webpack1/"},{"categories":["CSS"],"content":"看了张鑫旭在慕课网关于vertical-align的讲解，感觉讲的挺深，所以总结了一下 vertical-align的百分比值相对于line-height计算 IE6/7下line-height不支持小数 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:0:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"vertical-align起作用的前提 该属性应用于inline水平或者table-cell元素 inline水平 inline:img,span,strong,em等 inline-block:input,button（ie8+，ie6/7会把inline-block当作inline） table-cell元素 td 所以默认情况下支持vertical-align的有：图片，按钮，文字，单元格 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:1:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"抛出一个问题 想实现图片的垂直居中 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e \u003cimg src=\"http://www.insgeek.com/public/insgeek2.0/img/indexpec/enleft.jpg\" width='100' alt=\"\"\u003e \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e p{ width:100%; height:200px; background-color: #ccc; } img{ vertical-align:middle; } 利用vertical-align：middle实现垂直居中，但是这里并没有按照我们想要的去做，解决办法： 1.给父元素添加line-height的值为的高度（ie7+都可以实现） p{ line-height:200px; } 2.给父元素添加display:table-cell table-cell元素的vertical-align只会作用于自身，里面的子元素设置不起作用 p{ display:table-cell; /*把img的去掉*/ vertical-align:middle; } ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:1:1","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"vertical-align与line-height 利用text-align:justify任意数目列表两端对齐效果 .justify-fix{display:inline-block;width:250px} p{ background:#666; } \u003cp style=\"text-align: justify\"\u003e \u003cimg src=\"img/mm1.jpg\" width=\"250\" alt=\"\"\u003e \u003cimg src=\"img/mm1.jpg\" width=\"250\" alt=\"\"\u003e \u003cimg src=\"img/mm1.jpg\" width=\"250\" alt=\"\"\u003e \u003cimg src=\"img/mm1.jpg\" width=\"250\" alt=\"\"\u003e \u003ci class=\"justify-fix\"\u003e\u003c/i\u003e \u003ci class=\"justify-fix\"\u003e\u003c/i\u003e \u003ci class=\"justify-fix\"\u003e\u003c/i\u003e \u003c/p\u003e 运行后红色虚线表示i标签的位置 设置容器，p的行高为0 p{ line-height:0; } 则出现如下情况： 为什么会出现这样的现象？ 首先看一个东西 从CSS2的可视化格式模型文档中看到： ‘inline-block’的基线是正常流中最后一个line box的基线，除非，这个line box里面既没有line boxes或者本身‘overflow’属性的计算值而不是‘visible’，这种情况下基线是margin第边缘 举例说明： \u003cstyle\u003e .dib-baseline{ display: inline-block; width: 150px; height: 150px; border: 1px solid #cad5eb; background-color: #f0f3f9; margin-top: 20px; } \u003c/style\u003e \u003cspan class=\"dib-baseline\"\u003e\u003c/span\u003e \u003cspan class=\"dib-baseline\"\u003edib-baseline\u003c/span\u003e 文档解释了该现象，因为前面的盒子没有任何字符，此时它的基线就是它的底边缘，后面的盒子有文字，所以该盒子的基线就是文字的基线，二者基线对齐，现成如此效果。 如果把第二个盒子line-height:0，此时文字基线的位置，就是文字的垂直中心，所以： 所以，以上情况下面那些空白，是由于本身后面两个图片是没有的，所以可以当作是空白字符（空格），即后面两个\u003ci\u003e是有字符的，而第一个\u003ci\u003e是没有字符的，所以和上面的那个例子一样，默认基线对齐，所以，会导致出现小的空隙（其本质和图2一样），要消除这个空隙，需要给i都添加空白字符（ 或者直接改变对齐方式，vertical-align：top / bottom）即可，而这个line-height：0可以不添加。 要消除需要给p标签（容器）设置： p{ line-height:0; } .justify-fix{ vertical-align: bottom / top; } 之后运行结果： ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:2:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"vertical-align线性属性值 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:3:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"1.vertical-align:bottom（top与之差不多） 定义 inline / inline-block元素：元素底部和整行底部对齐。 table-cell元素：单元格底padding边缘和表格行的底部对齐 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:3:1","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"2.vertical-align:middle 定义 inline / inline-block元素：元素的垂直中心点和父元素基线上1/2 x-height处对齐 table - cell元素：单元格填充盒子相对于外卖的表格行居中对齐 利用vertical-align：middle所实现的是近似垂直居中 为什么是近似呢？答案就在于： inline / inline-block元素：元素的垂直中心点和父元素基线上1/2 x-height处对齐 父元素基线上1/2 x-height处其实就是用line-height撑开后字符水平中心 字符所在的水平中心线和经过line-height撑开后的水平中心线（vertical-algin：middle的水平中心线）不是一个中心线（具体演示看[4-1 vertical-align线性属性值]http://www.imooc.com/video/10403）因为字符，本身有个下沉的特性 那么如何实现完全垂直居中？ 给父元素设置 p{font-size:0} 这样元素的垂直中心点和父元素基线上1/2 x-height处就完全重合了 但是这样会出现问题，如果我们在父级元素中有文字，那么设置font-size：0会导致文字无法显示，实现完全垂直居中的另一种方法是给图片（img）后面添加一个span,span设置为vertical-align：middle p { line-height:250px; } img { veritcal-align:middle; } img+span { veritcal-align:middle; } ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:3:2","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"vertical-align文本类属性值 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:4:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"定义： vertical-align :text-top 盒子的顶部和父级content area的顶部对齐 vertical-align：text-bottom 盒子的底部和父级content area的底部对齐 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:4:1","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"解释： content area就是只与父级font-size的大小有关，与行高，以及后面是否有inline-block元素的没有任何关系，但是vertical-align：middle / top / bottom都会被后面的inline-block水平元素影响。 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:4:2","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"用处： 一般用于表情图片（或原始尺寸背景图标）与文字的对齐效果 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:4:3","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"输入理解vertical-align上标下标类—sub / super HTML中有原生的上下标标签，分别为：\u003csup\u003e ,\u003csub\u003e。利用原生的HTML获得的上下标文字大小是父元素75%左右。 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:5:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"定义： 1.vertical-align：super 提高盒子的基线到父级合适的上标基线位置。 2.vertical-align：sub 降低盒子的基线到父级合适的下标基线位置。 这里的‘合适的上（下）标基线位置’，哪里合适，说不清 ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:5:1","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["CSS"],"content":"vertical-align前后不一的作用机制与示例 vertical-align所有的表现只当前元素和父级有关，前后并没有直接影响 1.实现小图标和文字的对齐 使用vertical-align负值，虽然图片文字对齐可以使用浮动实现的，但是尽量少用浮动，因为会破坏布局，使用vertical-align负值可以实现居中 2.不定尺寸图片或多行文字的垂直居中,具体实现步骤如下： a.大小不固定的图片垂直居中 主体元素inline-block化； 0宽度100%高度辅助元素； vertical-align:middle； \u003cp\u003e\u003cimg width=\"30%\" src=\"./111.jpg\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/p\u003e p{ width: 500px; height: 200px; background-color: yellowgreen; } /*主体元素inline-block化img本身是inline， 但是里面的content为inline-block*/ img{ width: 40%; vertical-align:middle; } /*宽度为0，高度100%的辅助元素*/ i { display: inline-block; height: 100%; vertical-align:middle; } /*给以上 img 和 i 元素添加 vertical-align:middle; */ 实现垂直居中，效果如下： b.大小不固定的文字垂直居中： \u003cp\u003e \u003cspan\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003cbr/\u003e测试文字垂直居中\u003c/span\u003e \u003ci\u003e\u003c/i\u003e \u003c/p\u003e p{ width: 500px; height: 200px; background-color: yellowgreen; } span{ display: inline-block; vertical-align:middle; } i{ display: inline-block; height: 100%; vertical-align:middle; } ","date":"2016-05-23","objectID":"/posts/2016-verticalalign-1/:6:0","series":null,"tags":["CSS"],"title":"慕课网---深入理解vertical-align总结","uri":"/posts/2016-verticalalign-1/"},{"categories":["前端工具"],"content":"在写前端代码的时候，我们为了看效果，需要一直按F5进行刷新，这样做很繁琐而且非常浪费时间，在网上搜过后发现很多关于自动刷新的办法，这里我介绍的是基于gulp和broserSync实现浏览器的自动刷新，即只要编辑器保存，浏览器就会自动刷新。 那么gulp，broserSync是什么呢？ ","date":"2016-05-16","objectID":"/posts/2016-gulpbrosersync/:0:0","series":null,"tags":["gulp"],"title":"Gulp+BroserSync实现浏览器自动刷新","uri":"/posts/2016-gulpbrosersync/"},{"categories":["前端工具"],"content":"Gulp Gulp是一个前端自动化工具，基于nodejs，和grunt差不多，但是比grunt语法更加简单，语法更加自然。在gulp的插件中，我们可以找到自动刷新，压缩图片/代码/等等各类工具，方便我们的使用，并且gulp的任务是流（pipe），即一个任务完成后，紧接的另一个任务开始进行。gulp的使用如下： 1.安装gulp 全局安装gulp： $ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： $ npm install --save-dev gulp 生成package.json $ npm init 注意： 这里官网只是写让这么安装，但是需要注意，两个安装不是第一步第二步，而是第一种方式或者第二种方式，两种方式任选其一。第一种安装方式是全局安装，即安装后，整个电脑无论哪个项目都可以使用。对应的，第二个表示安装到对应项目中，即如果在window的cmd命令行进入对应项目A的目录，则运行npm install –save-dev gulp后，安装的gulp只能在该文件夹下使用，其他文件夹下的其他文件都无法使用。 其实不只是gulp，gulp的插件也是这样，要么全局安装，要么安装在项目中。一般情况下，gulp会全局安装，但是由于每个项目用到的gulp插件不同，所以可能需要局部安装gulp插件。 安装完成gulp之后，会在安装gulp的文件夹下生成node_modules文件夹。此时，在与该文件夹同层创建gulpfile.js这就是用于配置gulp插件的文件。 2.恢复gulp 随着我们gulp插件的改变，package.json会自动变化，同时我们的配置文件gulpfile.js也会对应变化（自己手动配置）。他们可以把我们安装的gulp给备份，如果我们在电脑A中安装完我们的工具，然后换了一台电脑B，我们只需要把电脑A中package.json与gulpfile.js复制到B电脑，然后在安装完gulp后，运行 $ npm install gulp就会自动把我们在package.json中的所有gulp插件全部安装回来，非常方便。 ","date":"2016-05-16","objectID":"/posts/2016-gulpbrosersync/:0:1","series":null,"tags":["gulp"],"title":"Gulp+BroserSync实现浏览器自动刷新","uri":"/posts/2016-gulpbrosersync/"},{"categories":["前端工具"],"content":"broserSync broserSync（以下简称bs）是一款非常优秀的自动刷新工具，本身可以独立使用，也可以配合gulp或者grunt一起使用，非常不错的一款插件。 当你改变代码的时候，BrowserSync会重新加载页面，或者如果是css文件，会直接添加进css中，页面并不需要再次刷新。这项功能在网站是禁止刷新的时候是很有用的。假设你正在开发单页应用的第4页，刷新页面就会导致你回到开始页。BrowserSync会直接将需要修改的地方添加进CSS，就不用再点击回退。同时，BrowserSync也可以在不同浏览器之间同步点击翻页、表单操作、滚动位置。你可以在电脑和iPhone上打开不同的浏览器然后进行操作。所有设备上的链接将会随之变化，当你向下滚动页面时，所有设备上页面都会向下滚动（通常还很流畅！）。当你在表单中输入文本时，每个窗口都会有输入。当你不想要这种行为时，也可以把这个功能关闭。 实际上bs对于gulp并不算是一种插件，因为bs并不像一个插件一样操作文件。然而，npm上的bs模块能在gulp上被直接调用。 1.安装broserSync 进入需要使用bs的目录，运行： $ npm install --save-dev broser-sync 2.配置broserSync bs本身可以打开本地静态服务器，也可以代理像wamp这样的服务器。 2.1 代理其他服务器 打开我们新建的gulpfile.js，配置如下： /*browserSync*/ const gulp = require('gulp'); const browserSync = require('browser-sync').create(); gulp.task(\"watch\",function(){ browserSync.init({ /*这里的files写的是需要监控的文件的位置*/ files:[ \"./Home/View/PC/**/*.html\", \"./public/group/css/*.css\", \"./public/group/js/*.js\" ], logLevel: \"debug\", logPrefix:\"insgeek\", /*这里的proxy写的是需要代理的服务器，我自己的wamp启动的是localhost:80*/ proxy:\"localhost:80\", ghostMode: { clicks: true, forms: true, scroll: true }, /*这里写的是代理后，bs在哪个端口打开*/ port: 81, /*这里设置的是bs运行时打开的浏览器名称*/ browser: \"chrome\" }); }); 2.2 启动静态服务器 const gulp = require('gulp'); const browserSync = require('browser-sync').create(); const reload = browserSync.reload; /*实时监控*/ gulp.task(\"watch\", function() { browserSync.init({ files: [ \"./work/*/*.html\", \"./work/*/*.css\", \"./work/*/*.js\" ], logLevel: \"debug\", logPrefix: \"insgeek\", server: { /*这里写的是html文件相对于根目录所在的文件夹*/ baseDir: \"./work/statement\" /*这里如果不写，默认启动的是index.html，如果是其他名字，需要这里写*/ // index: \"insurance_template_statement.html\" }, ghostMode: { clicks: true, forms: true, scroll: true }, browser: \"chrome\" }); }); 完成上述配置后，可以在cmd命令行切换到工作目录，运行gulp watch启动broserSync。 ","date":"2016-05-16","objectID":"/posts/2016-gulpbrosersync/:0:2","series":null,"tags":["gulp"],"title":"Gulp+BroserSync实现浏览器自动刷新","uri":"/posts/2016-gulpbrosersync/"},{"categories":["CSS"],"content":"最近在写页面的时候遇到了一个问题—当行文本双端对齐，大家都知道CSS属性中有一个“text-align:justify”，但是这个属性使用的时候，要求还是挺多的，尤其是要实现单行文本双端对齐。关于两端对齐，大漠和张鑫旭的博客中都有文章讲，非常不错，推荐给大家： display:inline-block/text-align:justify下列表的两端对齐布局 Text-align:Justify和RWD ","date":"2016-05-11","objectID":"/posts/2016-textalgin/:0:0","series":null,"tags":["CSS"],"title":"text-algin:justify实现文本两端对齐","uri":"/posts/2016-textalgin/"},{"categories":["CSS"],"content":"text-align:justify与text-align-last:justify ","date":"2016-05-11","objectID":"/posts/2016-textalgin/:1:0","series":null,"tags":["CSS"],"title":"text-algin:justify实现文本两端对齐","uri":"/posts/2016-textalgin/"},{"categories":["CSS"],"content":"1.text-align MDN中这样介绍到：“text-align CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align并不控制块元素自己的对齐，只控制它的行内内容的对齐。”从这里可以看出，控制文本居中对齐直接写text-align:justify就可以。但是这对于多行文本（即有文本换行）除了最后一行都可以实现两端对齐，最后一行依旧左对齐。所以就需要控制最后一行文本对齐方式的CSS属性：text-align-last。 ","date":"2016-05-11","objectID":"/posts/2016-textalgin/:1:1","series":null,"tags":["CSS"],"title":"text-algin:justify实现文本两端对齐","uri":"/posts/2016-textalgin/"},{"categories":["CSS"],"content":"2.text-align-last text-align-last 属性规定如何对齐文本的最后一行。但是这里注意一点text-align-last 属性只有在 text-align 属性设置为 “justify” 时才起作用。所以，利用这个属性就可以控制最后一行文本的对齐方式。我们可以想象，如果是单行文本，就可以当作最后一行文本处理，直接设置text-align-last:justify来实现当行文本两端对齐，可惜的是，这样的方法兼容性并不好。 ","date":"2016-05-11","objectID":"/posts/2016-textalgin/:1:2","series":null,"tags":["CSS"],"title":"text-algin:justify实现文本两端对齐","uri":"/posts/2016-textalgin/"},{"categories":["CSS"],"content":"利用CSS实现兼容性较好的两端对齐 从上面的分析可以知道，如果文本出现换行，则除最后一行的所有文本都会实现两端对齐。这时我们想到利用::after伪类，给元素最后设置一个看不见的内联元素，并设置宽度为100%，就可以让我们可以看到的单行文本让浏览器认为是多行文本，从而实现单行文本的两端对齐。具体实现代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"line\"\u003e \u003cdiv class=\"public\"\u003e啊啊\u003c/div\u003e \u003cb\u003e:\u003c/b\u003e \u003cb\u003eaaaaaa\u003c/b\u003e \u003c/div\u003e \u003cdiv class=\"line\"\u003e \u003cdiv class=\"public\"\u003e啊啊啊啊啊\u003c/div\u003e \u003cb\u003e:\u003c/b\u003e \u003cb\u003eaaaaaa\u003c/b\u003e \u003c/div\u003e \u003cdiv class=\"line\"\u003e \u003cdiv class=\"public\"\u003e啊啊啊啊\u003c/div\u003e \u003cb\u003e:\u003c/b\u003e \u003cb\u003eaaaaaa\u003c/b\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e .line{ width:100%; height:15px; margin:5px; background-color: #ccc; } .public{ width:80px; height:100%; display:inline-block; text-align: justify; vertical-align:top; background-color: #aaa; } .public::after{ content:\"\"; display: inline-block; width:100%; overflow:hidden; height:0; } 运行结果： 2018/5/11更新 这里需要注意一个问题⚠️ 如果将html进行压缩（例如使用webpack把html进行压缩），将元素之间的空白节点去掉（这行），则以上两端对齐效果会消失，因为**inline-block本身的外在表现是行框，如果没有空白节点，多个inline-block紧紧挨在一起，表现可以理解为一个letter，letter是不受text-align影响的，text-align针对的是 word!** ","date":"2016-05-11","objectID":"/posts/2016-textalgin/:2:0","series":null,"tags":["CSS"],"title":"text-algin:justify实现文本两端对齐","uri":"/posts/2016-textalgin/"},{"categories":["CSS"],"content":"做移动端的响应方法有很多，但是我喜欢用 CSS3 的新单位 rem，这个单位非常好用（有个比它还好用的单位 vh，不过兼容性太差，不考虑了），根据不同屏幕，设置不同的基准值，从而实现适配各个屏幕尺寸的移动设备。慕课网有一套非常不错的讲关于 rem 的视频，这里推荐给大家http://www.imooc.com/learn/494。 rem—-CSS3 中新增的单位，兼容性还不错，常用于移动端实现字体的响应，与 em 不同，rem 根据根元素的 font-size 计算，所以要利用 rem 实现适配各个屏幕的大小，就需要根据不同的屏幕设置根元素不同的 font-size 的值。所以我们需要做下面的一些工作。 ","date":"2016-04-26","objectID":"/posts/2016-filerem/:0:0","series":null,"tags":["CSS"],"title":"利用CSS3新单位rem实现响应","uri":"/posts/2016-filerem/"},{"categories":["CSS"],"content":"1.获取浏览器的宽高（对于移动设备就是设备的宽度） 代码如下： var pageWidth = window.innerWidth var pageHeight = window.innerHeight if (typeof pageWidth !== 'number') { if (document.compatMode === 'CSS1Compat') { pageWidt = document.documentElement.clientWidth pageHeight = document.documentElement.clientHeight } else { pageWidt = document.body.clientWidth pageHeight = document.body.clientHeight } } 1.1 window.innerWidth 与 document.documentElement.clientWidth 通过测试发现，在 IE9+，chrome，firefox 下利用 window.innerWidth 与 document.documentElement.clientWidth 都可以获取到浏览器的宽高，但是他们有区别： window.innerWidth 获取到的宽度是把右侧滚动条算在内的宽度 document.documentElement.clientWidth 获取到的宽度是把右侧滚动条的宽度不算在内的宽度 但是，window.innerWidth 支持的是 IE9+，到 IE8 以前就会输出 undefined，而 document.documentElement.clientWidth 可以支持 IE7（在 IE 模拟器中，没有 IE6，到 IE5 就只能输出 0 了），在《javascript 高级程序设计》（第三版）中这样写道：“在 IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 document.body.clientWidth 和 document.body. clientHeight 取得相同信息。”所以 document.body.clientWidth;用于混杂模式，在标准模式下只需要 document.documentElement.clientWidth 即可。 1.2 如何判断浏览器处于什么模式？ Javascript 提供了方法 if (document.compatMode === 'CSS1Compat') { alert('标准模式') } else if (document.compatMode === 'BackCompat') { alert('混杂模式') } ","date":"2016-04-26","objectID":"/posts/2016-filerem/:0:1","series":null,"tags":["CSS"],"title":"利用CSS3新单位rem实现响应","uri":"/posts/2016-filerem/"},{"categories":["CSS"],"content":"2.计算根元素字体大小 通过上面代码可以拿到浏览器窗口（也就是 document）的宽度，这样就可以计算根元素的基准值了。 假设1rem = xpx，这里的x是计算得出的，这里的1rem代表根元素字体大小。 计算rem的公式如下(rem表示基准值) rem = document.documentElement.clientWidth * dpr / 10 `` 假设在宽度为720px的屏幕上，`1rem = 36px`，即720px的屏幕上根元素字体大小为`36px`，则在360px的屏幕上字体大小为`18px`，因为屏幕宽度和根元素字体大小的比值不变，是20，所以计算公式如下： ```javascript var fontSize = pageWidth / 20 var html = document.querySelectorAll('html')[0] html.style.fontSize = fontSize 通过以上代码就实现了给根元素设置基准 fontSize。 ","date":"2016-04-26","objectID":"/posts/2016-filerem/:0:2","series":null,"tags":["CSS"],"title":"利用CSS3新单位rem实现响应","uri":"/posts/2016-filerem/"},{"categories":["CSS"],"content":"3.将 PSD 中测量出的值换算成 rem 公司设计师给的 PSD 的基准宽度为 720px,所以我在布局的时候常常使用 nexus 5 作为移动端设备去测试，因为它的宽度是 360px，与 720px 刚好是 2 倍的关系，根据这个 2 倍的关系，所以换算步骤如下： PSD 设计图中测量出来的尺寸为 m px，则放在我移动设备中需要写的尺寸为 m/2 px 将 px 换算为 rem，由于在 360px 的移动设备下，font-size 基准值为 360 / 20 = 18px，所以 px=\u003erem 过程为：rem = m / 2 / 18 = m / 36; 通过以上计算就将 PSD 中的 px 转换为移动设备中的 rem，这样就可以实现对各个移动设备的适配。 ","date":"2016-04-26","objectID":"/posts/2016-filerem/:0:3","series":null,"tags":["CSS"],"title":"利用CSS3新单位rem实现响应","uri":"/posts/2016-filerem/"},{"categories":["Javascript"],"content":"前几天搞得那个文件上传，最近工作不太忙，又开始完善。这次主要添加了文件上传的进度部分，主要用到的则是XMLHttpRequest2的progress，由于我读的是《javascript高级程序设计》（第三版），这里我遇到一个关于progeress事件的坑，后面详细解答。 ","date":"2016-04-14","objectID":"/posts/2016-fileupload2/:0:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","uri":"/posts/2016-fileupload2/"},{"categories":["Javascript"],"content":"创建XMLHttpRequest对象 首先说说XMLHttpRequest，在IE7+浏览器中，只需要new一个XMLHttpRequest对象即可： let xhr=new XMLHttpRequest(); 由于现在淘宝都不再支持IE6以及7，所以这里不考虑IE7及以下浏览器关于xhr的创建方法。 ","date":"2016-04-14","objectID":"/posts/2016-fileupload2/:1:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","uri":"/posts/2016-fileupload2/"},{"categories":["Javascript"],"content":"open()方法 在使用XHR对象时候，第一个方法是open()方法，它接受3个参数： 要发送的请求的类型（“get”、“post\"等）； 请求的URL； 是否异步发送请求的布尔值。 例如： let xhr=new XMLHttpRequest(); xhr.open('get','example.php',false); 以上代码会启动一个针对example.php的GET请求。这里需要注意两点： URL相对于执行代码的当前页面； 调用open()方法并不会真正发送请求，只是启动一个请求以备发送 ","date":"2016-04-14","objectID":"/posts/2016-fileupload2/:1:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","uri":"/posts/2016-fileupload2/"},{"categories":["Javascript"],"content":"sned()方法 send()方法接收一个参数，即要作为请求主题发送的数据。如果不需要通过请求主题发送数据，则传入null。在发送数据收到响应后，响应的数据会自动填充XHR对象的属性，相关属性如下： responseText：作为响应主题被返回的文本； responseXML：如果响应的内容类型是\"text/xml\"或者\"application/xml”，则这个属性中将保存包含着响应数据的XML DOM文档； status：响应HTTP状态； statusText：响应HTTP状态的说明。 在接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。一般来说，可以将 HTTP状态代码为 200作为成功的标志。此时，responseText 属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也应该能够访问了。此外，状态代码为304 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。由于我们用XHR对象常常是为了异步传输，所以—可以检测 XHR 对象的readyState 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下： 0：未初始化。尚未调用 open()方法。 1：启动。已经调用 open()方法，但尚未调用 send()方法。 2：发送。已经调用 send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 必须在调用 open()之前指定 onreadystatechange事件处理程序才能确保跨浏览器兼容性。所以，实现代码如下： var xhr = new XMLHttpRequest(); //必须在open之前指定onreadystatechange才能保证跨浏览器兼容性！！！！ xhr.onreadystatechange=function () { if(xhr.readyState==4){ if((xhr.status\u003e=200\u0026\u0026xhr.status\u003c300)||xhr.status==304){ alert(xhr.responseText); }else{ alert('请求失败'+xhr.status); } } }; 所以利用以上代码就可以实现文件是上传成功还是失败。 ","date":"2016-04-14","objectID":"/posts/2016-fileupload2/:1:2","series":null,"tags":["H5","file","canvas"],"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","uri":"/posts/2016-fileupload2/"},{"categories":["Javascript"],"content":"XMLHttpRequest2级的进度事件 XHR2有如下6个进度事件： loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断地触发。 error：在请求发生错误时触发。 abort：在因为调用 abort()方法而终止连接时触发。 load：在接收到完整的响应数据时触发。 loadend：在通信完成或者触发 error、abort 或 load 事件后触发。 以上事件触发顺序如下： laodstart =\u003e progress =\u003e error =\u003e abort/load =\u003e loadend ","date":"2016-04-14","objectID":"/posts/2016-fileupload2/:2:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","uri":"/posts/2016-fileupload2/"},{"categories":["Javascript"],"content":"关于progress事件中上传与下载的事件 这里就是我遇到的坑，在《javascript高级程序设计》中并没有说清楚，让我感到困惑，在原书中581页这么描写：“onprogress事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。”而实际上表示总字节数的属性是total，表示已经传输的字节数是load属性。 XHR2传输数据有一个progress事件，用来返回进度信息，它分成上传和下载两种情况，下载的progress事件属于XMLHttpRequest对象，而上传的progress事件属于XMLHttpRequest.upload对象。 首先定义传输文件的函数： function percentFun(event){ if (event.lengthComputable) { /*event.total是需要传输的总字节数，event.load是已经传输的字节数，如果event.lengthComputable!=true,则event.total=0*/ var percent = event.loaded / event.total; } } 如果需要显示进度，则分别如下： /*下载的进度*/ xhr.onprogress = percentFun; /*上传的进度*/ xhr.upload.onprogress = percentFun; 基于以上几点，实现了上传进度显示，具体代码如下： addEvent(button,'click',function () { if(filesArray.length!=0){ var data=new FormData(); var i=0; while(i\u003cfilesLen){ data.append('file'+i,filesArray[i]); i++; } var xhr = new XMLHttpRequest(); //必须在open之前指定onreadystatechange才能保证跨浏览器兼容性！！！！ xhr.onreadystatechange=function () { if(xhr.readyState==4){ if((xhr.status\u003e=200\u0026\u0026xhr.status\u003c300)||xhr.status==304){ //console.log(xhr.responseText); }else{ alert('请求失败'+xhr.status); } } }; xhr.upload.onprogress=function (event) { var e=event||window.event; var percentComplete = Math.ceil((e.loaded / e.total)*100); var progressFont=document.querySelectorAll('.progress-font'); for(let i=0;i\u003cfilesArray.length;i++){ ThumbnailArray[i].innerHTML=percentComplete +'%'; } } /*上传完成后滞空数组，保证下次上传不会重复上传*/ xhr.upload.onload=function () { filesArray=[]; ThumbnailArray=[]; alert('上传完成，数组置空'); } xhr.open('post','uploader.php',true); xhr.send(data); } }); ","date":"2016-04-14","objectID":"/posts/2016-fileupload2/:2:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","uri":"/posts/2016-fileupload2/"},{"categories":["Javascript"],"content":"最近因为同学的一个轮播图不会写，让我萌生了用ES6写一个轮播图的想法（本人喜欢这些玩儿一些新的东西），以前就知道ES6，但是一直没有学，现在终于下决心学了，借助阮一峰老师的书ECMAScript 6 入门 和Youtube上面老外的视频学习ES6非常不错。阮一峰老师的书写的非常详细，推荐想学习的ES6的同学仔细看看。本篇文章会总结在实践中用到的ES6的知识。 ","date":"2016-04-11","objectID":"/posts/2016-es6practice/:0:0","series":null,"tags":["Javascript"],"title":"初探ES6——轮播图实践总结","uri":"/posts/2016-es6practice/"},{"categories":["Javascript"],"content":"模板字符串 这是我非常喜欢的ES6的特点之一，非常直观的反应出变量和字符串之间的关系，在ES5中，如果我们想在字符串中添加变量，需要用如下写法： animate(box, 'translate(-' + itemWidth * num + 'px,0)', 1000, function () { box.style.transitionDuration = ''; box.style.transform = 'translate(-800px,0)'; flag = true; }); 现在用ES6的模板字符串，可以直接把字符串和变量相结合，更加易懂。 animate(box, `translate(-${itemWidth*num}px,0)`, 1000, function() { box.style.transitionDuration = ''; box.style.transform = `translate(-${itemWidth*(item.length-2)}px,0)`; flag = true; }); 是不是非常直观方便，从上面的两个简单示例中可以看出，在ES6中，字符串用反引号（``）标识，这一点需要知道。 还有一个特点，模板字符串可以输出折行的字符串，这在ES5传统字符串中是无法做到的，必须借助（\\n），且不能在书写时候写入回车，但是在ES6的字符串模板中，可以直接写入回车，空格，然后在字符串输出时候直接输出，非常方便。 let myString=`abc de ffff fas`; console.log(myString); /*输出abc de ffff fas*/ ","date":"2016-04-11","objectID":"/posts/2016-es6practice/:1:0","series":null,"tags":["Javascript"],"title":"初探ES6——轮播图实践总结","uri":"/posts/2016-es6practice/"},{"categories":["Javascript"],"content":"对函数的扩展 ","date":"2016-04-11","objectID":"/posts/2016-es6practice/:2:0","series":null,"tags":["Javascript"],"title":"初探ES6——轮播图实践总结","uri":"/posts/2016-es6practice/"},{"categories":["Javascript"],"content":"1.给函数设置默认值 在对函数的扩展中，添加了一项给函数设置默认值的功能，这个功能可以说是非常赞的。是否记得我们在ES5中是怎么给函数设置默认值？ function test(a,b,c){ var a=a||10; var a=b||15; var c=c||20; console.log(a+b+c); } 这里我们设置默认值，可以达到自己的预期效果，直到有一天，我们把a=0传入，这时候，我们这么写就不对了，对于程序来说，0就是false，所以a会取默认值10，从而达不到我们预期的效果。但是ES6为我们提供非常好的设置默认值的方式。上面的代码可以改写成下面的这样： function test(a=10,b=15,c=20){ console.log(a+b+c); } ","date":"2016-04-11","objectID":"/posts/2016-es6practice/:2:1","series":null,"tags":["Javascript"],"title":"初探ES6——轮播图实践总结","uri":"/posts/2016-es6practice/"},{"categories":["Javascript"],"content":"2.箭头函数 了解Coffescript的同学应该清楚，Cofficescript的强大之处在于它的无处不在的箭头函数，写起来非常爽，现在，ES6正式引入箭头函数，让我们的程序可以得到简化，例如： //ES5的写法 var test = function (a,b){ return a+b; } //ES6的箭头函数 var test2 = test(a,b)=\u003ea+b; 在写轮播时候，需要鼠标移动到下面的这个小圆点在小圆点类数组对象中是第几个，从而才能让图运动到正确位置，在ES5的时候，我们需要给当前这个对象添加属性，写起来比较繁琐，写法如下： var liList = document.querySelectorAll('li'); for(var i=0;i\u003cliList.length;i++){ liList[i].index=i; liList[i].addEventListener('mouseenter',function(){ console.log(this.index); },false); } 这个this.index属性就是当前的鼠标放上去的元素的索引，然后根据这个索引去得到当前的元素。但是在ES6中，我们可以直接使用箭头函数以及在数组中新引入的findIndex来找到当前的活动元素的索引，代码如下： let liList = document.querySelectorAll('li'); let ArrayliList=Array.form(liList); for(var i=0;i\u003cliList.length;i++){ liList[i].index=i; liList[i].addEventListener('mouseenter',function(){ let thisIndex = ArrayliList.findIndex((n) =\u003e n == this); },false); } 以上代码得到的thisIndex就是当前鼠标放上去的索引，这里我对箭头函数中n这个参数的理解是，传入参数n后会遍历数组中的对象，从而找到与this相等的那个对象，然后返回它的索引，这里用到Array.from()，这是一个ES6中数组中新增的方法，可以将类数组转换成数组。 ","date":"2016-04-11","objectID":"/posts/2016-es6practice/:2:2","series":null,"tags":["Javascript"],"title":"初探ES6——轮播图实践总结","uri":"/posts/2016-es6practice/"},{"categories":["Javascript"],"content":"ES6的for…of循环 上面的JS代码循环用了for，其实可以用ES6中的for…of循环去代替，这样写法更加简洁。是否记得JS中的for…in循环，这个循环可以循环键值对中的键，但是无法循环值，而for…of的出现正是为了弥补它的不足，for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator对象，以及字符串。所以我们可以利用该循环替代for循环，但是这里要注意一点如果直接用for…of循环，在chrome49下会报错，官方已证实这是chrome49的BUG，将会在chrome51中修复，所以我在写的时候，利用Array.from()将NodeList对象转换为数组，这样可以放心操作，代码如下： let liList = document.querySelectorAll('li'); let ArrayliList=Array.form(liList); for(let li of liList){ li.addEventListener('mouseenter',function(){ let thisIndex = ArrayliList.findIndex((n) =\u003e n == this); },false); } 是不是非常简洁:) 以上就是最近几天对ES6的初探的总结，感觉仅仅只是这些就已经让我感受到ES6的魅力了，接下来，我会再做几个demo，慢慢去熟悉这个新的但是非常好玩儿的ES6。 ","date":"2016-04-11","objectID":"/posts/2016-es6practice/:3:0","series":null,"tags":["Javascript"],"title":"初探ES6——轮播图实践总结","uri":"/posts/2016-es6practice/"},{"categories":["Javascript"],"content":"最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:0:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"一.做好HTML，CSS样式 这里很简单，就是写一个HTML+CSS的文件，让我们的上传看起来像那么回事儿，这里不细说，代码如下： ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:1:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003efileUploader\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./index.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"upbox\"\u003e \u003ch1\u003e测试\u003c/h1\u003e \u003cinput id=\"uploader\" type=\"file\" multiple=\"multiple\" name=\"file\" accept=\"image/*\"\u003e \u003c/div\u003e \u003ca id=\"test\" href=\"\"\u003e点击选择上传图片\u003c/a\u003e \u003cbutton type=\"button\" id=\"button\"\u003e上传\u003c/button\u003e \u003cscript src=\"./index.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:1:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"index.css .upbox{width: 100%;height: 500px;border: 3px dashed #000;position: relative;} #uploader{display: block;width: 100%;height: 100%;opacity: 0;position: absolute;left: 0;top: 0;cursor: pointer;} h1{position: absolute;left: 45%;top: 40%;} button{width: 100px;height: 50px;float: right;} .img-content{width: 120px;height: 120px;border: 1px solid #000;margin: 20px;float: left;position: relative; z-index: 5;} .img-box{width: 100%;height: 100%;} .img-box img{display: block; width: 100%;height: 100%;} ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:1:2","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"二.用户多选文件并读取用户选择的文件 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:2:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"1.让input实现多文件选择 用户在点击input区域后，可以选择文件，H5支持多文件选择，只需要像下面这样写就可以： \u003cinput id=\"uploader\" type=\"file\" multiple=\"multiple\" name=\"file\" accept=\"image/*\"\u003e 在上面代码中，设置multiple可以让input实现文件多选，accept则是允许用户选择什么文件，这里我们要写图片上传，所以接受所有的图片的类型，也为后文的转换上传图片的文件格式奠定基础。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:2:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"2.利用FileReader对象读取源文件 H5的File接口提供了文件的信息以及文件内容的存取的方法。File对象是用户在input元素上选择文件后返回的FileList对象，所以，通过File对象可以获得用户选择的文件。代码如下： var uploader=document.querySelectorAll('#uploader')[0]; uploader.addEventListener('change',function (event) { var e=event||window.event; var target=e.target; var files=target.files; }); 这里可以获得用户选择的文件，但是因为我们要利用用户选择的源文件生成缩略图，所以需要需要读取的是用户在计算机上存储的源文件，H5提供了FileReader对象，该对象允许web应用程序异步读取存储在用户计算机上的文件（或者元素数据缓冲）内容。 FileReader对象提供了readAsDataURL()方法： readAsDataURL() 开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.参数file为将要读取的Blob对象或者File对象. 所以拿到用户选择的源文件的代码如下： var filesLen; var uploader=document.querySelectorAll('#uploader')[0]; uploader.addEventListener('change',function (event) { var e=event||window.event; var target=e.target; var files=target.files; filesLen=files.length; for(let i=0;i\u003cfilesLen;i++){ var reader=new FileReader(); //文件读取结束后要做的事 reader.onload=function (event) { //读取用户选择的文件 var fileURL=event.target.result; } reader.readAsDataURL(files[i]); } }); 因为是读取多个文件，所以需要使用for循环去读取每一个文件（这意味着FileReader一次只读取一个文件，异步读取），这样就拿到了用户选择的图片的源文件，该源文件被读取为base64编码，这位下一步，生成缩略图做了基础。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:2:2","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"三.利用canvas生成缩略图 H5的canvas提供了drawImage和toDataURL两个方法 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:3:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"1.drawImage() drawImage()方法在画布上绘制图像，画布或视频，同时也能绘制图像的某个部分或者增加减少图像的尺寸。在javascript中有三种语法，分别如下： 在画布上定位图像 context.drawImage(img,x,y); 在画布上定位图像并规定图像的宽度和高度 context.drawImage(img,x,y,width,height); 正是这一点儿让利用canvas压缩图片成为可能（本身生成缩略图也是在更改图片大小） 剪切图像并在画布上定位被剪切部分 context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 以上参数值对应如下： ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:3:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"2.toDataURL() toDataURL()方法回传含有图像和参数设置特定格式的dataURLs，回传的图像解析度为96dpi。同样通过toDataURL()可以方便的将图片转换为base64编码，但是这里需要注意两点： 如果canvas的高度或者宽度为0，则回传的字符串为data:,。 如果要求图像类型并非image/png，但是回传的类型却是data:image/png，表示要求的图像类型并不支持。 表达式如下： canvas.toDataURL(type,encoderOptions); type：图片的格式，预设为image/png encoderOptions：生成的图片的品质，为0~1之间的数字，如果只不在该范围内，则使用默认值，其他会忽略 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:3:2","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"生成缩略图代码实现 基于以上两个canvas方法，可以写出生成缩略图的方法，代码如下： //创建缩略图样式 function createThumbnailFromUrl(context,fileURL) { //创建元素 var img=document.createElement('img'), imgBox=document.createElement('div'), imgContent=document.createElement('div'); //添加Class imgBox.classList.add('img-box'); imgContent.classList.add('img-content'); //动态插入创建的元素 context.appendChild(imgContent); imgContent.appendChild(imgBox); imgBox.appendChild(img); //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image图片对象 var image=new Image(); image.src=fileURL; image.onload=function () { canvas.width=120; canvas.height=120*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); img.src=canvas.toDataURL('image/png',0.5); } } 这里，为了拿到图片对象，也就是拿到要转换的图片，我们新建一个图片对象，然后将图片对象的src赋值为FileReader拿到的FileURL，这样就拿到了用户选择上传的图片，这就将用户选择的文件与canvas联系起来，接下来就进行处理，等图片读取完成后，进行cnavas操作，最后把生成的base64图片编码直接赋值给动态创建的缩略图img，这样就实现了用户在选择完要上传的图片后生成缩略图。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:3:3","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"四.将要上传的图片利用canvas进行压缩，改变格式—遇到js中的异步执行 canvas压缩，更改图片格式的实现就是上面生成缩略图的方法，但是我在写这里的时候遇到了一个问题，就是javascript中异步执行机制。 我在javascript中写了一个函数，代码如下： function changeImg(fileURL) { //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image(); //这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高 image.src=fileURL; image.onload=function () { canvas.width=image.width; canvas.height=image.height; context.drawImage(image,0,0,canvas.width,canvas.height); newFile=canvas.toDataURL('image/png',0.5); //这里的return就是问题的所在 return newFile } } 本来我的想法是通过写一个changeImg函数，在文件读取完成后，进行图片压缩，然后再将转换后的图片利用return返回回来，然后继续操作。但是在执行的时候，发现浏览器一直报错，var newFile=changeImg(newFile)返回的是undefined的。经过询问高手，得知这里遇到了js中异步执行索带来的结果。关于js异步执行机制，我会在接下来做细致研究，并记录，现在说一下通过这个问题知道的一些东西。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:4:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"什么时候就会出现异步执行机制 当在js中出现回调，ajax，FileReader(暂时知道这三个)的时候，就会出现异步执行机制，简单举例： var a; a=ajax();//这里代表经过ajax执行后返回的值给a console.log(a);//undefined 以上代码运行结果并不是ajax返回的值，而是undefined。ajax是 JavaScript和XML，这里我对异步的简单理解就是在代码执行的同时，ajax执行，可以想象，在浏览器中js代码执行的速度与通过ajax返回服务器回传的数据的速度，当ajax返回数据时，浏览器中代码早已执行完成console，所以输入的是undefined，同时这也解释了为什么ajax会存在当ajax调用成功后，再执行一个XXX。 所以在这里不能写return newFile，因为image.onload=function(){}也是异步的，我这里想到的办法就是在文件读取完成后，继续创建canvas，转换压缩图片（我感觉这个方法一点儿不好，暂时这么写）。 所以正确的代码如下： //input选框change事件，取得文件，创建缩略图 uploader.addEventListener('change',function (event) { var e=event||window.event; var target=e.target; files=target.files; filesLen=files.length; for(let i=0;i\u003cfilesLen;i++){ var reader=new FileReader(); //文件读取结束后要做的事 reader.onload=function (event) { //读取用户选择的文件 var fileURL=event.target.result; //根据读取的文件创建缩略图 createThumbnailFromUrl(upbox,fileURL); //上传前改变图片的格式 //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image(); //这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高 image.src=fileURL; image.onload=function () { canvas.width=image.width/2; canvas.height=image.width/2*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); newURL=canvas.toDataURL('image/jpeg',0.5); var base=newURL.substr(23); newFile=atob(base); } } reader.readAsDataURL(files[i]); filesArray.push(newURL); } },false); 上面的代码实现了将经过转换的图片的base64编码放入一个数组中，将这些代码传给后台。 这里有一点，本身base64可以利用javascript的window.atob()实现base64的转码，但是简单利用该函数进行转码不能转回图片，还需要blob对象中的一些东西，关于这个对象我并没有深入研究，只是知道，对于该对象的研究我会在接下来继续研究。后台可以解析base64，所以直接把base64传给后台也可以，关于base64转码的实现可以参考稀土掘金中的文章@用Canvas技术压缩要上传的图片。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:4:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"五.利用XMLHttpRequest,FormData实现文件上传 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:5:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"1.FormData对象 利用FormData对象可以创建一系列键值对来模拟一个完整的表单，然后再使用XMLHttpRequest发送这个表单，这样就不用像传统的表单那样写form。所以在新建一个FormData对象： var data=new FormData(); 然后就可以使用append()方法向该对象里添加字段，形成可以发送给后台的键值对。 ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:5:1","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"2.XMLHttpRequest对象 通过XMLHttpRequest可以很容易取回URL上的数据资源，可以取回的数据不仅仅是XML，除了支持HTTP还支持file，ftp协议。 通过下列代码可以获得一个XMLHttpRequest()实例。 然后利用open()初始化请求。 var xhr=new XMLHttpRequest(); xhr.open('post','uploader.php',true); xhr.send(data); ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:5:2","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"3.open方法 open可以写入的参数如下： void open( DOMString method, DOMString url, optional boolean async, optional DOMString user, optional DOMString password ); method：请求所使用的HTTP方法：例如’GET'，‘POST’，‘PUT’，‘DELETE’等，但是如果下个参数是非HTTP(S)的URL，则忽略该参数。 url：该请求所要访问的URL async：一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。 user：用户名,可选参数,为授权使用;默认参数为空string. password：密码,可选参数,为授权使用;默认参数为空string. ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:5:3","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"4.send()方法 发送请求. 如果该请求是异步模式(默认),该方法会立刻返回. 相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回. ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:5:4","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["Javascript"],"content":"综合以上，简单的一个上传图片代码实现如下： //创建缩略图样式 function createThumbnailFromUrl(context,fileURL) { //创建元素 var img=document.createElement('img'), imgBox=document.createElement('div'), imgContent=document.createElement('div'); //添加Class imgBox.classList.add('img-box'); imgContent.classList.add('img-content'); //动态插入创建的元素 context.appendChild(imgContent); imgContent.appendChild(imgBox); imgBox.appendChild(img); //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image(); image.src=fileURL; image.onload=function () { canvas.width=120; canvas.height=120*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); img.src=canvas.toDataURL('image/png',0.5); } } window.addEventListener('load',function () { var uploader=document.querySelectorAll('#uploader')[0]; var button=document.querySelectorAll('#button')[0]; var upbox=document.querySelectorAll('.upbox')[0]; var files,filesLen,newFileURL,newFile; var filesArray=[],newURL; var test=document.querySelectorAll('#test')[0]; //input选框change事件，取得文件，创建缩略图 uploader.addEventListener('change',function (event) { var e=event||window.event; var target=e.target; files=target.files; filesLen=files.length; for(let i=0;i\u003cfilesLen;i++){ var reader=new FileReader(); //文件读取结束后要做的事 reader.onload=function (event) { //读取用户选择的文件 var fileURL=event.target.result; //根据读取的文件创建缩略图 createThumbnailFromUrl(upbox,fileURL); //上传前改变图片的格式 //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image();//这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高 image.src=fileURL; image.onload=function () { canvas.width=image.width/2; canvas.height=image.width/2*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); newURL=canvas.toDataURL('image/jpeg',0.5); var base=newURL.substr(23); newFile=atob(base); } } reader.readAsDataURL(files[i]); filesArray.push(newURL); } },false); //button按钮点击上传 button.addEventListener('click',function () { if(filesLen.length!=0){ var data=new FormData(); var i=0; //将所有的经过转码后的base64组成的数组传给后台 while(i\u003cfilesLen){ data.append('file'+i,filesArray[i]); i++; } var xhr = new XMLHttpRequest(); xhr.open('post','uploader.php',true); xhr.onreadystatechange=function () { if(xhr.readyState==4){ console.log(xhr.responseText); } }; xhr.send(data); } }) },false); ","date":"2016-03-31","objectID":"/posts/2016-fileupload/:6:0","series":null,"tags":["H5","file","canvas"],"title":"文件上传（一）---H5 file API，canvas","uri":"/posts/2016-fileupload/"},{"categories":["HTML"],"content":"周四下午测试人员提出BUG，说我写的那个类支付宝密码框在按下Tab键时候无法像原生的form表单中的input那样被激活，当时的第一反应是，我的密码框原本就是用div模拟的，怎么可能想form表单一样在Tab键时候激活呢。但是当我打开支付宝官网，按下tab键后，密码框可以被激活，这激起了我的好奇心，也就有了后来对tabindex和document.activeElement的发现。废话不多说，进入正题。 ","date":"2016-03-26","objectID":"/posts/2016-activeelement/:0:0","series":null,"tags":["HTML5"],"title":"H5焦点管理---tabindex与document.activeElement","uri":"/posts/2016-activeelement/"},{"categories":["HTML"],"content":"HTML tabindex属 tabindex的设置 当Tab键用于导航时，tabindex属性规定元素的tab键控制次序，其中tabindex的值为阿拉伯数字，默认情况下越靠前的元素该值越小，所以我们可以通过人为改变tabindex的值来改变按下Tab键后可以被激活元素的激活顺序，只需要做如下设置： \u003cinput type=\"text\" tabindex=\"1\"\u003e \u003cinput type=\"text\" tabindex=\"2\"\u003e \u003cinput type=\"text\" tabindex=\"4\"\u003e \u003cinput type=\"text\" tabindex=\"3\"\u003e 以上代码在浏览器中按下Tab键激活顺序就是它们在HTML代码中的顺序，但是我在这里设置第三个input的tabindex比第四个的大，所以按下Tab键后，第四个input框的激活在第三个之前。 注意 前面说过tabindex的值越小，越被早激活，但是tabIndex的值要0~32767之间。 如果把tabindex值设置为负值（比如设置为tabindex=-1），则按下Tab键不会激活该元素，但是该元素的focus和blur事件仍然启动。 如果把tabindex设置为0，则带0值tabIndex的元素根据源代码（或默认页面行为）进行排序。 如果页面中出现多个tabindex值相同的元素，则浏览器会把这些元素的tabindex值看做0。 为div与span设置tabindex 默认情况下按下Tab键可以被选中或者激活的有a,area,button,input,object,select,textarea，但是在现代浏览器和IE9+中给div和span设置tabindex属性也可以被选中，在chrome中，被选中的元素会出现淡蓝色的边框。 ","date":"2016-03-26","objectID":"/posts/2016-activeelement/:0:1","series":null,"tags":["HTML5"],"title":"H5焦点管理---tabindex与document.activeElement","uri":"/posts/2016-activeelement/"},{"categories":["HTML"],"content":"H5焦点管理document.activeElement H5添加了辅助管理DOM焦点的document.activeElemnt属性，这个属性始终会引用DOM中当前获得了焦点的元素。元素获取焦点的方式有页面加载，用户输入（通常是通过按Tab键）和代码中调用focus()方法。 默认情况下，文档刚刚加载完，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。另外顺带提一句，判断是否获得焦点可以使用hasFocus()。 利用该属性，就可以知道当前哪个元素被Tab键激活，进而就可以获取到被激活元素的各类属性，比如可以在按下Tab键时候去输出当前被激活元素的class属性。代码如下： $(function(){ var $input=$('input'); $input.on('keydown',function(e){ var event=e||window.event; if(event.keyCode==9){ console.log(document.activeElement.attr('class')); } }); }); ","date":"2016-03-26","objectID":"/posts/2016-activeelement/:0:2","series":null,"tags":["HTML5"],"title":"H5焦点管理---tabindex与document.activeElement","uri":"/posts/2016-activeelement/"},{"categories":["HTML"],"content":"总结 基于以上两点，通过判断当前被激活的元素的class，就实现了让模拟的密码输入框有和原生的input一样在按下Tab键被激活。 ","date":"2016-03-26","objectID":"/posts/2016-activeelement/:0:3","series":null,"tags":["HTML5"],"title":"H5焦点管理---tabindex与document.activeElement","uri":"/posts/2016-activeelement/"},{"categories":["Javascript"],"content":"今天早上到公司，看到CTO要求调查关于前端如何实现图片格式转换，自己上网找了下关于canvas如何实现图片格式转换，其实还是蛮简单的，但是因为网上的教程着实写的简单，而且都一样，我也是醉了，所以写下这篇博客，以记录今天的调查结果。 使用Javasript将图片写入画布 function convertImageToCanvas(image) { var canvas = document.createElement(\"canvas\"); canvas.width = image.width; canvas.height = image.height; canvas.getContext(\"2d\").drawImage(image, 0, 0); return canvas; } 用JavaScript将画布保持成图片格式 function convertCanvasToImage(canvas) { var image = new Image(); //这里的image后面可以写png，jpeg，但是不能写jpg，写了不会转换的 image.src = canvas.toDataURL(\"image/jpeg\"); return image; } 调用函数实现转换 函数convertImageToCanvas需要传入一个image对象，这个对象需要我们手动去获取，例如，可以在html页面中写入img标签并引入图片，然后利用js获取img对象，将img对象传入该函数，即可获得返回的canvas对象，再将该canvas对象传入函数convertCanvasToImage即可获得返回的image，但是，这里获得的是base64的编码的图片，本身绘制在canvas画布上的图片右键保存还是png图，所以，要想获得转换后的图片，可以利用a标签在href中写入base64编码获得，点击a标签可以跳转到转换后的图片。关于如将base64编码的图片解码成图片，因为今天下午事儿多，没顾上研究，有时间，研究一下。 实现代码如下： var img=document.getElementById('img'); var body=document.getElementById('body'); var canvas=convertImageToCanvas(img); convertCanvasToImage(canvas); var link=document.createElement('a'); body.appendChild(link); link.innerHTML('跳转图片'); 以上代码可以在点击link链接后得到转换后的图片，今天就研究到这些，以后有时间再继续研究完善。 ","date":"2016-03-22","objectID":"/posts/2016-canvas/:0:0","series":null,"tags":["Javascript"],"title":"H5 Canvas实现图片格式的转换","uri":"/posts/2016-canvas/"}]